var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except2, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except2)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc2 = __getOwnPropDesc(from, key2)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options2) {
        this.name = name;
        this.startTime = options2?.startTime || _performanceNow();
        this.detail = options2?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e3) => e3.name !== markName) : this._entries.filter((e3) => e3.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e3) => e3.name !== measureName) : this._entries.filter((e3) => e3.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e3) => e3.entryType !== "resource" || e3.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e3) => e3.name === name && (!type || e3.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e3) => e3.entryType === type);
      }
      mark(name, options2) {
        const entry = new PerformanceMark(name, options2);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options2) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options2) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options2) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/.pnpm/wrangler@4.19.1_@cloudflare+workers-types@4.20250610.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/.pnpm/wrangler@4.19.1_@cloudflare+workers-types@4.20250610.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count3, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      ref() {
      }
      unref() {
      }
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      mainModule = void 0;
      domain = void 0;
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, exit, platform, nextTick, unenvProcess, abort, addListener, allowedNodeEnvironmentFlags, hasUncaughtExceptionCaptureCallback, setUncaughtExceptionCaptureCallback, loadEnvFile, sourceMapsEnabled, arch, argv, argv0, chdir, config, connected, constrainedMemory, availableMemory, cpuUsage, cwd, debugPort, dlopen, disconnect, emit, emitWarning, env, eventNames, execArgv, execPath, finalization, features, getActiveResourcesInfo, getMaxListeners, hrtime3, kill, listeners, listenerCount, memoryUsage, on, off, once, pid, ppid, prependListener, prependOnceListener, rawListeners, release, removeAllListeners, removeListener, report, resourceUsage, setMaxListeners, setSourceMapsEnabled, stderr, stdin, stdout, title, throwDeprecation, traceDeprecation, umask, uptime, version, versions, domain, initgroups, moduleLoadList, reallyExit, openStdin, assert2, binding, send, exitCode, channel, getegid, geteuid, getgid, getgroups, getuid, setegid, seteuid, setgid, setgroups, setuid, permission, mainModule, _events, _eventsCount, _exiting, _maxListeners, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _disconnect, _handleQueue, _pendingMessage, _channel, _send, _linkedBinding, _process, process_default;
var init_process2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    ({ exit, platform, nextTick } = getBuiltinModule(
      "node:process"
    ));
    unenvProcess = new Process({
      env: globalProcess.env,
      hrtime,
      nextTick
    });
    ({
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      finalization,
      features,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      on,
      off,
      once,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    } = unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/.pnpm/wrangler@4.19.1_@cloudflare+workers-types@4.20250610.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/.pnpm/wrangler@4.19.1_@cloudflare+workers-types@4.20250610.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// .svelte-kit/output/server/chunks/equality.js
function run_all(arr2) {
  for (var i = 0; i < arr2.length; i++) {
    arr2[i]();
  }
}
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b2) {
  return a != a ? b2 == b2 : a !== b2 || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
var is_array, index_of, array_from, define_property, get_descriptor, object_prototype, array_prototype, get_prototype_of, is_extensible, noop;
var init_equality = __esm({
  ".svelte-kit/output/server/chunks/equality.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    is_array = Array.isArray;
    index_of = Array.prototype.indexOf;
    array_from = Array.from;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    object_prototype = Object.prototype;
    array_prototype = Array.prototype;
    get_prototype_of = Object.getPrototypeOf;
    is_extensible = Object.isExtensible;
    noop = /* @__PURE__ */ __name(() => {
    }, "noop");
    __name(run_all, "run_all");
    __name(equals, "equals");
    __name(safe_not_equal, "safe_not_equal");
    __name(safe_equals, "safe_equals");
  }
});

// ../node_modules/clsx/dist/clsx.mjs
var init_clsx = __esm({
  "../node_modules/clsx/dist/clsx.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// .svelte-kit/output/server/chunks/index2.js
function lifecycle_outside_component(name) {
  {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last = 0;
  while (pattern2.test(str)) {
    const i = pattern2.lastIndex - 1;
    const ch = str[i];
    escaped2 += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped2 + str.substring(last);
}
function attr(name, value, is_boolean = false) {
  if (value == null || !value && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value) || value;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
function to_class(value, hash5, directives) {
  var classname = "" + value;
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a = 0;
        while ((a = classname.indexOf(key2, a)) >= 0) {
          var b2 = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b2 === classname.length || whitespace.includes(classname[b2]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b2 + 1);
          } else {
            a = b2;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function getContext(key2) {
  const context_map = get_or_init_context_map();
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
function setContext(key2, context3) {
  get_or_init_context_map().set(key2, context3);
  return context3;
}
function get_or_init_context_map(name) {
  if (current_component === null) {
    lifecycle_outside_component();
  }
  return current_component.c ??= new Map(get_parent_context(current_component) || void 0);
}
function push(fn) {
  current_component = { p: current_component, c: null, d: null };
}
function pop() {
  var component10 = (
    /** @type {Component} */
    current_component
  );
  var ondestroy = component10.d;
  if (ondestroy) {
    on_destroy.push(...ondestroy);
  }
  current_component = component10.p;
}
function get_parent_context(component_context2) {
  let parent = component_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
function props_id_generator(prefix) {
  let uid2 = 1;
  return () => `${prefix}s${uid2++}`;
}
function render(component10, options2 = {}) {
  const payload = new Payload(options2.idPrefix ? options2.idPrefix + "-" : "");
  const prev_on_destroy = on_destroy;
  on_destroy = [];
  payload.out += BLOCK_OPEN;
  if (options2.context) {
    push();
    current_component.c = options2.context;
  }
  component10(payload, options2.props ?? {}, {}, {});
  if (options2.context) {
    pop();
  }
  payload.out += BLOCK_CLOSE;
  for (const cleanup of on_destroy) cleanup();
  on_destroy = prev_on_destroy;
  let head = payload.head.out + payload.head.title;
  for (const { hash: hash5, code } of payload.css) {
    head += `<style id="${hash5}">${code}</style>`;
  }
  return {
    head,
    html: payload.out,
    body: payload.out
  };
}
function attr_class(value, hash5, directives) {
  var result = to_class(value, hash5, directives);
  return result ? ` class="${escape_html(result, true)}"` : "";
}
function ensure_array_like(array_like_or_iterator) {
  if (array_like_or_iterator) {
    return array_like_or_iterator.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }
  return [];
}
var HYDRATION_START, HYDRATION_END, HYDRATION_ERROR, UNINITIALIZED, ATTR_REGEX, CONTENT_REGEX, replacements, whitespace, current_component, BLOCK_OPEN, BLOCK_CLOSE, HeadPayload, Payload, on_destroy;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    HYDRATION_START = "[";
    HYDRATION_END = "]";
    HYDRATION_ERROR = {};
    UNINITIALIZED = Symbol();
    __name(lifecycle_outside_component, "lifecycle_outside_component");
    ATTR_REGEX = /[&"<]/g;
    CONTENT_REGEX = /[&<]/g;
    __name(escape_html, "escape_html");
    replacements = {
      translate: /* @__PURE__ */ new Map([
        [true, "yes"],
        [false, "no"]
      ])
    };
    __name(attr, "attr");
    whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
    __name(to_class, "to_class");
    current_component = null;
    __name(getContext, "getContext");
    __name(setContext, "setContext");
    __name(get_or_init_context_map, "get_or_init_context_map");
    __name(push, "push");
    __name(pop, "pop");
    __name(get_parent_context, "get_parent_context");
    BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
    BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
    HeadPayload = class {
      static {
        __name(this, "HeadPayload");
      }
      /** @type {Set<{ hash: string; code: string }>} */
      css = /* @__PURE__ */ new Set();
      out = "";
      uid = /* @__PURE__ */ __name(() => "", "uid");
      title = "";
      constructor(css = /* @__PURE__ */ new Set(), out = "", title2 = "", uid2 = () => "") {
        this.css = css;
        this.out = out;
        this.title = title2;
        this.uid = uid2;
      }
    };
    Payload = class {
      static {
        __name(this, "Payload");
      }
      /** @type {Set<{ hash: string; code: string }>} */
      css = /* @__PURE__ */ new Set();
      out = "";
      uid = /* @__PURE__ */ __name(() => "", "uid");
      select_value = void 0;
      head = new HeadPayload();
      constructor(id_prefix = "") {
        this.uid = props_id_generator(id_prefix);
        this.head.uid = this.uid;
      }
    };
    __name(props_id_generator, "props_id_generator");
    on_destroy = [];
    __name(render, "render");
    __name(attr_class, "attr_class");
    __name(ensure_array_like, "ensure_array_like");
  }
});

// node_modules/.pnpm/cookie@1.0.2/node_modules/cookie/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/cookie@1.0.2/node_modules/cookie/dist/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = parse5;
    exports.serialize = serialize2;
    var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
    var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    var __toString = Object.prototype.toString;
    var NullObject = /* @__PURE__ */ (() => {
      const C = /* @__PURE__ */ __name(function() {
      }, "C");
      C.prototype = /* @__PURE__ */ Object.create(null);
      return C;
    })();
    function parse5(str, options2) {
      const obj = new NullObject();
      const len = str.length;
      if (len < 2)
        return obj;
      const dec = options2?.decode || decode;
      let index10 = 0;
      do {
        const eqIdx = str.indexOf("=", index10);
        if (eqIdx === -1)
          break;
        const colonIdx = str.indexOf(";", index10);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
          index10 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const keyStartIdx = startIndex(str, index10, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key2 = str.slice(keyStartIdx, keyEndIdx);
        if (obj[key2] === void 0) {
          let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
          let valEndIdx = endIndex(str, endIdx, valStartIdx);
          const value = dec(str.slice(valStartIdx, valEndIdx));
          obj[key2] = value;
        }
        index10 = endIdx + 1;
      } while (index10 < len);
      return obj;
    }
    __name(parse5, "parse");
    function startIndex(str, index10, max) {
      do {
        const code = str.charCodeAt(index10);
        if (code !== 32 && code !== 9)
          return index10;
      } while (++index10 < max);
      return max;
    }
    __name(startIndex, "startIndex");
    function endIndex(str, index10, min) {
      while (index10 > min) {
        const code = str.charCodeAt(--index10);
        if (code !== 32 && code !== 9)
          return index10 + 1;
      }
      return min;
    }
    __name(endIndex, "endIndex");
    function serialize2(name, val, options2) {
      const enc = options2?.encode || encodeURIComponent;
      if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
      }
      const value = enc(val);
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
      }
      let str = name + "=" + value;
      if (!options2)
        return str;
      if (options2.maxAge !== void 0) {
        if (!Number.isInteger(options2.maxAge)) {
          throw new TypeError(`option maxAge is invalid: ${options2.maxAge}`);
        }
        str += "; Max-Age=" + options2.maxAge;
      }
      if (options2.domain) {
        if (!domainValueRegExp.test(options2.domain)) {
          throw new TypeError(`option domain is invalid: ${options2.domain}`);
        }
        str += "; Domain=" + options2.domain;
      }
      if (options2.path) {
        if (!pathValueRegExp.test(options2.path)) {
          throw new TypeError(`option path is invalid: ${options2.path}`);
        }
        str += "; Path=" + options2.path;
      }
      if (options2.expires) {
        if (!isDate2(options2.expires) || !Number.isFinite(options2.expires.valueOf())) {
          throw new TypeError(`option expires is invalid: ${options2.expires}`);
        }
        str += "; Expires=" + options2.expires.toUTCString();
      }
      if (options2.httpOnly) {
        str += "; HttpOnly";
      }
      if (options2.secure) {
        str += "; Secure";
      }
      if (options2.partitioned) {
        str += "; Partitioned";
      }
      if (options2.priority) {
        const priority = typeof options2.priority === "string" ? options2.priority.toLowerCase() : void 0;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError(`option priority is invalid: ${options2.priority}`);
        }
      }
      if (options2.sameSite) {
        const sameSite = typeof options2.sameSite === "string" ? options2.sameSite.toLowerCase() : options2.sameSite;
        switch (sameSite) {
          case true:
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError(`option sameSite is invalid: ${options2.sameSite}`);
        }
      }
      return str;
    }
    __name(serialize2, "serialize");
    function decode(str) {
      if (str.indexOf("%") === -1)
        return str;
      try {
        return decodeURIComponent(str);
      } catch (e3) {
        return str;
      }
    }
    __name(decode, "decode");
    function isDate2(val) {
      return __toString.call(val) === "[object Date]";
    }
    __name(isDate2, "isDate");
  }
});

// node-built-in-modules:buffer
import libDefault from "buffer";
var require_buffer = __commonJS({
  "node-built-in-modules:buffer"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault;
  }
});

// node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var buffer2 = require_buffer();
    var Buffer7 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer7.from && Buffer7.alloc && Buffer7.allocUnsafe && Buffer7.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer7(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer7.prototype);
    copyProps(Buffer7, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer7(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer7(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer7(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size2);
    };
  }
});

// node-built-in-modules:stream
import libDefault2 from "stream";
var require_stream = __commonJS({
  "node-built-in-modules:stream"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault2;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/util/legacy-types.mjs
var isRegExp, isDate, isBoolean, isNull, isNullOrUndefined, isNumber, isString, isSymbol, isUndefined, isFunction, isBuffer, isObject, isError, isPrimitive;
var init_legacy_types = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/util/legacy-types.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    isRegExp = /* @__PURE__ */ __name((val) => val instanceof RegExp, "isRegExp");
    isDate = /* @__PURE__ */ __name((val) => val instanceof Date, "isDate");
    isBoolean = /* @__PURE__ */ __name((val) => typeof val === "boolean", "isBoolean");
    isNull = /* @__PURE__ */ __name((val) => val === null, "isNull");
    isNullOrUndefined = /* @__PURE__ */ __name((val) => val === null || val === void 0, "isNullOrUndefined");
    isNumber = /* @__PURE__ */ __name((val) => typeof val === "number", "isNumber");
    isString = /* @__PURE__ */ __name((val) => typeof val === "string", "isString");
    isSymbol = /* @__PURE__ */ __name((val) => typeof val === "symbol", "isSymbol");
    isUndefined = /* @__PURE__ */ __name((val) => val === void 0, "isUndefined");
    isFunction = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction");
    isBuffer = /* @__PURE__ */ __name((val) => {
      return val && typeof val === "object" && typeof val.copy === "function" && typeof val.fill === "function" && typeof val.readUInt8 === "function";
    }, "isBuffer");
    isObject = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object" && Object.getPrototypeOf(val).isPrototypeOf(Object), "isObject");
    isError = /* @__PURE__ */ __name((val) => val instanceof Error, "isError");
    isPrimitive = /* @__PURE__ */ __name((val) => {
      if (typeof val === "object") {
        return val === null;
      }
      return typeof val !== "function";
    }, "isPrimitive");
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/util/log.mjs
var init_log = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/util/log.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/util.mjs
import types from "node:util/types";
import { default as default2 } from "node:util/types";
var TextDecoder2, TextEncoder2, _errnoException, _exceptionWithHostPort, getSystemErrorMap, getSystemErrorName, parseEnv, styleText;
var init_util = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/util.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_legacy_types();
    init_log();
    TextDecoder2 = globalThis.TextDecoder;
    TextEncoder2 = globalThis.TextEncoder;
    _errnoException = /* @__PURE__ */ notImplemented("util._errnoException");
    _exceptionWithHostPort = /* @__PURE__ */ notImplemented("util._exceptionWithHostPort");
    getSystemErrorMap = /* @__PURE__ */ notImplemented("util.getSystemErrorMap");
    getSystemErrorName = /* @__PURE__ */ notImplemented("util.getSystemErrorName");
    parseEnv = /* @__PURE__ */ notImplemented("util.parseEnv");
    styleText = /* @__PURE__ */ notImplemented("util.styleText");
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs
var workerdUtil, MIMEParams, MIMEType, TextDecoder3, TextEncoder3, _extend, aborted, callbackify, debug3, debuglog, deprecate, format, formatWithOptions, getCallSite, inherits, inspect, isArray, isDeepStrictEqual, log3, parseArgs, promisify, stripVTControlCharacters, toUSVString, transferableAbortController, transferableAbortSignal, types2, util_default;
var init_util2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util();
    workerdUtil = process.getBuiltinModule("node:util");
    ({
      MIMEParams,
      MIMEType,
      TextDecoder: TextDecoder3,
      TextEncoder: TextEncoder3,
      _extend: (
        // @ts-expect-error missing types?
        _extend
      ),
      aborted,
      callbackify,
      debug: debug3,
      debuglog,
      deprecate,
      format,
      formatWithOptions,
      getCallSite: (
        // @ts-expect-error unknown type
        getCallSite
      ),
      inherits,
      inspect,
      isArray,
      isDeepStrictEqual,
      log: log3,
      parseArgs,
      promisify,
      stripVTControlCharacters,
      toUSVString,
      transferableAbortController,
      transferableAbortSignal
    } = workerdUtil);
    types2 = workerdUtil.types;
    util_default = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      _errnoException,
      _exceptionWithHostPort,
      // @ts-expect-error unenv has unknown type
      getSystemErrorMap,
      // @ts-expect-error unenv has unknown type
      getSystemErrorName,
      isBoolean,
      isBuffer,
      isDate,
      isError,
      isFunction,
      isNull,
      isNullOrUndefined,
      isNumber,
      isObject,
      isPrimitive,
      isRegExp,
      isString,
      isSymbol,
      isUndefined,
      // @ts-expect-error unenv has unknown type
      parseEnv,
      // @ts-expect-error unenv has unknown type
      styleText,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      _extend,
      aborted,
      callbackify,
      debug: debug3,
      debuglog,
      deprecate,
      format,
      formatWithOptions,
      getCallSite,
      inherits,
      inspect,
      isArray,
      isDeepStrictEqual,
      log: log3,
      MIMEParams,
      MIMEType,
      parseArgs,
      promisify,
      stripVTControlCharacters,
      TextDecoder: TextDecoder3,
      TextEncoder: TextEncoder3,
      toUSVString,
      transferableAbortController,
      transferableAbortSignal,
      // special-cased deep merged symbols
      types: types2
    };
  }
});

// node-built-in-modules:util
var require_util = __commonJS({
  "node-built-in-modules:util"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util2();
    module.exports = util_default;
  }
});

// node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/data-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer7 = require_safe_buffer().Buffer;
    var Stream3 = require_stream();
    var util = require_util();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer7.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer7.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    __name(DataStream, "DataStream");
    util.inherits(DataStream, Stream3);
    DataStream.prototype.write = /* @__PURE__ */ __name(function write(data) {
      this.buffer = Buffer7.concat([this.buffer, Buffer7.from(data)]);
      this.emit("data", data);
    }, "write");
    DataStream.prototype.end = /* @__PURE__ */ __name(function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    }, "end");
    module.exports = DataStream;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs
var subtle;
var init_web = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    subtle = globalThis.crypto?.subtle;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs
var webcrypto, createCipher, createDecipher, pseudoRandomBytes, Cipher, Decipher;
var init_node = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    webcrypto = new Proxy(globalThis.crypto, { get(_, key2) {
      if (key2 === "CryptoKey") {
        return globalThis.CryptoKey;
      }
      if (typeof globalThis.crypto[key2] === "function") {
        return globalThis.crypto[key2].bind(globalThis.crypto);
      }
      return globalThis.crypto[key2];
    } });
    createCipher = /* @__PURE__ */ notImplemented("crypto.createCipher");
    createDecipher = /* @__PURE__ */ notImplemented("crypto.createDecipher");
    pseudoRandomBytes = /* @__PURE__ */ notImplemented("crypto.pseudoRandomBytes");
    Cipher = /* @__PURE__ */ notImplementedClass("crypto.Cipher");
    Decipher = /* @__PURE__ */ notImplementedClass("crypto.Decipher");
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs
var SSL_OP_ALL, SSL_OP_ALLOW_NO_DHE_KEX, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, SSL_OP_CIPHER_SERVER_PREFERENCE, SSL_OP_CISCO_ANYCONNECT, SSL_OP_COOKIE_EXCHANGE, SSL_OP_CRYPTOPRO_TLSEXT_BUG, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS, SSL_OP_LEGACY_SERVER_CONNECT, SSL_OP_NO_COMPRESSION, SSL_OP_NO_ENCRYPT_THEN_MAC, SSL_OP_NO_QUERY_MTU, SSL_OP_NO_RENEGOTIATION, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TICKET, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1, SSL_OP_NO_TLSv1_2, SSL_OP_NO_TLSv1_3, SSL_OP_PRIORITIZE_CHACHA, SSL_OP_TLS_ROLLBACK_BUG, ENGINE_METHOD_RSA, ENGINE_METHOD_DSA, ENGINE_METHOD_DH, ENGINE_METHOD_RAND, ENGINE_METHOD_EC, ENGINE_METHOD_CIPHERS, ENGINE_METHOD_DIGESTS, ENGINE_METHOD_PKEY_METHS, ENGINE_METHOD_PKEY_ASN1_METHS, ENGINE_METHOD_ALL, ENGINE_METHOD_NONE, DH_CHECK_P_NOT_SAFE_PRIME, DH_CHECK_P_NOT_PRIME, DH_UNABLE_TO_CHECK_GENERATOR, DH_NOT_SUITABLE_GENERATOR, RSA_PKCS1_PADDING, RSA_NO_PADDING, RSA_PKCS1_OAEP_PADDING, RSA_X931_PADDING, RSA_PKCS1_PSS_PADDING, RSA_PSS_SALTLEN_DIGEST, RSA_PSS_SALTLEN_MAX_SIGN, RSA_PSS_SALTLEN_AUTO, POINT_CONVERSION_COMPRESSED, POINT_CONVERSION_UNCOMPRESSED, POINT_CONVERSION_HYBRID, defaultCoreCipherList, defaultCipherList, OPENSSL_VERSION_NUMBER, TLS1_VERSION, TLS1_1_VERSION, TLS1_2_VERSION, TLS1_3_VERSION;
var init_constants = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SSL_OP_ALL = 2147485776;
    SSL_OP_ALLOW_NO_DHE_KEX = 1024;
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 262144;
    SSL_OP_CIPHER_SERVER_PREFERENCE = 4194304;
    SSL_OP_CISCO_ANYCONNECT = 32768;
    SSL_OP_COOKIE_EXCHANGE = 8192;
    SSL_OP_CRYPTOPRO_TLSEXT_BUG = 2147483648;
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 2048;
    SSL_OP_LEGACY_SERVER_CONNECT = 4;
    SSL_OP_NO_COMPRESSION = 131072;
    SSL_OP_NO_ENCRYPT_THEN_MAC = 524288;
    SSL_OP_NO_QUERY_MTU = 4096;
    SSL_OP_NO_RENEGOTIATION = 1073741824;
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 65536;
    SSL_OP_NO_SSLv2 = 0;
    SSL_OP_NO_SSLv3 = 33554432;
    SSL_OP_NO_TICKET = 16384;
    SSL_OP_NO_TLSv1 = 67108864;
    SSL_OP_NO_TLSv1_1 = 268435456;
    SSL_OP_NO_TLSv1_2 = 134217728;
    SSL_OP_NO_TLSv1_3 = 536870912;
    SSL_OP_PRIORITIZE_CHACHA = 2097152;
    SSL_OP_TLS_ROLLBACK_BUG = 8388608;
    ENGINE_METHOD_RSA = 1;
    ENGINE_METHOD_DSA = 2;
    ENGINE_METHOD_DH = 4;
    ENGINE_METHOD_RAND = 8;
    ENGINE_METHOD_EC = 2048;
    ENGINE_METHOD_CIPHERS = 64;
    ENGINE_METHOD_DIGESTS = 128;
    ENGINE_METHOD_PKEY_METHS = 512;
    ENGINE_METHOD_PKEY_ASN1_METHS = 1024;
    ENGINE_METHOD_ALL = 65535;
    ENGINE_METHOD_NONE = 0;
    DH_CHECK_P_NOT_SAFE_PRIME = 2;
    DH_CHECK_P_NOT_PRIME = 1;
    DH_UNABLE_TO_CHECK_GENERATOR = 4;
    DH_NOT_SUITABLE_GENERATOR = 8;
    RSA_PKCS1_PADDING = 1;
    RSA_NO_PADDING = 3;
    RSA_PKCS1_OAEP_PADDING = 4;
    RSA_X931_PADDING = 5;
    RSA_PKCS1_PSS_PADDING = 6;
    RSA_PSS_SALTLEN_DIGEST = -1;
    RSA_PSS_SALTLEN_MAX_SIGN = -2;
    RSA_PSS_SALTLEN_AUTO = -2;
    POINT_CONVERSION_COMPRESSED = 2;
    POINT_CONVERSION_UNCOMPRESSED = 4;
    POINT_CONVERSION_HYBRID = 6;
    defaultCoreCipherList = "";
    defaultCipherList = "";
    OPENSSL_VERSION_NUMBER = 0;
    TLS1_VERSION = 0;
    TLS1_1_VERSION = 0;
    TLS1_2_VERSION = 0;
    TLS1_3_VERSION = 0;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/crypto.mjs
var constants;
var init_crypto = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/crypto.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_constants();
    init_web();
    init_node();
    constants = {
      OPENSSL_VERSION_NUMBER,
      SSL_OP_ALL,
      SSL_OP_ALLOW_NO_DHE_KEX,
      SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,
      SSL_OP_CIPHER_SERVER_PREFERENCE,
      SSL_OP_CISCO_ANYCONNECT,
      SSL_OP_COOKIE_EXCHANGE,
      SSL_OP_CRYPTOPRO_TLSEXT_BUG,
      SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,
      SSL_OP_LEGACY_SERVER_CONNECT,
      SSL_OP_NO_COMPRESSION,
      SSL_OP_NO_ENCRYPT_THEN_MAC,
      SSL_OP_NO_QUERY_MTU,
      SSL_OP_NO_RENEGOTIATION,
      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,
      SSL_OP_NO_SSLv2,
      SSL_OP_NO_SSLv3,
      SSL_OP_NO_TICKET,
      SSL_OP_NO_TLSv1,
      SSL_OP_NO_TLSv1_1,
      SSL_OP_NO_TLSv1_2,
      SSL_OP_NO_TLSv1_3,
      SSL_OP_PRIORITIZE_CHACHA,
      SSL_OP_TLS_ROLLBACK_BUG,
      ENGINE_METHOD_RSA,
      ENGINE_METHOD_DSA,
      ENGINE_METHOD_DH,
      ENGINE_METHOD_RAND,
      ENGINE_METHOD_EC,
      ENGINE_METHOD_CIPHERS,
      ENGINE_METHOD_DIGESTS,
      ENGINE_METHOD_PKEY_METHS,
      ENGINE_METHOD_PKEY_ASN1_METHS,
      ENGINE_METHOD_ALL,
      ENGINE_METHOD_NONE,
      DH_CHECK_P_NOT_SAFE_PRIME,
      DH_CHECK_P_NOT_PRIME,
      DH_UNABLE_TO_CHECK_GENERATOR,
      DH_NOT_SUITABLE_GENERATOR,
      RSA_PKCS1_PADDING,
      RSA_NO_PADDING,
      RSA_PKCS1_OAEP_PADDING,
      RSA_X931_PADDING,
      RSA_PKCS1_PSS_PADDING,
      RSA_PSS_SALTLEN_DIGEST,
      RSA_PSS_SALTLEN_MAX_SIGN,
      RSA_PSS_SALTLEN_AUTO,
      defaultCoreCipherList,
      TLS1_VERSION,
      TLS1_1_VERSION,
      TLS1_2_VERSION,
      TLS1_3_VERSION,
      POINT_CONVERSION_COMPRESSED,
      POINT_CONVERSION_UNCOMPRESSED,
      POINT_CONVERSION_HYBRID,
      defaultCipherList
    };
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs
var workerdCrypto, Certificate, checkPrime, checkPrimeSync, Cipheriv, createCipheriv, createDecipheriv, createDiffieHellman, createDiffieHellmanGroup, createECDH, createHash, createHmac, createPrivateKey, createPublicKey, createSecretKey, createSign, createVerify, Decipheriv, diffieHellman, DiffieHellman, DiffieHellmanGroup, ECDH, fips, generateKey, generateKeyPair, generateKeyPairSync, generateKeySync, generatePrime, generatePrimeSync, getCipherInfo, getCiphers, getCurves, getDiffieHellman, getFips, getHashes, getRandomValues, hash, Hash, hkdf, hkdfSync, Hmac, KeyObject, pbkdf2, pbkdf2Sync, privateDecrypt, privateEncrypt, publicDecrypt, publicEncrypt, randomBytes, randomFill, randomFillSync, randomInt, randomUUID, scrypt, scryptSync, secureHeapUsed, setEngine, setFips, sign, Sign, subtle2, timingSafeEqual, verify, Verify, X509Certificate, webcrypto2, crypto_default;
var init_crypto2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_crypto();
    workerdCrypto = process.getBuiltinModule("node:crypto");
    ({
      Certificate,
      checkPrime,
      checkPrimeSync,
      Cipheriv: (
        // @ts-expect-error
        Cipheriv
      ),
      createCipheriv,
      createDecipheriv,
      createDiffieHellman,
      createDiffieHellmanGroup,
      createECDH,
      createHash,
      createHmac,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
      createSign,
      createVerify,
      Decipheriv: (
        // @ts-expect-error
        Decipheriv
      ),
      diffieHellman,
      DiffieHellman,
      DiffieHellmanGroup,
      ECDH,
      fips,
      generateKey,
      generateKeyPair,
      generateKeyPairSync,
      generateKeySync,
      generatePrime,
      generatePrimeSync,
      getCipherInfo,
      getCiphers,
      getCurves,
      getDiffieHellman,
      getFips,
      getHashes,
      getRandomValues,
      hash,
      Hash,
      hkdf,
      hkdfSync,
      Hmac,
      KeyObject,
      pbkdf2,
      pbkdf2Sync,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      randomBytes,
      randomFill,
      randomFillSync,
      randomInt,
      randomUUID,
      scrypt,
      scryptSync,
      secureHeapUsed,
      setEngine,
      setFips,
      sign,
      Sign,
      subtle: subtle2,
      timingSafeEqual,
      verify,
      Verify,
      X509Certificate
    } = workerdCrypto);
    webcrypto2 = {
      // @ts-expect-error
      CryptoKey: webcrypto.CryptoKey,
      getRandomValues,
      randomUUID,
      subtle: subtle2
    };
    crypto_default = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      Certificate,
      Cipher,
      Cipheriv,
      Decipher,
      Decipheriv,
      ECDH,
      Sign,
      Verify,
      X509Certificate,
      // @ts-expect-error @types/node is out of date - this is a bug in typings
      constants,
      createCipheriv,
      createDecipheriv,
      createECDH,
      createSign,
      createVerify,
      diffieHellman,
      getCipherInfo,
      hash,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      scrypt,
      scryptSync,
      sign,
      verify,
      // default-only export from unenv
      // @ts-expect-error unenv has unknown type
      createCipher,
      // @ts-expect-error unenv has unknown type
      createDecipher,
      // @ts-expect-error unenv has unknown type
      pseudoRandomBytes,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      DiffieHellman,
      DiffieHellmanGroup,
      Hash,
      Hmac,
      KeyObject,
      checkPrime,
      checkPrimeSync,
      createDiffieHellman,
      createDiffieHellmanGroup,
      createHash,
      createHmac,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
      generateKey,
      generateKeyPair,
      generateKeyPairSync,
      generateKeySync,
      generatePrime,
      generatePrimeSync,
      getCiphers,
      getCurves,
      getDiffieHellman,
      getFips,
      getHashes,
      getRandomValues,
      hkdf,
      hkdfSync,
      pbkdf2,
      pbkdf2Sync,
      randomBytes,
      randomFill,
      randomFillSync,
      randomInt,
      randomUUID,
      secureHeapUsed,
      setEngine,
      setFips,
      subtle: subtle2,
      timingSafeEqual,
      // default-only export from workerd
      fips,
      // special-cased deep merged symbols
      webcrypto: webcrypto2
    };
  }
});

// node-built-in-modules:crypto
var require_crypto = __commonJS({
  "node-built-in-modules:crypto"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_crypto2();
    module.exports = crypto_default;
  }
});

// node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    __name(getParamSize, "getParamSize");
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    __name(getParamBytesForAlg, "getParamBytesForAlg");
    module.exports = getParamBytesForAlg;
  }
});

// node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/.pnpm/ecdsa-sig-formatter@1.0.11/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer7 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base642) {
      return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(base64Url, "base64Url");
    function signatureAsBuffer(signature) {
      if (Buffer7.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer7.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    __name(signatureAsBuffer, "signatureAsBuffer");
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer7.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o2 = offset; offset < o2 + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    __name(derToJose, "derToJose");
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    __name(countPadding, "countPadding");
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer7.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    __name(joseToDer, "joseToDer");
    module.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/.pnpm/buffer-equal-constant-time@1.0.1/node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/.pnpm/buffer-equal-constant-time@1.0.1/node_modules/buffer-equal-constant-time/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer7 = require_buffer().Buffer;
    var SlowBuffer = require_buffer().SlowBuffer;
    module.exports = bufferEq;
    function bufferEq(a, b2) {
      if (!Buffer7.isBuffer(a) || !Buffer7.isBuffer(b2)) {
        return false;
      }
      if (a.length !== b2.length) {
        return false;
      }
      var c2 = 0;
      for (var i = 0; i < a.length; i++) {
        c2 |= a[i] ^ b2[i];
      }
      return c2 === 0;
    }
    __name(bufferEq, "bufferEq");
    bufferEq.install = function() {
      Buffer7.prototype.equal = SlowBuffer.prototype.equal = /* @__PURE__ */ __name(function equal(that) {
        return bufferEq(this, that);
      }, "equal");
    };
    var origBufEqual = Buffer7.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer7.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/.pnpm/jwa@1.4.2/node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/.pnpm/jwa@1.4.2/node_modules/jwa/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer7 = require_safe_buffer().Buffer;
    var crypto3 = require_crypto();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require_util();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto3.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key2) {
      if (Buffer7.isBuffer(key2)) {
        return;
      }
      if (typeof key2 === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2 !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key2.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    __name(checkIsPublicKey, "checkIsPublicKey");
    function checkIsPrivateKey(key2) {
      if (Buffer7.isBuffer(key2)) {
        return;
      }
      if (typeof key2 === "string") {
        return;
      }
      if (typeof key2 === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    __name(checkIsPrivateKey, "checkIsPrivateKey");
    function checkIsSecretKey(key2) {
      if (Buffer7.isBuffer(key2)) {
        return;
      }
      if (typeof key2 === "string") {
        return key2;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key2 !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key2.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key2.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    __name(checkIsSecretKey, "checkIsSecretKey");
    function fromBase64(base642) {
      return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(fromBase64, "fromBase64");
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    __name(toBase64, "toBase64");
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    __name(typeError, "typeError");
    function bufferOrString(obj) {
      return Buffer7.isBuffer(obj) || typeof obj === "string";
    }
    __name(bufferOrString, "bufferOrString");
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    __name(normalizeInput, "normalizeInput");
    function createHmacSigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac2 = crypto3.createHmac("sha" + bits, secret);
        var sig = (hmac2.update(thing), hmac2.digest("base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createHmacSigner, "createHmacSigner");
    var bufferEqual;
    var timingSafeEqual2 = "timingSafeEqual" in crypto3 ? /* @__PURE__ */ __name(function timingSafeEqual3(a, b2) {
      if (a.byteLength !== b2.byteLength) {
        return false;
      }
      return crypto3.timingSafeEqual(a, b2);
    }, "timingSafeEqual") : /* @__PURE__ */ __name(function timingSafeEqual3(a, b2) {
      if (!bufferEqual) {
        bufferEqual = require_buffer_equal_constant_time();
      }
      return bufferEqual(a, b2);
    }, "timingSafeEqual");
    function createHmacVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return timingSafeEqual2(Buffer7.from(signature), Buffer7.from(computedSig));
      }, "verify");
    }
    __name(createHmacVerifier, "createHmacVerifier");
    function createKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto3.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createKeySigner, "createKeySigner");
    function createKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto3.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      }, "verify");
    }
    __name(createKeyVerifier, "createKeyVerifier");
    function createPSSKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto3.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createPSSKeySigner, "createPSSKeySigner");
    function createPSSKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto3.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      }, "verify");
    }
    __name(createPSSKeyVerifier, "createPSSKeyVerifier");
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return /* @__PURE__ */ __name(function sign3() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      }, "sign");
    }
    __name(createECDSASigner, "createECDSASigner");
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      }, "verify");
    }
    __name(createECDSAVerifer, "createECDSAVerifer");
    function createNoneSigner() {
      return /* @__PURE__ */ __name(function sign3() {
        return "";
      }, "sign");
    }
    __name(createNoneSigner, "createNoneSigner");
    function createNoneVerifier() {
      return /* @__PURE__ */ __name(function verify3(thing, signature) {
        return signature === "";
      }, "verify");
    }
    __name(createNoneVerifier, "createNoneVerifier");
    module.exports = /* @__PURE__ */ __name(function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    }, "jwa");
  }
});

// node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/tostring.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer7 = require_buffer().Buffer;
    module.exports = /* @__PURE__ */ __name(function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer7.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    }, "toString");
  }
});

// node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/sign-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer7 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream3 = require_stream();
    var toString = require_tostring();
    var util = require_util();
    function base64url(string2, encoding) {
      return Buffer7.from(string2, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(base64url, "base64url");
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    __name(jwsSecuredInput, "jwsSecuredInput");
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    __name(jwsSign, "jwsSign");
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    __name(SignStream, "SignStream");
    util.inherits(SignStream, Stream3);
    SignStream.prototype.sign = /* @__PURE__ */ __name(function sign3() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e3) {
        this.readable = false;
        this.emit("error", e3);
        this.emit("close");
      }
    }, "sign");
    SignStream.sign = jwsSign;
    module.exports = SignStream;
  }
});

// node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/.pnpm/jws@3.2.2/node_modules/jws/lib/verify-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer7 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream3 = require_stream();
    var toString = require_tostring();
    var util = require_util();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject3(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    __name(isObject3, "isObject");
    function safeJsonParse(thing) {
      if (isObject3(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e3) {
        return void 0;
      }
    }
    __name(safeJsonParse, "safeJsonParse");
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer7.from(encodedHeader, "base64").toString("binary"));
    }
    __name(headerFromJWS, "headerFromJWS");
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    __name(securedInputFromJWS, "securedInputFromJWS");
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    __name(signatureFromJWS, "signatureFromJWS");
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer7.from(payload, "base64").toString(encoding);
    }
    __name(payloadFromJWS, "payloadFromJWS");
    function isValidJws(string2) {
      return JWS_REGEX.test(string2) && !!headerFromJWS(string2);
    }
    __name(isValidJws, "isValidJws");
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err2 = new Error("Missing algorithm parameter for jws.verify");
        err2.code = "MISSING_ALGORITHM";
        throw err2;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    __name(jwsVerify, "jwsVerify");
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    __name(jwsDecode, "jwsDecode");
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    __name(VerifyStream, "VerifyStream");
    util.inherits(VerifyStream, Stream3);
    VerifyStream.prototype.verify = /* @__PURE__ */ __name(function verify3() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e3) {
        this.readable = false;
        this.emit("error", e3);
        this.emit("close");
      }
    }, "verify");
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module.exports = VerifyStream;
  }
});

// node_modules/.pnpm/jws@3.2.2/node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/.pnpm/jws@3.2.2/node_modules/jws/index.js"(exports) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = /* @__PURE__ */ __name(function createSign2(opts) {
      return new SignStream(opts);
    }, "createSign");
    exports.createVerify = /* @__PURE__ */ __name(function createVerify2(opts) {
      return new VerifyStream(opts);
    }, "createVerify");
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/decode.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var jws = require_jws();
    module.exports = function(jwt3, options2) {
      options2 = options2 || {};
      var decoded = jws.decode(jwt3, options2);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e3) {
        }
      }
      if (options2.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = /* @__PURE__ */ __name(function(message, error3) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error3) this.inner = error3;
    }, "JsonWebTokenError");
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module.exports = JsonWebTokenError;
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = /* @__PURE__ */ __name(function(message, date2) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date2;
    }, "NotBeforeError");
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module.exports = NotBeforeError;
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = /* @__PURE__ */ __name(function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    }, "TokenExpiredError");
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module.exports = TokenExpiredError;
  }
});

// node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var s3 = 1e3;
    var m = s3 * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    __name(parse5, "parse");
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s3) {
        return Math.round(ms / s3) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s3) {
        return plural(ms, msAbs, s3, "second");
      }
      return ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/timespan.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ms = require_ms();
    module.exports = function(time4, iat) {
      var timestamp2 = iat || Math.floor(Date.now() / 1e3);
      if (typeof time4 === "string") {
        var milliseconds = ms(time4);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp2 + milliseconds / 1e3);
      } else if (typeof time4 === "number") {
        return timestamp2 + time4;
      } else {
        return;
      }
    };
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var debug4 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug4;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug4 = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t3 = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = /* @__PURE__ */ __name((value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    }, "makeSafeRegex");
    var createToken = /* @__PURE__ */ __name((name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index10 = R++;
      debug4(name, index10, value);
      t3[name] = index10;
      src[index10] = value;
      safeSrc[index10] = safe;
      re[index10] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index10] = new RegExp(safe, isGlobal ? "g" : void 0);
    }, "createToken");
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t3.NUMERICIDENTIFIER]})\\.(${src[t3.NUMERICIDENTIFIER]})\\.(${src[t3.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src[t3.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t3.NONNUMERICIDENTIFIER]}|${src[t3.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t3.NONNUMERICIDENTIFIER]}|${src[t3.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t3.PRERELEASEIDENTIFIER]}(?:\\.${src[t3.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t3.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t3.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t3.BUILDIDENTIFIER]}(?:\\.${src[t3.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t3.MAINVERSION]}${src[t3.PRERELEASE]}?${src[t3.BUILD]}?`);
    createToken("FULL", `^${src[t3.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t3.MAINVERSIONLOOSE]}${src[t3.PRERELEASELOOSE]}?${src[t3.BUILD]}?`);
    createToken("LOOSE", `^${src[t3.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t3.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t3.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t3.XRANGEIDENTIFIER]})(?:\\.(${src[t3.XRANGEIDENTIFIER]})(?:\\.(${src[t3.XRANGEIDENTIFIER]})(?:${src[t3.PRERELEASE]})?${src[t3.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})(?:${src[t3.PRERELEASELOOSE]})?${src[t3.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t3.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t3.COERCEPLAIN] + `(?:${src[t3.PRERELEASE]})?(?:${src[t3.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t3.COERCE], true);
    createToken("COERCERTLFULL", src[t3.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t3.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t3.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t3.GTLT]}\\s*(${src[t3.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]}|${src[t3.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t3.XRANGEPLAIN]})\\s+-\\s+(${src[t3.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t3.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t3.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions2 = /* @__PURE__ */ __name((options2) => {
      if (!options2) {
        return emptyOpts;
      }
      if (typeof options2 !== "object") {
        return looseOption;
      }
      return options2;
    }, "parseOptions");
    module.exports = parseOptions2;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/identifiers.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var numeric2 = /^[0-9]+$/;
    var compareIdentifiers = /* @__PURE__ */ __name((a, b2) => {
      const anum = numeric2.test(a);
      const bnum = numeric2.test(b2);
      if (anum && bnum) {
        a = +a;
        b2 = +b2;
      }
      return a === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b2 ? -1 : 1;
    }, "compareIdentifiers");
    var rcompareIdentifiers = /* @__PURE__ */ __name((a, b2) => compareIdentifiers(b2, a), "rcompareIdentifiers");
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var debug4 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t: t3 } = require_re();
    var parseOptions2 = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      static {
        __name(this, "SemVer");
      }
      constructor(version4, options2) {
        options2 = parseOptions2(options2);
        if (version4 instanceof _SemVer) {
          if (version4.loose === !!options2.loose && version4.includePrerelease === !!options2.includePrerelease) {
            return version4;
          } else {
            version4 = version4.version;
          }
        } else if (typeof version4 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version4}".`);
        }
        if (version4.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug4("SemVer", version4, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        const m = version4.trim().match(options2.loose ? re[t3.LOOSE] : re[t3.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version4}`);
        }
        this.raw = version4;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug4("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b2 = other.prerelease[i];
          debug4("prerelease compare", i, a, b2);
          if (a === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b2) {
            continue;
          } else {
            return compareIdentifiers(a, b2);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b2 = other.build[i];
          debug4("build compare", i, a, b2);
          if (a === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b2) {
            continue;
          } else {
            return compareIdentifiers(a, b2);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release2, identifier, identifierBase) {
        if (release2.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t3.PRERELEASELOOSE] : re[t3.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release2) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base2 = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base2];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base2);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base2];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release2}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var parse5 = /* @__PURE__ */ __name((version4, options2, throwErrors = false) => {
      if (version4 instanceof SemVer) {
        return version4;
      }
      try {
        return new SemVer(version4, options2);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    }, "parse");
    module.exports = parse5;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/valid.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse5 = require_parse();
    var valid = /* @__PURE__ */ __name((version4, options2) => {
      const v = parse5(version4, options2);
      return v ? v.version : null;
    }, "valid");
    module.exports = valid;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/clean.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse5 = require_parse();
    var clean = /* @__PURE__ */ __name((version4, options2) => {
      const s3 = parse5(version4.trim().replace(/^[=v]+/, ""), options2);
      return s3 ? s3.version : null;
    }, "clean");
    module.exports = clean;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/inc.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var inc = /* @__PURE__ */ __name((version4, release2, options2, identifier, identifierBase) => {
      if (typeof options2 === "string") {
        identifierBase = identifier;
        identifier = options2;
        options2 = void 0;
      }
      try {
        return new SemVer(
          version4 instanceof SemVer ? version4.version : version4,
          options2
        ).inc(release2, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    }, "inc");
    module.exports = inc;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/diff.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse5 = require_parse();
    var diff3 = /* @__PURE__ */ __name((version1, version23) => {
      const v1 = parse5(version1, null, true);
      const v2 = parse5(version23, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    }, "diff");
    module.exports = diff3;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/major.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var major = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).major, "major");
    module.exports = major;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/minor.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var minor = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).minor, "minor");
    module.exports = minor;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/patch.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var patch = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).patch, "patch");
    module.exports = patch;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/prerelease.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse5 = require_parse();
    var prerelease = /* @__PURE__ */ __name((version4, options2) => {
      const parsed = parse5(version4, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }, "prerelease");
    module.exports = prerelease;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var compare = /* @__PURE__ */ __name((a, b2, loose) => new SemVer(a, loose).compare(new SemVer(b2, loose)), "compare");
    module.exports = compare;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rcompare.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var rcompare = /* @__PURE__ */ __name((a, b2, loose) => compare(b2, a, loose), "rcompare");
    module.exports = rcompare;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-loose.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var compareLoose = /* @__PURE__ */ __name((a, b2) => compare(a, b2, true), "compareLoose");
    module.exports = compareLoose;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-build.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var compareBuild = /* @__PURE__ */ __name((a, b2, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b2, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }, "compareBuild");
    module.exports = compareBuild;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/sort.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compareBuild = require_compare_build();
    var sort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b2) => compareBuild(a, b2, loose)), "sort");
    module.exports = sort;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rsort.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compareBuild = require_compare_build();
    var rsort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b2) => compareBuild(b2, a, loose)), "rsort");
    module.exports = rsort;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gt.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var gt2 = /* @__PURE__ */ __name((a, b2, loose) => compare(a, b2, loose) > 0, "gt");
    module.exports = gt2;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lt.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var lt2 = /* @__PURE__ */ __name((a, b2, loose) => compare(a, b2, loose) < 0, "lt");
    module.exports = lt2;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/eq.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var eq2 = /* @__PURE__ */ __name((a, b2, loose) => compare(a, b2, loose) === 0, "eq");
    module.exports = eq2;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/neq.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var neq = /* @__PURE__ */ __name((a, b2, loose) => compare(a, b2, loose) !== 0, "neq");
    module.exports = neq;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var gte2 = /* @__PURE__ */ __name((a, b2, loose) => compare(a, b2, loose) >= 0, "gte");
    module.exports = gte2;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lte.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var lte2 = /* @__PURE__ */ __name((a, b2, loose) => compare(a, b2, loose) <= 0, "lte");
    module.exports = lte2;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/cmp.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var eq2 = require_eq();
    var neq = require_neq();
    var gt2 = require_gt();
    var gte2 = require_gte();
    var lt2 = require_lt();
    var lte2 = require_lte();
    var cmp2 = /* @__PURE__ */ __name((a, op, b2, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a === b2;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a !== b2;
        case "":
        case "=":
        case "==":
          return eq2(a, b2, loose);
        case "!=":
          return neq(a, b2, loose);
        case ">":
          return gt2(a, b2, loose);
        case ">=":
          return gte2(a, b2, loose);
        case "<":
          return lt2(a, b2, loose);
        case "<=":
          return lte2(a, b2, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    }, "cmp");
    module.exports = cmp2;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/coerce.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var parse5 = require_parse();
    var { safeRe: re, t: t3 } = require_re();
    var coerce = /* @__PURE__ */ __name((version4, options2) => {
      if (version4 instanceof SemVer) {
        return version4;
      }
      if (typeof version4 === "number") {
        version4 = String(version4);
      }
      if (typeof version4 !== "string") {
        return null;
      }
      options2 = options2 || {};
      let match = null;
      if (!options2.rtl) {
        match = version4.match(options2.includePrerelease ? re[t3.COERCEFULL] : re[t3.COERCE]);
      } else {
        const coerceRtlRegex = options2.includePrerelease ? re[t3.COERCERTLFULL] : re[t3.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version4)) && (!match || match.index + match[0].length !== version4.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options2.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options2.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse5(`${major}.${minor}.${patch}${prerelease}${build}`, options2);
    }, "coerce");
    module.exports = coerce;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/lrucache.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var LRUCache = class {
      static {
        __name(this, "LRUCache");
      }
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key2) {
        const value = this.map.get(key2);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key2);
          this.map.set(key2, value);
          return value;
        }
      }
      delete(key2) {
        return this.map.delete(key2);
      }
      set(key2, value) {
        const deleted = this.delete(key2);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key2, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      static {
        __name(this, "Range");
      }
      constructor(range, options2) {
        options2 = parseOptions2(options2);
        if (range instanceof _Range) {
          if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options2);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r3) => this.parseRange(r3.trim())).filter((c2) => c2.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first2 = this.set[0];
          this.set = this.set.filter((c2) => !isNullSet(c2[0]));
          if (this.set.length === 0) {
            this.set = [first2];
          } else if (this.set.length > 1) {
            for (const c2 of this.set) {
              if (c2.length === 1 && isAny(c2[0])) {
                this.set = [c2];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t3.HYPHENRANGELOOSE] : re[t3.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug4("hyphen replace", range);
        range = range.replace(re[t3.COMPARATORTRIM], comparatorTrimReplace);
        debug4("comparator trim", range);
        range = range.replace(re[t3.TILDETRIM], tildeTrimReplace);
        debug4("tilde trim", range);
        range = range.replace(re[t3.CARETTRIM], caretTrimReplace);
        debug4("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug4("loose invalid filter", comp, this.options);
            return !!comp.match(re[t3.COMPARATORLOOSE]);
          });
        }
        debug4("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options2) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options2) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options2);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version4) {
        if (!version4) {
          return false;
        }
        if (typeof version4 === "string") {
          try {
            version4 = new SemVer(version4, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version4, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions2 = require_parse_options();
    var Comparator = require_comparator();
    var debug4 = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t: t3,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = /* @__PURE__ */ __name((c2) => c2.value === "<0.0.0-0", "isNullSet");
    var isAny = /* @__PURE__ */ __name((c2) => c2.value === "", "isAny");
    var isSatisfiable = /* @__PURE__ */ __name((comparators, options2) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }, "isSatisfiable");
    var parseComparator = /* @__PURE__ */ __name((comp, options2) => {
      debug4("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug4("caret", comp);
      comp = replaceTildes(comp, options2);
      debug4("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug4("xrange", comp);
      comp = replaceStars(comp, options2);
      debug4("stars", comp);
      return comp;
    }, "parseComparator");
    var isX = /* @__PURE__ */ __name((id) => !id || id.toLowerCase() === "x" || id === "*", "isX");
    var replaceTildes = /* @__PURE__ */ __name((comp, options2) => {
      return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options2)).join(" ");
    }, "replaceTildes");
    var replaceTilde = /* @__PURE__ */ __name((comp, options2) => {
      const r3 = options2.loose ? re[t3.TILDELOOSE] : re[t3.TILDE];
      return comp.replace(r3, (_, M, m, p, pr) => {
        debug4("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug4("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug4("tilde return", ret);
        return ret;
      });
    }, "replaceTilde");
    var replaceCarets = /* @__PURE__ */ __name((comp, options2) => {
      return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options2)).join(" ");
    }, "replaceCarets");
    var replaceCaret = /* @__PURE__ */ __name((comp, options2) => {
      debug4("caret", comp, options2);
      const r3 = options2.loose ? re[t3.CARETLOOSE] : re[t3.CARET];
      const z2 = options2.includePrerelease ? "-0" : "";
      return comp.replace(r3, (_, M, m, p, pr) => {
        debug4("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug4("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug4("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug4("caret return", ret);
        return ret;
      });
    }, "replaceCaret");
    var replaceXRanges = /* @__PURE__ */ __name((comp, options2) => {
      debug4("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map((c2) => replaceXRange(c2, options2)).join(" ");
    }, "replaceXRanges");
    var replaceXRange = /* @__PURE__ */ __name((comp, options2) => {
      comp = comp.trim();
      const r3 = options2.loose ? re[t3.XRANGELOOSE] : re[t3.XRANGE];
      return comp.replace(r3, (ret, gtlt, M, m, p, pr) => {
        debug4("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug4("xRange return", ret);
        return ret;
      });
    }, "replaceXRange");
    var replaceStars = /* @__PURE__ */ __name((comp, options2) => {
      debug4("replaceStars", comp, options2);
      return comp.trim().replace(re[t3.STAR], "");
    }, "replaceStars");
    var replaceGTE0 = /* @__PURE__ */ __name((comp, options2) => {
      debug4("replaceGTE0", comp, options2);
      return comp.trim().replace(re[options2.includePrerelease ? t3.GTE0PRE : t3.GTE0], "");
    }, "replaceGTE0");
    var hyphenReplace = /* @__PURE__ */ __name((incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    }, "hyphenReplace");
    var testSet = /* @__PURE__ */ __name((set2, version4, options2) => {
      for (let i = 0; i < set2.length; i++) {
        if (!set2[i].test(version4)) {
          return false;
        }
      }
      if (version4.prerelease.length && !options2.includePrerelease) {
        for (let i = 0; i < set2.length; i++) {
          debug4(set2[i].semver);
          if (set2[i].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i].semver.prerelease.length > 0) {
            const allowed = set2[i].semver;
            if (allowed.major === version4.major && allowed.minor === version4.minor && allowed.patch === version4.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }, "testSet");
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/comparator.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static {
        __name(this, "Comparator");
      }
      static get ANY() {
        return ANY;
      }
      constructor(comp, options2) {
        options2 = parseOptions2(options2);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options2.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug4("comparator", comp, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug4("comp", this);
      }
      parse(comp) {
        const r3 = this.options.loose ? re[t3.COMPARATORLOOSE] : re[t3.COMPARATOR];
        const m = comp.match(r3);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version4) {
        debug4("Comparator.test", version4, this.options.loose);
        if (this.semver === ANY || version4 === ANY) {
          return true;
        }
        if (typeof version4 === "string") {
          try {
            version4 = new SemVer(version4, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp2(version4, this.operator, this.semver, this.options);
      }
      intersects(comp, options2) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options2).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options2).test(comp.semver);
        }
        options2 = parseOptions2(options2);
        if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp2(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp2(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions2 = require_parse_options();
    var { safeRe: re, t: t3 } = require_re();
    var cmp2 = require_cmp();
    var debug4 = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/satisfies.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var satisfies = /* @__PURE__ */ __name((version4, range, options2) => {
      try {
        range = new Range(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version4);
    }, "satisfies");
    module.exports = satisfies;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var toComparators = /* @__PURE__ */ __name((range, options2) => new Range(range, options2).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" ")), "toComparators");
    module.exports = toComparators;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = /* @__PURE__ */ __name((versions2, range, options2) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions2.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    }, "maxSatisfying");
    module.exports = maxSatisfying;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = /* @__PURE__ */ __name((versions2, range, options2) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions2.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    }, "minSatisfying");
    module.exports = minSatisfying;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-version.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Range = require_range();
    var gt2 = require_gt();
    var minVersion = /* @__PURE__ */ __name((range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator2) => {
          const compver = new SemVer(comparator2.semver.version);
          switch (comparator2.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt2(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator2.operator}`);
          }
        });
        if (setMin && (!minver || gt2(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }, "minVersion");
    module.exports = minVersion;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/valid.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var validRange = /* @__PURE__ */ __name((range, options2) => {
      try {
        return new Range(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    }, "validRange");
    module.exports = validRange;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/outside.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt2 = require_gt();
    var lt2 = require_lt();
    var lte2 = require_lte();
    var gte2 = require_gte();
    var outside = /* @__PURE__ */ __name((version4, range, hilo, options2) => {
      version4 = new SemVer(version4, options2);
      range = new Range(range, options2);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt2;
          ltefn = lte2;
          ltfn = lt2;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt2;
          ltefn = gte2;
          ltfn = gt2;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version4, range, options2)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator2) => {
          if (comparator2.semver === ANY) {
            comparator2 = new Comparator(">=0.0.0");
          }
          high = high || comparator2;
          low = low || comparator2;
          if (gtfn(comparator2.semver, high.semver, options2)) {
            high = comparator2;
          } else if (ltfn(comparator2.semver, low.semver, options2)) {
            low = comparator2;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version4, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version4, low.semver)) {
          return false;
        }
      }
      return true;
    }, "outside");
    module.exports = outside;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/gtr.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var outside = require_outside();
    var gtr = /* @__PURE__ */ __name((version4, range, options2) => outside(version4, range, ">", options2), "gtr");
    module.exports = gtr;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/ltr.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var outside = require_outside();
    var ltr = /* @__PURE__ */ __name((version4, range, options2) => outside(version4, range, "<", options2), "ltr");
    module.exports = ltr;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/intersects.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var intersects = /* @__PURE__ */ __name((r1, r22, options2) => {
      r1 = new Range(r1, options2);
      r22 = new Range(r22, options2);
      return r1.intersects(r22, options2);
    }, "intersects");
    module.exports = intersects;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/simplify.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions2, range, options2) => {
      const set2 = [];
      let first2 = null;
      let prev = null;
      const v = versions2.sort((a, b2) => compare(a, b2, options2));
      for (const version4 of v) {
        const included = satisfies(version4, range, options2);
        if (included) {
          prev = version4;
          if (!first2) {
            first2 = version4;
          }
        } else {
          if (prev) {
            set2.push([first2, prev]);
          }
          prev = null;
          first2 = null;
        }
      }
      if (first2) {
        set2.push([first2, null]);
      }
      const ranges = [];
      for (const [min, max] of set2) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/subset.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = /* @__PURE__ */ __name((sub, dom, options2 = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options2);
      dom = new Range(dom, options2);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options2);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    }, "subset");
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = /* @__PURE__ */ __name((sub, dom, options2) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options2.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options2.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt2, lt2;
      for (const c2 of sub) {
        if (c2.operator === ">" || c2.operator === ">=") {
          gt2 = higherGT(gt2, c2, options2);
        } else if (c2.operator === "<" || c2.operator === "<=") {
          lt2 = lowerLT(lt2, c2, options2);
        } else {
          eqSet.add(c2.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt2 && lt2) {
        gtltComp = compare(gt2.semver, lt2.semver, options2);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
          return null;
        }
      }
      for (const eq2 of eqSet) {
        if (gt2 && !satisfies(eq2, String(gt2), options2)) {
          return null;
        }
        if (lt2 && !satisfies(eq2, String(lt2), options2)) {
          return null;
        }
        for (const c2 of dom) {
          if (!satisfies(eq2, String(c2), options2)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt2 && !options2.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
      let needDomGTPre = gt2 && !options2.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c2 of dom) {
        hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
        hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
        if (gt2) {
          if (needDomGTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c2.operator === ">" || c2.operator === ">=") {
            higher = higherGT(gt2, c2, options2);
            if (higher === c2 && higher !== gt2) {
              return false;
            }
          } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c2), options2)) {
            return false;
          }
        }
        if (lt2) {
          if (needDomLTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c2.operator === "<" || c2.operator === "<=") {
            lower = lowerLT(lt2, c2, options2);
            if (lower === c2 && lower !== lt2) {
              return false;
            }
          } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c2), options2)) {
            return false;
          }
        }
        if (!c2.operator && (lt2 || gt2) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
        return false;
      }
      if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    }, "simpleSubset");
    var higherGT = /* @__PURE__ */ __name((a, b2, options2) => {
      if (!a) {
        return b2;
      }
      const comp = compare(a.semver, b2.semver, options2);
      return comp > 0 ? a : comp < 0 ? b2 : b2.operator === ">" && a.operator === ">=" ? b2 : a;
    }, "higherGT");
    var lowerLT = /* @__PURE__ */ __name((a, b2, options2) => {
      if (!a) {
        return b2;
      }
      const comp = compare(a.semver, b2.semver, options2);
      return comp < 0 ? a : comp > 0 ? b2 : b2.operator === "<" && a.operator === "<=" ? b2 : a;
    }, "lowerLT");
    module.exports = subset;
  }
});

// node_modules/.pnpm/semver@7.7.2/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/.pnpm/semver@7.7.2/node_modules/semver/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var internalRe = require_re();
    var constants2 = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse5 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff3 = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt2 = require_gt();
    var lt2 = require_lt();
    var eq2 = require_eq();
    var neq = require_neq();
    var gte2 = require_gte();
    var lte2 = require_lte();
    var cmp2 = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse5,
      valid,
      clean,
      inc,
      diff: diff3,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt: gt2,
      lt: lt2,
      eq: eq2,
      neq,
      gte: gte2,
      lte: lte2,
      cmp: cmp2,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants2.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module.exports = function(algorithm, key2) {
      if (!algorithm || !key2) return;
      const keyType = key2.asymmetricKeyType;
      if (!keyType) return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key2.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key2.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/lib/psSupported.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/verify.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject: KeyObject2, createSecretKey: createSecretKey2, createPublicKey: createPublicKey2 } = require_crypto();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module.exports = function(jwtString, secretOrPublicKey, options2, callback) {
      if (typeof options2 === "function" && !callback) {
        callback = options2;
        options2 = {};
      }
      if (!options2) {
        options2 = {};
      }
      options2 = Object.assign({}, options2);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = /* @__PURE__ */ __name(function(err2, data) {
          if (err2) throw err2;
          return data;
        }, "done");
      }
      if (options2.clockTimestamp && typeof options2.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options2.nonce !== void 0 && (typeof options2.nonce !== "string" || options2.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options2.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options2.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options2.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err2) {
        return done(err2);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = /* @__PURE__ */ __name(function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        }, "getSecret");
      }
      return getSecret(header, function(err2, secretOrPublicKey2) {
        if (err2) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err2.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options2.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject2)) {
          try {
            secretOrPublicKey2 = createPublicKey2(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey2(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options2.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options2.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options2.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options2.algorithms = EC_KEY_ALGS;
          } else {
            options2.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options2.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options2.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e3) {
            return done(e3);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e3) {
          return done(e3);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options2.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options2.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options2.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options2.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options2.audience) {
          const audiences = Array.isArray(options2.audience) ? options2.audience : [options2.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options2.issuer) {
          const invalid_issuer = typeof options2.issuer === "string" && payload.iss !== options2.issuer || Array.isArray(options2.issuer) && options2.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options2.issuer));
          }
        }
        if (options2.subject) {
          if (payload.sub !== options2.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options2.subject));
          }
        }
        if (options2.jwtid) {
          if (payload.jti !== options2.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options2.jwtid));
          }
        }
        if (options2.nonce) {
          if (payload.nonce !== options2.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options2.nonce));
          }
        }
        if (options2.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options2.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options2.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options2.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/.pnpm/lodash.includes@4.3.0/node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash.includes@4.3.0/node_modules/lodash.includes/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN2 = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array3, iteratee) {
      var index10 = -1, length = array3 ? array3.length : 0, result = Array(length);
      while (++index10 < length) {
        result[index10] = iteratee(array3[index10], index10, array3);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function baseFindIndex(array3, predicate, fromIndex, fromRight) {
      var length = array3.length, index10 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index10-- : ++index10 < length) {
        if (predicate(array3[index10], index10, array3)) {
          return index10;
        }
      }
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    function baseIndexOf(array3, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array3, baseIsNaN, fromIndex);
      }
      var index10 = fromIndex - 1, length = array3.length;
      while (++index10 < length) {
        if (array3[index10] === value) {
          return index10;
        }
      }
      return -1;
    }
    __name(baseIndexOf, "baseIndexOf");
    function baseIsNaN(value) {
      return value !== value;
    }
    __name(baseIsNaN, "baseIsNaN");
    function baseTimes(n2, iteratee) {
      var index10 = -1, result = Array(n2);
      while (++index10 < n2) {
        result[index10] = iteratee(index10);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function baseValues(object2, props) {
      return arrayMap(props, function(key2) {
        return object2[key2];
      });
    }
    __name(baseValues, "baseValues");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && (key2 == "length" || isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key2 in Object(object2)) {
        if (hasOwnProperty.call(object2, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values2(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    __name(includes, "includes");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    __name(isArrayLike, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    function isFunction2(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction2, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    __name(isString2, "isString");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign3 = value < 0 ? -1 : 1;
        return sign3 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN2;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN2 : +value;
    }
    __name(toNumber, "toNumber");
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    __name(keys, "keys");
    function values2(object2) {
      return object2 ? baseValues(object2, keys(object2)) : [];
    }
    __name(values2, "values");
    module.exports = includes;
  }
});

// node_modules/.pnpm/lodash.isboolean@3.0.3/node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/.pnpm/lodash.isboolean@3.0.3/node_modules/lodash.isboolean/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean2(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    __name(isBoolean2, "isBoolean");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    module.exports = isBoolean2;
  }
});

// node_modules/.pnpm/lodash.isinteger@4.0.4/node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/.pnpm/lodash.isinteger@4.0.4/node_modules/lodash.isinteger/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN2 = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    __name(isInteger, "isInteger");
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign3 = value < 0 ? -1 : 1;
        return sign3 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN2;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN2 : +value;
    }
    __name(toNumber, "toNumber");
    module.exports = isInteger;
  }
});

// node_modules/.pnpm/lodash.isnumber@3.0.3/node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/.pnpm/lodash.isnumber@3.0.3/node_modules/lodash.isnumber/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    __name(isNumber2, "isNumber");
    module.exports = isNumber2;
  }
});

// node_modules/.pnpm/lodash.isplainobject@4.0.6/node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/.pnpm/lodash.isplainobject@4.0.6/node_modules/lodash.isplainobject/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e3) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    __name(isPlainObject, "isPlainObject");
    module.exports = isPlainObject;
  }
});

// node_modules/.pnpm/lodash.isstring@4.0.1/node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/.pnpm/lodash.isstring@4.0.1/node_modules/lodash.isstring/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray2 = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    __name(isString2, "isString");
    module.exports = isString2;
  }
});

// node_modules/.pnpm/lodash.once@4.1.1/node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/.pnpm/lodash.once@4.1.1/node_modules/lodash.once/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN2 = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n2, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n2 = toInteger(n2);
      return function() {
        if (--n2 > 0) {
          result = func.apply(this, arguments);
        }
        if (n2 <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    __name(before, "before");
    function once3(func) {
      return before(2, func);
    }
    __name(once3, "once");
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign3 = value < 0 ? -1 : 1;
        return sign3 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN2;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN2 : +value;
    }
    __name(toNumber, "toNumber");
    module.exports = once3;
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/sign.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean2 = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber2 = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString2 = require_lodash6();
    var once3 = require_lodash7();
    var { KeyObject: KeyObject2, createSecretKey: createSecretKey2, createPrivateKey: createPrivateKey2 } = require_crypto();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: /* @__PURE__ */ __name(function(value) {
        return isInteger(value) || isString2(value) && value;
      }, "isValid"), message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: /* @__PURE__ */ __name(function(value) {
        return isInteger(value) || isString2(value) && value;
      }, "isValid"), message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: /* @__PURE__ */ __name(function(value) {
        return isString2(value) || Array.isArray(value);
      }, "isValid"), message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString2, message: '"encoding" must be a string' },
      issuer: { isValid: isString2, message: '"issuer" must be a string' },
      subject: { isValid: isString2, message: '"subject" must be a string' },
      jwtid: { isValid: isString2, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean2, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString2, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean2, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean2, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean2, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber2, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber2, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber2, message: '"nbf" should be a number of seconds' }
    };
    function validate(schema2, allowUnknown, object2, parameterName) {
      if (!isPlainObject(object2)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object2).forEach(function(key2) {
        const validator2 = schema2[key2];
        if (!validator2) {
          if (!allowUnknown) {
            throw new Error('"' + key2 + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator2.isValid(object2[key2])) {
          throw new Error(validator2.message);
        }
      });
    }
    __name(validate, "validate");
    function validateOptions2(options2) {
      return validate(sign_options_schema, false, options2, "options");
    }
    __name(validateOptions2, "validateOptions");
    function validatePayload(payload) {
      return validate(registered_claims_schema, true, payload, "payload");
    }
    __name(validatePayload, "validatePayload");
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module.exports = function(payload, secretOrPrivateKey, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      } else {
        options2 = options2 || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options2.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options2.keyid
      }, options2.header);
      function failure(err2) {
        if (callback) {
          return callback(err2);
        }
        throw err2;
      }
      __name(failure, "failure");
      if (!secretOrPrivateKey && options2.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject2)) {
        try {
          secretOrPrivateKey = createPrivateKey2(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey2(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options2.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error3) {
          return failure(error3);
        }
        if (!options2.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options2[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options2.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options2.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions2(options2);
      } catch (error3) {
        return failure(error3);
      }
      if (!options2.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error3) {
          return failure(error3);
        }
      }
      const timestamp2 = payload.iat || Math.floor(Date.now() / 1e3);
      if (options2.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp2;
      }
      if (typeof options2.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options2.notBefore, timestamp2);
        } catch (err2) {
          return failure(err2);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options2.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options2.expiresIn, timestamp2);
        } catch (err2) {
          return failure(err2);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key2) {
        const claim = options_to_payload[key2];
        if (typeof options2[key2] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key2 + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options2[key2];
        }
      });
      const encoding = options2.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once3(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options2.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options2.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/polyfills.js
import { EventEmitter as EventEmitter2 } from "node:events";
import { Buffer as Buffer2 } from "node:buffer";
function Socket() {
  const tcp = Object.assign(new EventEmitter2(), {
    readyState: "open",
    raw: null,
    writer: null,
    reader: null,
    connect,
    write,
    end,
    destroy,
    read
  });
  return tcp;
  async function connect(port, host) {
    try {
      tcp.readyState = "opening";
      const { connect: connect2 } = await import("cloudflare:sockets");
      tcp.raw = connect2(host + ":" + port, tcp.ssl ? { secureTransport: "starttls" } : {});
      tcp.raw.closed.then(
        () => {
          tcp.readyState !== "upgrade" ? close() : (tcp.readyState = "open", tcp.emit("secureConnect"));
        },
        (e3) => tcp.emit("error", e3)
      );
      tcp.writer = tcp.raw.writable.getWriter();
      tcp.reader = tcp.raw.readable.getReader();
      tcp.ssl ? readFirst() : read();
      tcp.writer.ready.then(() => {
        tcp.readyState = "open";
        tcp.emit("connect");
      });
    } catch (err2) {
      error3(err2);
    }
  }
  __name(connect, "connect");
  function close() {
    if (tcp.readyState === "closed")
      return;
    tcp.readyState = "closed";
    tcp.emit("close");
  }
  __name(close, "close");
  function write(data, cb) {
    tcp.writer.write(data).then(cb, error3);
    return true;
  }
  __name(write, "write");
  function end(data) {
    return data ? tcp.write(data, () => tcp.raw.close()) : tcp.raw.close();
  }
  __name(end, "end");
  function destroy() {
    tcp.destroyed = true;
    tcp.end();
  }
  __name(destroy, "destroy");
  async function read() {
    try {
      let done, value;
      while ({ done, value } = await tcp.reader.read(), !done)
        tcp.emit("data", Buffer2.from(value));
    } catch (err2) {
      error3(err2);
    }
  }
  __name(read, "read");
  async function readFirst() {
    const { value } = await tcp.reader.read();
    tcp.emit("data", Buffer2.from(value));
  }
  __name(readFirst, "readFirst");
  function error3(err2) {
    tcp.emit("error", err2);
    tcp.emit("close");
  }
  __name(error3, "error");
}
function setImmediate(fn) {
  const id = ids++;
  tasks.add(id);
  queueMicrotask(() => {
    if (tasks.has(id)) {
      fn();
      tasks.delete(id);
    }
  });
  return id;
}
function clearImmediate(id) {
  tasks.delete(id);
}
var Crypto, ids, tasks, v4Seg, v4Str, IPv4Reg, v6Seg, IPv6Reg, textEncoder, crypto2, performance3, process2, os, fs, net, tls;
var init_polyfills = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/polyfills.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Crypto = globalThis.crypto;
    ids = 1;
    tasks = /* @__PURE__ */ new Set();
    v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
    IPv4Reg = new RegExp(`^${v4Str}$`);
    v6Seg = "(?:[0-9a-fA-F]{1,4})";
    IPv6Reg = new RegExp(
      `^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`
    );
    textEncoder = new TextEncoder();
    crypto2 = {
      randomBytes: /* @__PURE__ */ __name((l) => Crypto.getRandomValues(Buffer2.alloc(l)), "randomBytes"),
      pbkdf2Sync: /* @__PURE__ */ __name(async (password, salt, iterations, keylen) => Crypto.subtle.deriveBits(
        {
          name: "PBKDF2",
          hash: "SHA-256",
          salt,
          iterations
        },
        await Crypto.subtle.importKey(
          "raw",
          textEncoder.encode(password),
          "PBKDF2",
          false,
          ["deriveBits"]
        ),
        keylen * 8,
        ["deriveBits"]
      ), "pbkdf2Sync"),
      createHash: /* @__PURE__ */ __name((type) => ({
        update: /* @__PURE__ */ __name((x) => ({
          digest: /* @__PURE__ */ __name((encoding) => {
            if (!(x instanceof Uint8Array)) {
              x = textEncoder.encode(x);
            }
            let prom;
            if (type === "sha256") {
              prom = Crypto.subtle.digest("SHA-256", x);
            } else if (type === "md5") {
              prom = Crypto.subtle.digest("md5", x);
            } else {
              throw Error("createHash only supports sha256 or md5 in this environment, not ${type}.");
            }
            if (encoding === "hex") {
              return prom.then((arrayBuf) => Buffer2.from(arrayBuf).toString("hex"));
            } else if (encoding) {
              throw Error(`createHash only supports hex encoding or unencoded in this environment, not ${encoding}`);
            } else {
              return prom;
            }
          }, "digest")
        }), "update")
      }), "createHash"),
      createHmac: /* @__PURE__ */ __name((type, key2) => ({
        update: /* @__PURE__ */ __name((x) => ({
          digest: /* @__PURE__ */ __name(async () => Buffer2.from(
            await Crypto.subtle.sign(
              "HMAC",
              await Crypto.subtle.importKey("raw", key2, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]),
              textEncoder.encode(x)
            )
          ), "digest")
        }), "update")
      }), "createHmac")
    };
    performance3 = globalThis.performance;
    process2 = {
      env: {}
    };
    os = {
      userInfo() {
        return { username: "postgres" };
      }
    };
    fs = {
      readFile() {
        throw new Error("Reading files not supported on CloudFlare");
      }
    };
    net = {
      isIP: /* @__PURE__ */ __name((x) => IPv4Reg.test(x) ? 4 : IPv6Reg.test(x) ? 6 : 0, "isIP"),
      Socket
    };
    tls = {
      connect({ socket: tcp, servername }) {
        tcp.writer.releaseLock();
        tcp.reader.releaseLock();
        tcp.readyState = "upgrading";
        tcp.raw = tcp.raw.startTls({ servername });
        tcp.raw.closed.then(
          () => tcp.emit("close"),
          (e3) => tcp.emit("error", e3)
        );
        tcp.writer = tcp.raw.writable.getWriter();
        tcp.reader = tcp.raw.readable.getReader();
        tcp.writer.ready.then(() => {
          tcp.read();
          tcp.readyState = "upgrade";
        });
        return tcp;
      }
    };
    __name(Socket, "Socket");
    __name(setImmediate, "setImmediate");
    __name(clearImmediate, "clearImmediate");
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/query.js
function cachedError(xs) {
  if (originCache.has(xs))
    return originCache.get(xs);
  const x = Error.stackTraceLimit;
  Error.stackTraceLimit = 4;
  originCache.set(xs, new Error());
  Error.stackTraceLimit = x;
  return originCache.get(xs);
}
var originCache, originStackCache, originError, CLOSE, Query;
var init_query = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/query.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    originCache = /* @__PURE__ */ new Map();
    originStackCache = /* @__PURE__ */ new Map();
    originError = Symbol("OriginError");
    CLOSE = {};
    Query = class extends Promise {
      static {
        __name(this, "Query");
      }
      constructor(strings, args, handler, canceller, options2 = {}) {
        let resolve2, reject;
        super((a, b2) => {
          resolve2 = a;
          reject = b2;
        });
        this.tagged = Array.isArray(strings.raw);
        this.strings = strings;
        this.args = args;
        this.handler = handler;
        this.canceller = canceller;
        this.options = options2;
        this.state = null;
        this.statement = null;
        this.resolve = (x) => (this.active = false, resolve2(x));
        this.reject = (x) => (this.active = false, reject(x));
        this.active = false;
        this.cancelled = null;
        this.executed = false;
        this.signature = "";
        this[originError] = this.handler.debug ? new Error() : this.tagged && cachedError(this.strings);
      }
      get origin() {
        return (this.handler.debug ? this[originError].stack : this.tagged && originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings)) || "";
      }
      static get [Symbol.species]() {
        return Promise;
      }
      cancel() {
        return this.canceller && (this.canceller(this), this.canceller = null);
      }
      simple() {
        this.options.simple = true;
        this.options.prepare = false;
        return this;
      }
      async readable() {
        this.simple();
        this.streaming = true;
        return this;
      }
      async writable() {
        this.simple();
        this.streaming = true;
        return this;
      }
      cursor(rows = 1, fn) {
        this.options.simple = false;
        if (typeof rows === "function") {
          fn = rows;
          rows = 1;
        }
        this.cursorRows = rows;
        if (typeof fn === "function")
          return this.cursorFn = fn, this;
        let prev;
        return {
          [Symbol.asyncIterator]: () => ({
            next: /* @__PURE__ */ __name(() => {
              if (this.executed && !this.active)
                return { done: true };
              prev && prev();
              const promise = new Promise((resolve2, reject) => {
                this.cursorFn = (value) => {
                  resolve2({ value, done: false });
                  return new Promise((r3) => prev = r3);
                };
                this.resolve = () => (this.active = false, resolve2({ done: true }));
                this.reject = (x) => (this.active = false, reject(x));
              });
              this.execute();
              return promise;
            }, "next"),
            return() {
              prev && prev(CLOSE);
              return { done: true };
            }
          })
        };
      }
      describe() {
        this.options.simple = false;
        this.onlyDescribe = this.options.prepare = true;
        return this;
      }
      stream() {
        throw new Error(".stream has been renamed to .forEach");
      }
      forEach(fn) {
        this.forEachFn = fn;
        this.handle();
        return this;
      }
      raw() {
        this.isRaw = true;
        return this;
      }
      values() {
        this.isRaw = "values";
        return this;
      }
      async handle() {
        !this.executed && (this.executed = true) && await 1 && this.handler(this);
      }
      execute() {
        this.handle();
        return this;
      }
      then() {
        this.handle();
        return super.then.apply(this, arguments);
      }
      catch() {
        this.handle();
        return super.catch.apply(this, arguments);
      }
      finally() {
        this.handle();
        return super.finally.apply(this, arguments);
      }
    };
    __name(cachedError, "cachedError");
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/errors.js
function connection(x, options2, socket) {
  const { host, port } = socket || options2;
  const error3 = Object.assign(
    new Error("write " + x + " " + (options2.path || host + ":" + port)),
    {
      code: x,
      errno: x,
      address: options2.path || host
    },
    options2.path ? {} : { port }
  );
  Error.captureStackTrace(error3, connection);
  return error3;
}
function postgres(x) {
  const error3 = new PostgresError(x);
  Error.captureStackTrace(error3, postgres);
  return error3;
}
function generic(code, message) {
  const error3 = Object.assign(new Error(code + ": " + message), { code });
  Error.captureStackTrace(error3, generic);
  return error3;
}
function notSupported(x) {
  const error3 = Object.assign(
    new Error(x + " (B) is not supported"),
    {
      code: "MESSAGE_NOT_SUPPORTED",
      name: x
    }
  );
  Error.captureStackTrace(error3, notSupported);
  return error3;
}
var PostgresError, Errors;
var init_errors = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    PostgresError = class extends Error {
      static {
        __name(this, "PostgresError");
      }
      constructor(x) {
        super(x.message);
        this.name = this.constructor.name;
        Object.assign(this, x);
      }
    };
    Errors = {
      connection,
      postgres,
      generic,
      notSupported
    };
    __name(connection, "connection");
    __name(postgres, "postgres");
    __name(generic, "generic");
    __name(notSupported, "notSupported");
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/types.js
import { Buffer as Buffer3 } from "node:buffer";
function handleValue(x, parameters, types4, options2) {
  let value = x instanceof Parameter ? x.value : x;
  if (value === void 0) {
    x instanceof Parameter ? x.value = options2.transform.undefined : value = x = options2.transform.undefined;
    if (value === void 0)
      throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  }
  return "$" + types4.push(
    x instanceof Parameter ? (parameters.push(x.value), x.array ? x.array[x.type || inferType(x.value)] || x.type || firstIsString(x.value) : x.type) : (parameters.push(x), inferType(x))
  );
}
function stringify(q, string2, value, parameters, types4, options2) {
  for (let i = 1; i < q.strings.length; i++) {
    string2 += stringifyValue(string2, value, parameters, types4, options2) + q.strings[i];
    value = q.args[i];
  }
  return string2;
}
function stringifyValue(string2, value, parameters, types4, o2) {
  return value instanceof Builder ? value.build(string2, parameters, types4, o2) : value instanceof Query ? fragment(value, parameters, types4, o2) : value instanceof Identifier ? value.value : value && value[0] instanceof Query ? value.reduce((acc, x) => acc + " " + fragment(x, parameters, types4, o2), "") : handleValue(value, parameters, types4, o2);
}
function fragment(q, parameters, types4, options2) {
  q.fragment = true;
  return stringify(q, q.strings[0], q.args[0], parameters, types4, options2);
}
function valuesBuilder(first2, parameters, types4, columns, options2) {
  return first2.map(
    (row) => "(" + columns.map(
      (column) => stringifyValue("values", row[column], parameters, types4, options2)
    ).join(",") + ")"
  ).join(",");
}
function values(first2, rest, parameters, types4, options2) {
  const multi = Array.isArray(first2[0]);
  const columns = rest.length ? rest.flat() : Object.keys(multi ? first2[0] : first2);
  return valuesBuilder(multi ? first2 : [first2], parameters, types4, columns, options2);
}
function select(first2, rest, parameters, types4, options2) {
  typeof first2 === "string" && (first2 = [first2].concat(rest));
  if (Array.isArray(first2))
    return escapeIdentifiers(first2, options2);
  let value;
  const columns = rest.length ? rest.flat() : Object.keys(first2);
  return columns.map((x) => {
    value = first2[x];
    return (value instanceof Query ? fragment(value, parameters, types4, options2) : value instanceof Identifier ? value.value : handleValue(value, parameters, types4, options2)) + " as " + escapeIdentifier(options2.transform.column.to ? options2.transform.column.to(x) : x);
  }).join(",");
}
function notTagged() {
  throw Errors.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
}
function firstIsString(x) {
  if (Array.isArray(x))
    return firstIsString(x[0]);
  return typeof x === "string" ? 1009 : 0;
}
function typeHandlers(types4) {
  return Object.keys(types4).reduce((acc, k) => {
    types4[k].from && [].concat(types4[k].from).forEach((x) => acc.parsers[x] = types4[k].parse);
    if (types4[k].serialize) {
      acc.serializers[types4[k].to] = types4[k].serialize;
      types4[k].from && [].concat(types4[k].from).forEach((x) => acc.serializers[x] = types4[k].serialize);
    }
    return acc;
  }, { parsers: {}, serializers: {} });
}
function escapeIdentifiers(xs, { transform: { column } }) {
  return xs.map((x) => escapeIdentifier(column.to ? column.to(x) : x)).join(",");
}
function arrayEscape(x) {
  return x.replace(escapeBackslash, "\\\\").replace(escapeQuote, '\\"');
}
function arrayParserLoop(s3, x, parser, typarray) {
  const xs = [];
  const delimiter = typarray === 1020 ? ";" : ",";
  for (; s3.i < x.length; s3.i++) {
    s3.char = x[s3.i];
    if (s3.quoted) {
      if (s3.char === "\\") {
        s3.str += x[++s3.i];
      } else if (s3.char === '"') {
        xs.push(parser ? parser(s3.str) : s3.str);
        s3.str = "";
        s3.quoted = x[s3.i + 1] === '"';
        s3.last = s3.i + 2;
      } else {
        s3.str += s3.char;
      }
    } else if (s3.char === '"') {
      s3.quoted = true;
    } else if (s3.char === "{") {
      s3.last = ++s3.i;
      xs.push(arrayParserLoop(s3, x, parser, typarray));
    } else if (s3.char === "}") {
      s3.quoted = false;
      s3.last < s3.i && xs.push(parser ? parser(x.slice(s3.last, s3.i)) : x.slice(s3.last, s3.i));
      s3.last = s3.i + 1;
      break;
    } else if (s3.char === delimiter && s3.p !== "}" && s3.p !== '"') {
      xs.push(parser ? parser(x.slice(s3.last, s3.i)) : x.slice(s3.last, s3.i));
      s3.last = s3.i + 1;
    }
    s3.p = s3.char;
  }
  s3.last < s3.i && xs.push(parser ? parser(x.slice(s3.last, s3.i + 1)) : x.slice(s3.last, s3.i + 1));
  return xs;
}
function createJsonTransform(fn) {
  return /* @__PURE__ */ __name(function jsonTransform(x, column) {
    return typeof x === "object" && x !== null && (column.type === 114 || column.type === 3802) ? Array.isArray(x) ? x.map((x2) => jsonTransform(x2, column)) : Object.entries(x).reduce((acc, [k, v]) => Object.assign(acc, { [fn(k)]: jsonTransform(v, column) }), {}) : x;
  }, "jsonTransform");
}
var types3, NotTagged, Identifier, Parameter, Builder, defaultHandlers, builders, serializers, parsers, mergeUserTypes, escapeIdentifier, inferType, escapeBackslash, escapeQuote, arraySerializer, arrayParserState, arrayParser, toCamel, toPascal, toKebab, fromCamel, fromPascal, fromKebab, camel, pascal, kebab;
var init_types = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/types.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_query();
    init_errors();
    types3 = {
      string: {
        to: 25,
        from: null,
        // defaults to string
        serialize: /* @__PURE__ */ __name((x) => "" + x, "serialize")
      },
      number: {
        to: 0,
        from: [21, 23, 26, 700, 701],
        serialize: /* @__PURE__ */ __name((x) => "" + x, "serialize"),
        parse: /* @__PURE__ */ __name((x) => +x, "parse")
      },
      json: {
        to: 114,
        from: [114, 3802],
        serialize: /* @__PURE__ */ __name((x) => JSON.stringify(x), "serialize"),
        parse: /* @__PURE__ */ __name((x) => JSON.parse(x), "parse")
      },
      boolean: {
        to: 16,
        from: 16,
        serialize: /* @__PURE__ */ __name((x) => x === true ? "t" : "f", "serialize"),
        parse: /* @__PURE__ */ __name((x) => x === "t", "parse")
      },
      date: {
        to: 1184,
        from: [1082, 1114, 1184],
        serialize: /* @__PURE__ */ __name((x) => (x instanceof Date ? x : new Date(x)).toISOString(), "serialize"),
        parse: /* @__PURE__ */ __name((x) => new Date(x), "parse")
      },
      bytea: {
        to: 17,
        from: 17,
        serialize: /* @__PURE__ */ __name((x) => "\\x" + Buffer3.from(x).toString("hex"), "serialize"),
        parse: /* @__PURE__ */ __name((x) => Buffer3.from(x.slice(2), "hex"), "parse")
      }
    };
    NotTagged = class {
      static {
        __name(this, "NotTagged");
      }
      then() {
        notTagged();
      }
      catch() {
        notTagged();
      }
      finally() {
        notTagged();
      }
    };
    Identifier = class extends NotTagged {
      static {
        __name(this, "Identifier");
      }
      constructor(value) {
        super();
        this.value = escapeIdentifier(value);
      }
    };
    Parameter = class extends NotTagged {
      static {
        __name(this, "Parameter");
      }
      constructor(value, type, array3) {
        super();
        this.value = value;
        this.type = type;
        this.array = array3;
      }
    };
    Builder = class extends NotTagged {
      static {
        __name(this, "Builder");
      }
      constructor(first2, rest) {
        super();
        this.first = first2;
        this.rest = rest;
      }
      build(before, parameters, types4, options2) {
        const keyword = builders.map(([x, fn]) => ({ fn, i: before.search(x) })).sort((a, b2) => a.i - b2.i).pop();
        return keyword.i === -1 ? escapeIdentifiers(this.first, options2) : keyword.fn(this.first, this.rest, parameters, types4, options2);
      }
    };
    __name(handleValue, "handleValue");
    defaultHandlers = typeHandlers(types3);
    __name(stringify, "stringify");
    __name(stringifyValue, "stringifyValue");
    __name(fragment, "fragment");
    __name(valuesBuilder, "valuesBuilder");
    __name(values, "values");
    __name(select, "select");
    builders = Object.entries({
      values,
      in: /* @__PURE__ */ __name((...xs) => {
        const x = values(...xs);
        return x === "()" ? "(null)" : x;
      }, "in"),
      select,
      as: select,
      returning: select,
      "\\(": select,
      update(first2, rest, parameters, types4, options2) {
        return (rest.length ? rest.flat() : Object.keys(first2)).map(
          (x) => escapeIdentifier(options2.transform.column.to ? options2.transform.column.to(x) : x) + "=" + stringifyValue("values", first2[x], parameters, types4, options2)
        );
      },
      insert(first2, rest, parameters, types4, options2) {
        const columns = rest.length ? rest.flat() : Object.keys(Array.isArray(first2) ? first2[0] : first2);
        return "(" + escapeIdentifiers(columns, options2) + ")values" + valuesBuilder(Array.isArray(first2) ? first2 : [first2], parameters, types4, columns, options2);
      }
    }).map(([x, fn]) => [new RegExp("((?:^|[\\s(])" + x + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), fn]);
    __name(notTagged, "notTagged");
    serializers = defaultHandlers.serializers;
    parsers = defaultHandlers.parsers;
    __name(firstIsString, "firstIsString");
    mergeUserTypes = /* @__PURE__ */ __name(function(types4) {
      const user = typeHandlers(types4 || {});
      return {
        serializers: Object.assign({}, serializers, user.serializers),
        parsers: Object.assign({}, parsers, user.parsers)
      };
    }, "mergeUserTypes");
    __name(typeHandlers, "typeHandlers");
    __name(escapeIdentifiers, "escapeIdentifiers");
    escapeIdentifier = /* @__PURE__ */ __name(function escape(str) {
      return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
    }, "escape");
    inferType = /* @__PURE__ */ __name(function inferType2(x) {
      return x instanceof Parameter ? x.type : x instanceof Date ? 1184 : x instanceof Uint8Array ? 17 : x === true || x === false ? 16 : typeof x === "bigint" ? 20 : Array.isArray(x) ? inferType2(x[0]) : 0;
    }, "inferType");
    escapeBackslash = /\\/g;
    escapeQuote = /"/g;
    __name(arrayEscape, "arrayEscape");
    arraySerializer = /* @__PURE__ */ __name(function arraySerializer2(xs, serializer, options2, typarray) {
      if (Array.isArray(xs) === false)
        return xs;
      if (!xs.length)
        return "{}";
      const first2 = xs[0];
      const delimiter = typarray === 1020 ? ";" : ",";
      if (Array.isArray(first2) && !first2.type)
        return "{" + xs.map((x) => arraySerializer2(x, serializer, options2, typarray)).join(delimiter) + "}";
      return "{" + xs.map((x) => {
        if (x === void 0) {
          x = options2.transform.undefined;
          if (x === void 0)
            throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
        }
        return x === null ? "null" : '"' + arrayEscape(serializer ? serializer(x.type ? x.value : x) : "" + x) + '"';
      }).join(delimiter) + "}";
    }, "arraySerializer");
    arrayParserState = {
      i: 0,
      char: null,
      str: "",
      quoted: false,
      last: 0
    };
    arrayParser = /* @__PURE__ */ __name(function arrayParser2(x, parser, typarray) {
      arrayParserState.i = arrayParserState.last = 0;
      return arrayParserLoop(arrayParserState, x, parser, typarray);
    }, "arrayParser");
    __name(arrayParserLoop, "arrayParserLoop");
    toCamel = /* @__PURE__ */ __name((x) => {
      let str = x[0];
      for (let i = 1; i < x.length; i++)
        str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
      return str;
    }, "toCamel");
    toPascal = /* @__PURE__ */ __name((x) => {
      let str = x[0].toUpperCase();
      for (let i = 1; i < x.length; i++)
        str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
      return str;
    }, "toPascal");
    toKebab = /* @__PURE__ */ __name((x) => x.replace(/_/g, "-"), "toKebab");
    fromCamel = /* @__PURE__ */ __name((x) => x.replace(/([A-Z])/g, "_$1").toLowerCase(), "fromCamel");
    fromPascal = /* @__PURE__ */ __name((x) => (x.slice(0, 1) + x.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase(), "fromPascal");
    fromKebab = /* @__PURE__ */ __name((x) => x.replace(/-/g, "_"), "fromKebab");
    __name(createJsonTransform, "createJsonTransform");
    toCamel.column = { from: toCamel };
    toCamel.value = { from: createJsonTransform(toCamel) };
    fromCamel.column = { to: fromCamel };
    camel = { ...toCamel };
    camel.column.to = fromCamel;
    toPascal.column = { from: toPascal };
    toPascal.value = { from: createJsonTransform(toPascal) };
    fromPascal.column = { to: fromPascal };
    pascal = { ...toPascal };
    pascal.column.to = fromPascal;
    toKebab.column = { from: toKebab };
    toKebab.value = { from: createJsonTransform(toKebab) };
    fromKebab.column = { to: fromKebab };
    kebab = { ...toKebab };
    kebab.column.to = fromKebab;
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/result.js
var Result;
var init_result = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/result.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Result = class extends Array {
      static {
        __name(this, "Result");
      }
      constructor() {
        super();
        Object.defineProperties(this, {
          count: { value: null, writable: true },
          state: { value: null, writable: true },
          command: { value: null, writable: true },
          columns: { value: null, writable: true },
          statement: { value: null, writable: true }
        });
      }
      static get [Symbol.species]() {
        return Array;
      }
    };
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/queue.js
function Queue(initial2 = []) {
  let xs = initial2.slice();
  let index10 = 0;
  return {
    get length() {
      return xs.length - index10;
    },
    remove: /* @__PURE__ */ __name((x) => {
      const index11 = xs.indexOf(x);
      return index11 === -1 ? null : (xs.splice(index11, 1), x);
    }, "remove"),
    push: /* @__PURE__ */ __name((x) => (xs.push(x), x), "push"),
    shift: /* @__PURE__ */ __name(() => {
      const out = xs[index10++];
      if (index10 === xs.length) {
        index10 = 0;
        xs = [];
      } else {
        xs[index10 - 1] = void 0;
      }
      return out;
    }, "shift")
  };
}
var queue_default;
var init_queue = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/queue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    queue_default = Queue;
    __name(Queue, "Queue");
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/bytes.js
import { Buffer as Buffer4 } from "node:buffer";
function fit(x) {
  if (buffer.length - b.i < x) {
    const prev = buffer, length = prev.length;
    buffer = Buffer4.allocUnsafe(length + (length >> 1) + x);
    prev.copy(buffer);
  }
}
function reset() {
  b.i = 0;
  return b;
}
var size, buffer, messages, b, bytes_default;
var init_bytes = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/bytes.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    size = 256;
    buffer = Buffer4.allocUnsafe(size);
    messages = "BCcDdEFfHPpQSX".split("").reduce((acc, x) => {
      const v = x.charCodeAt(0);
      acc[x] = () => {
        buffer[0] = v;
        b.i = 5;
        return b;
      };
      return acc;
    }, {});
    b = Object.assign(reset, messages, {
      N: String.fromCharCode(0),
      i: 0,
      inc(x) {
        b.i += x;
        return b;
      },
      str(x) {
        const length = Buffer4.byteLength(x);
        fit(length);
        b.i += buffer.write(x, b.i, length, "utf8");
        return b;
      },
      i16(x) {
        fit(2);
        buffer.writeUInt16BE(x, b.i);
        b.i += 2;
        return b;
      },
      i32(x, i) {
        if (i || i === 0) {
          buffer.writeUInt32BE(x, i);
          return b;
        }
        fit(4);
        buffer.writeUInt32BE(x, b.i);
        b.i += 4;
        return b;
      },
      z(x) {
        fit(x);
        buffer.fill(0, b.i, b.i + x);
        b.i += x;
        return b;
      },
      raw(x) {
        buffer = Buffer4.concat([buffer.subarray(0, b.i), x]);
        b.i = buffer.length;
        return b;
      },
      end(at = 1) {
        buffer.writeUInt32BE(b.i - at, at);
        const out = buffer.subarray(0, b.i);
        b.i = 0;
        buffer = Buffer4.allocUnsafe(size);
        return out;
      }
    });
    bytes_default = b;
    __name(fit, "fit");
    __name(reset, "reset");
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/connection.js
import { Buffer as Buffer5 } from "node:buffer";
import Stream from "node:stream";
function Connection(options2, queues = {}, { onopen = noop2, onend = noop2, onclose = noop2 } = {}) {
  const {
    ssl,
    max,
    user,
    host,
    port,
    database,
    parsers: parsers2,
    transform,
    onnotice,
    onnotify,
    onparameter,
    max_pipeline,
    keep_alive,
    backoff: backoff2,
    target_session_attrs
  } = options2;
  const sent = queue_default(), id = uid++, backend = { pid: null, secret: null }, idleTimer = timer(end, options2.idle_timeout), lifeTimer = timer(end, options2.max_lifetime), connectTimer = timer(connectTimedOut, options2.connect_timeout);
  let socket = null, cancelMessage, result = new Result(), incoming = Buffer5.alloc(0), needsTypes = options2.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length = 0, delay = 0, rows = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial2 = null, ending = null, stream = null, chunk = null, ended = null, nonce = null, query = null, final = null;
  const connection2 = {
    queue: queues.closed,
    idleTimer,
    connect(query2) {
      initial2 = query2;
      reconnect();
    },
    terminate,
    execute,
    cancel,
    end,
    count: 0,
    id
  };
  queues.closed && queues.closed.push(connection2);
  return connection2;
  async function createSocket2() {
    let x;
    try {
      x = options2.socket ? await Promise.resolve(options2.socket(options2)) : new net.Socket();
    } catch (e3) {
      error3(e3);
      return;
    }
    x.on("error", error3);
    x.on("close", closed);
    x.on("drain", drain);
    return x;
  }
  __name(createSocket2, "createSocket");
  async function cancel({ pid: pid2, secret }, resolve2, reject) {
    try {
      cancelMessage = bytes_default().i32(16).i32(80877102).i32(pid2).i32(secret).end(16);
      await connect();
      socket.once("error", reject);
      socket.once("close", resolve2);
    } catch (error4) {
      reject(error4);
    }
  }
  __name(cancel, "cancel");
  function execute(q) {
    if (terminated)
      return queryError(q, Errors.connection("CONNECTION_DESTROYED", options2));
    if (q.cancelled)
      return;
    try {
      q.state = backend;
      query ? sent.push(q) : (query = q, query.active = true);
      build(q);
      return write(toBuffer(q)) && !q.describeFirst && !q.cursorFn && sent.length < max_pipeline && (!q.options.onexecute || q.options.onexecute(connection2));
    } catch (error4) {
      sent.length === 0 && write(Sync);
      errored(error4);
      return true;
    }
  }
  __name(execute, "execute");
  function toBuffer(q) {
    if (q.parameters.length >= 65534)
      throw Errors.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return q.options.simple ? bytes_default().Q().str(q.statement.string + bytes_default.N).end() : q.describeFirst ? Buffer5.concat([describe(q), Flush]) : q.prepare ? q.prepared ? prepared(q) : Buffer5.concat([describe(q), prepared(q)]) : unnamed(q);
  }
  __name(toBuffer, "toBuffer");
  function describe(q) {
    return Buffer5.concat([
      Parse(q.statement.string, q.parameters, q.statement.types, q.statement.name),
      Describe("S", q.statement.name)
    ]);
  }
  __name(describe, "describe");
  function prepared(q) {
    return Buffer5.concat([
      Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),
      q.cursorFn ? Execute("", q.cursorRows) : ExecuteUnnamed
    ]);
  }
  __name(prepared, "prepared");
  function unnamed(q) {
    return Buffer5.concat([
      Parse(q.statement.string, q.parameters, q.statement.types),
      DescribeUnnamed,
      prepared(q)
    ]);
  }
  __name(unnamed, "unnamed");
  function build(q) {
    const parameters = [], types4 = [];
    const string2 = stringify(q, q.strings[0], q.args[0], parameters, types4, options2);
    !q.tagged && q.args.forEach((x) => handleValue(x, parameters, types4, options2));
    q.prepare = options2.prepare && ("prepare" in q.options ? q.options.prepare : true);
    q.string = string2;
    q.signature = q.prepare && types4 + string2;
    q.onlyDescribe && delete statements[q.signature];
    q.parameters = q.parameters || parameters;
    q.prepared = q.prepare && q.signature in statements;
    q.describeFirst = q.onlyDescribe || parameters.length && !q.prepared;
    q.statement = q.prepared ? statements[q.signature] : { string: string2, types: types4, name: q.prepare ? statementId + statementCount++ : "" };
    typeof options2.debug === "function" && options2.debug(id, string2, parameters, types4);
  }
  __name(build, "build");
  function write(x, fn) {
    chunk = chunk ? Buffer5.concat([chunk, x]) : Buffer5.from(x);
    if (fn || chunk.length >= 1024)
      return nextWrite(fn);
    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
    return true;
  }
  __name(write, "write");
  function nextWrite(fn) {
    const x = socket.write(chunk, fn);
    nextWriteTimer !== null && clearImmediate(nextWriteTimer);
    chunk = nextWriteTimer = null;
    return x;
  }
  __name(nextWrite, "nextWrite");
  function connectTimedOut() {
    errored(Errors.connection("CONNECT_TIMEOUT", options2, socket));
    socket.destroy();
  }
  __name(connectTimedOut, "connectTimedOut");
  async function secure() {
    write(SSLRequest);
    const canSSL = await new Promise((r3) => socket.once("data", (x) => r3(x[0] === 83)));
    if (!canSSL && ssl === "prefer")
      return connected2();
    socket.removeAllListeners();
    socket = tls.connect({
      socket,
      servername: net.isIP(socket.host) ? void 0 : socket.host,
      ...ssl === "require" || ssl === "allow" || ssl === "prefer" ? { rejectUnauthorized: false } : ssl === "verify-full" ? {} : typeof ssl === "object" ? ssl : {}
    });
    socket.on("secureConnect", connected2);
    socket.on("error", error3);
    socket.on("close", closed);
    socket.on("drain", drain);
  }
  __name(secure, "secure");
  function drain() {
    !query && onopen(connection2);
  }
  __name(drain, "drain");
  function data(x) {
    if (incomings) {
      incomings.push(x);
      remaining -= x.length;
      if (remaining > 0)
        return;
    }
    incoming = incomings ? Buffer5.concat(incomings, length - remaining) : incoming.length === 0 ? x : Buffer5.concat([incoming, x], incoming.length + x.length);
    while (incoming.length > 4) {
      length = incoming.readUInt32BE(1);
      if (length >= incoming.length) {
        remaining = length - incoming.length;
        incomings = [incoming];
        break;
      }
      try {
        handle2(incoming.subarray(0, length + 1));
      } catch (e3) {
        query && (query.cursorFn || query.describeFirst) && write(Sync);
        errored(e3);
      }
      incoming = incoming.subarray(length + 1);
      remaining = 0;
      incomings = null;
    }
  }
  __name(data, "data");
  async function connect() {
    terminated = false;
    backendParameters = {};
    socket || (socket = await createSocket2());
    if (!socket)
      return;
    connectTimer.start();
    if (options2.socket)
      return ssl ? secure() : connected2();
    socket.on("connect", ssl ? secure : connected2);
    if (options2.path)
      return socket.connect(options2.path);
    socket.ssl = ssl;
    socket.connect(port[hostIndex], host[hostIndex]);
    socket.host = host[hostIndex];
    socket.port = port[hostIndex];
    hostIndex = (hostIndex + 1) % port.length;
  }
  __name(connect, "connect");
  function reconnect() {
    setTimeout(connect, closedDate ? closedDate + delay - performance3.now() : 0);
  }
  __name(reconnect, "reconnect");
  function connected2() {
    try {
      statements = {};
      needsTypes = options2.fetch_types;
      statementId = Math.random().toString(36).slice(2);
      statementCount = 1;
      lifeTimer.start();
      socket.on("data", data);
      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1e3 * keep_alive);
      const s3 = StartupMessage();
      write(s3);
    } catch (err2) {
      error3(err2);
    }
  }
  __name(connected2, "connected");
  function error3(err2) {
    if (connection2.queue === queues.connecting && options2.host[retries + 1])
      return;
    errored(err2);
    while (sent.length)
      queryError(sent.shift(), err2);
  }
  __name(error3, "error");
  function errored(err2) {
    stream && (stream.destroy(err2), stream = null);
    query && queryError(query, err2);
    initial2 && (queryError(initial2, err2), initial2 = null);
  }
  __name(errored, "errored");
  function queryError(query2, err2) {
    if (query2.reserve)
      return query2.reject(err2);
    if (!err2 || typeof err2 !== "object")
      err2 = new Error(err2);
    "query" in err2 || "parameters" in err2 || Object.defineProperties(err2, {
      stack: { value: err2.stack + query2.origin.replace(/.*\n/, "\n"), enumerable: options2.debug },
      query: { value: query2.string, enumerable: options2.debug },
      parameters: { value: query2.parameters, enumerable: options2.debug },
      args: { value: query2.args, enumerable: options2.debug },
      types: { value: query2.statement && query2.statement.types, enumerable: options2.debug }
    });
    query2.reject(err2);
  }
  __name(queryError, "queryError");
  function end() {
    return ending || (!connection2.reserved && onend(connection2), !connection2.reserved && !initial2 && !query && sent.length === 0 ? (terminate(), new Promise((r3) => socket && socket.readyState !== "closed" ? socket.once("close", r3) : r3())) : ending = new Promise((r3) => ended = r3));
  }
  __name(end, "end");
  function terminate() {
    terminated = true;
    if (stream || query || initial2 || sent.length)
      error3(Errors.connection("CONNECTION_DESTROYED", options2));
    clearImmediate(nextWriteTimer);
    if (socket) {
      socket.removeListener("data", data);
      socket.removeListener("connect", connected2);
      socket.readyState === "open" && socket.end(bytes_default().X().end());
    }
    ended && (ended(), ending = ended = null);
  }
  __name(terminate, "terminate");
  async function closed(hadError) {
    incoming = Buffer5.alloc(0);
    remaining = 0;
    incomings = null;
    clearImmediate(nextWriteTimer);
    socket.removeListener("data", data);
    socket.removeListener("connect", connected2);
    idleTimer.cancel();
    lifeTimer.cancel();
    connectTimer.cancel();
    socket.removeAllListeners();
    socket = null;
    if (initial2)
      return reconnect();
    !hadError && (query || sent.length) && error3(Errors.connection("CONNECTION_CLOSED", options2, socket));
    closedDate = performance3.now();
    hadError && options2.shared.retries++;
    delay = (typeof backoff2 === "function" ? backoff2(options2.shared.retries) : backoff2) * 1e3;
    onclose(connection2, Errors.connection("CONNECTION_CLOSED", options2, socket));
  }
  __name(closed, "closed");
  function handle2(xs, x = xs[0]) {
    (x === 68 ? DataRow : (
      // D
      x === 100 ? CopyData : (
        // d
        x === 65 ? NotificationResponse : (
          // A
          x === 83 ? ParameterStatus : (
            // S
            x === 90 ? ReadyForQuery : (
              // Z
              x === 67 ? CommandComplete : (
                // C
                x === 50 ? BindComplete : (
                  // 2
                  x === 49 ? ParseComplete : (
                    // 1
                    x === 116 ? ParameterDescription : (
                      // t
                      x === 84 ? RowDescription : (
                        // T
                        x === 82 ? Authentication : (
                          // R
                          x === 110 ? NoData : (
                            // n
                            x === 75 ? BackendKeyData : (
                              // K
                              x === 69 ? ErrorResponse : (
                                // E
                                x === 115 ? PortalSuspended : (
                                  // s
                                  x === 51 ? CloseComplete : (
                                    // 3
                                    x === 71 ? CopyInResponse : (
                                      // G
                                      x === 78 ? NoticeResponse : (
                                        // N
                                        x === 72 ? CopyOutResponse : (
                                          // H
                                          x === 99 ? CopyDone : (
                                            // c
                                            x === 73 ? EmptyQueryResponse : (
                                              // I
                                              x === 86 ? FunctionCallResponse : (
                                                // V
                                                x === 118 ? NegotiateProtocolVersion : (
                                                  // v
                                                  x === 87 ? CopyBothResponse : (
                                                    // W
                                                    /* c8 ignore next */
                                                    UnknownMessage
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    ))(xs);
  }
  __name(handle2, "handle");
  function DataRow(x) {
    let index10 = 7;
    let length2;
    let column;
    let value;
    const row = query.isRaw ? new Array(query.statement.columns.length) : {};
    for (let i = 0; i < query.statement.columns.length; i++) {
      column = query.statement.columns[i];
      length2 = x.readInt32BE(index10);
      index10 += 4;
      value = length2 === -1 ? null : query.isRaw === true ? x.subarray(index10, index10 += length2) : column.parser === void 0 ? x.toString("utf8", index10, index10 += length2) : column.parser.array === true ? column.parser(x.toString("utf8", index10 + 1, index10 += length2)) : column.parser(x.toString("utf8", index10, index10 += length2));
      query.isRaw ? row[i] = query.isRaw === true ? value : transform.value.from ? transform.value.from(value, column) : value : row[column.name] = transform.value.from ? transform.value.from(value, column) : value;
    }
    query.forEachFn ? query.forEachFn(transform.row.from ? transform.row.from(row) : row, result) : result[rows++] = transform.row.from ? transform.row.from(row) : row;
  }
  __name(DataRow, "DataRow");
  function ParameterStatus(x) {
    const [k, v] = x.toString("utf8", 5, x.length - 1).split(bytes_default.N);
    backendParameters[k] = v;
    if (options2.parameters[k] !== v) {
      options2.parameters[k] = v;
      onparameter && onparameter(k, v);
    }
  }
  __name(ParameterStatus, "ParameterStatus");
  function ReadyForQuery(x) {
    query && query.options.simple && query.resolve(results || result);
    query = results = null;
    result = new Result();
    connectTimer.cancel();
    if (initial2) {
      if (target_session_attrs) {
        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)
          return fetchState();
        else if (tryNext(target_session_attrs, backendParameters))
          return terminate();
      }
      if (needsTypes) {
        initial2.reserve && (initial2 = null);
        return fetchArrayTypes();
      }
      initial2 && !initial2.reserve && execute(initial2);
      options2.shared.retries = retries = 0;
      initial2 = null;
      return;
    }
    while (sent.length && (query = sent.shift()) && (query.active = true, query.cancelled))
      Connection(options2).cancel(query.state, query.cancelled.resolve, query.cancelled.reject);
    if (query)
      return;
    connection2.reserved ? !connection2.reserved.release && x[5] === 73 ? ending ? terminate() : (connection2.reserved = null, onopen(connection2)) : connection2.reserved() : ending ? terminate() : onopen(connection2);
  }
  __name(ReadyForQuery, "ReadyForQuery");
  function CommandComplete(x) {
    rows = 0;
    for (let i = x.length - 1; i > 0; i--) {
      if (x[i] === 32 && x[i + 1] < 58 && result.count === null)
        result.count = +x.toString("utf8", i + 1, x.length - 1);
      if (x[i - 1] >= 65) {
        result.command = x.toString("utf8", 5, i);
        result.state = backend;
        break;
      }
    }
    final && (final(), final = null);
    if (result.command === "BEGIN" && max !== 1 && !connection2.reserved)
      return errored(Errors.generic("UNSAFE_TRANSACTION", "Only use sql.begin, sql.reserved or max: 1"));
    if (query.options.simple)
      return BindComplete();
    if (query.cursorFn) {
      result.count && query.cursorFn(result);
      write(Sync);
    }
    query.resolve(result);
  }
  __name(CommandComplete, "CommandComplete");
  function ParseComplete() {
    query.parsing = false;
  }
  __name(ParseComplete, "ParseComplete");
  function BindComplete() {
    !result.statement && (result.statement = query.statement);
    result.columns = query.statement.columns;
  }
  __name(BindComplete, "BindComplete");
  function ParameterDescription(x) {
    const length2 = x.readUInt16BE(5);
    for (let i = 0; i < length2; ++i)
      !query.statement.types[i] && (query.statement.types[i] = x.readUInt32BE(7 + i * 4));
    query.prepare && (statements[query.signature] = query.statement);
    query.describeFirst && !query.onlyDescribe && (write(prepared(query)), query.describeFirst = false);
  }
  __name(ParameterDescription, "ParameterDescription");
  function RowDescription(x) {
    if (result.command) {
      results = results || [result];
      results.push(result = new Result());
      result.count = null;
      query.statement.columns = null;
    }
    const length2 = x.readUInt16BE(5);
    let index10 = 7;
    let start;
    query.statement.columns = Array(length2);
    for (let i = 0; i < length2; ++i) {
      start = index10;
      while (x[index10++] !== 0) ;
      const table4 = x.readUInt32BE(index10);
      const number2 = x.readUInt16BE(index10 + 4);
      const type = x.readUInt32BE(index10 + 6);
      query.statement.columns[i] = {
        name: transform.column.from ? transform.column.from(x.toString("utf8", start, index10 - 1)) : x.toString("utf8", start, index10 - 1),
        parser: parsers2[type],
        table: table4,
        number: number2,
        type
      };
      index10 += 18;
    }
    result.statement = query.statement;
    if (query.onlyDescribe)
      return query.resolve(query.statement), write(Sync);
  }
  __name(RowDescription, "RowDescription");
  async function Authentication(x, type = x.readUInt32BE(5)) {
    (type === 3 ? AuthenticationCleartextPassword : type === 5 ? AuthenticationMD5Password : type === 10 ? SASL : type === 11 ? SASLContinue : type === 12 ? SASLFinal : type !== 0 ? UnknownAuth : noop2)(x, type);
  }
  __name(Authentication, "Authentication");
  async function AuthenticationCleartextPassword() {
    const payload = await Pass();
    write(
      bytes_default().p().str(payload).z(1).end()
    );
  }
  __name(AuthenticationCleartextPassword, "AuthenticationCleartextPassword");
  async function AuthenticationMD5Password(x) {
    const payload = "md5" + await md5(
      Buffer5.concat([
        Buffer5.from(await md5(await Pass() + user)),
        x.subarray(9)
      ])
    );
    write(
      bytes_default().p().str(payload).z(1).end()
    );
  }
  __name(AuthenticationMD5Password, "AuthenticationMD5Password");
  async function SASL() {
    nonce = (await crypto2.randomBytes(18)).toString("base64");
    bytes_default().p().str("SCRAM-SHA-256" + bytes_default.N);
    const i = bytes_default.i;
    write(bytes_default.inc(4).str("n,,n=*,r=" + nonce).i32(bytes_default.i - i - 4, i).end());
  }
  __name(SASL, "SASL");
  async function SASLContinue(x) {
    const res = x.toString("utf8", 9).split(",").reduce((acc, x2) => (acc[x2[0]] = x2.slice(2), acc), {});
    const saltedPassword = await crypto2.pbkdf2Sync(
      await Pass(),
      Buffer5.from(res.s, "base64"),
      parseInt(res.i),
      32,
      "sha256"
    );
    const clientKey = await hmac(saltedPassword, "Client Key");
    const auth = "n=*,r=" + nonce + ",r=" + res.r + ",s=" + res.s + ",i=" + res.i + ",c=biws,r=" + res.r;
    serverSignature = (await hmac(await hmac(saltedPassword, "Server Key"), auth)).toString("base64");
    const payload = "c=biws,r=" + res.r + ",p=" + xor(
      clientKey,
      Buffer5.from(await hmac(await sha256(clientKey), auth))
    ).toString("base64");
    write(
      bytes_default().p().str(payload).end()
    );
  }
  __name(SASLContinue, "SASLContinue");
  function SASLFinal(x) {
    if (x.toString("utf8", 9).split(bytes_default.N, 1)[0].slice(2) === serverSignature)
      return;
    errored(Errors.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature"));
    socket.destroy();
  }
  __name(SASLFinal, "SASLFinal");
  function Pass() {
    return Promise.resolve(
      typeof options2.pass === "function" ? options2.pass() : options2.pass
    );
  }
  __name(Pass, "Pass");
  function NoData() {
    result.statement = query.statement;
    result.statement.columns = [];
    if (query.onlyDescribe)
      return query.resolve(query.statement), write(Sync);
  }
  __name(NoData, "NoData");
  function BackendKeyData(x) {
    backend.pid = x.readUInt32BE(5);
    backend.secret = x.readUInt32BE(9);
  }
  __name(BackendKeyData, "BackendKeyData");
  async function fetchArrayTypes() {
    needsTypes = false;
    const types4 = await new Query([`
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `], [], execute);
    types4.forEach(({ oid, typarray }) => addArrayType(oid, typarray));
  }
  __name(fetchArrayTypes, "fetchArrayTypes");
  function addArrayType(oid, typarray) {
    if (!!options2.parsers[typarray] && !!options2.serializers[typarray]) return;
    const parser = options2.parsers[oid];
    options2.shared.typeArrayMap[oid] = typarray;
    options2.parsers[typarray] = (xs) => arrayParser(xs, parser, typarray);
    options2.parsers[typarray].array = true;
    options2.serializers[typarray] = (xs) => arraySerializer(xs, options2.serializers[oid], options2, typarray);
  }
  __name(addArrayType, "addArrayType");
  function tryNext(x, xs) {
    return x === "read-write" && xs.default_transaction_read_only === "on" || x === "read-only" && xs.default_transaction_read_only === "off" || x === "primary" && xs.in_hot_standby === "on" || x === "standby" && xs.in_hot_standby === "off" || x === "prefer-standby" && xs.in_hot_standby === "off" && options2.host[retries];
  }
  __name(tryNext, "tryNext");
  function fetchState() {
    const query2 = new Query([`
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `], [], execute, null, { simple: true });
    query2.resolve = ([[a], [b2]]) => {
      backendParameters.default_transaction_read_only = a.transaction_read_only;
      backendParameters.in_hot_standby = b2.pg_is_in_recovery ? "on" : "off";
    };
    query2.execute();
  }
  __name(fetchState, "fetchState");
  function ErrorResponse(x) {
    query && (query.cursorFn || query.describeFirst) && write(Sync);
    const error4 = Errors.postgres(parseError(x));
    query && query.retried ? errored(query.retried) : query && query.prepared && retryRoutines.has(error4.routine) ? retry(query, error4) : errored(error4);
  }
  __name(ErrorResponse, "ErrorResponse");
  function retry(q, error4) {
    delete statements[q.signature];
    q.retried = error4;
    execute(q);
  }
  __name(retry, "retry");
  function NotificationResponse(x) {
    if (!onnotify)
      return;
    let index10 = 9;
    while (x[index10++] !== 0) ;
    onnotify(
      x.toString("utf8", 9, index10 - 1),
      x.toString("utf8", index10, x.length - 1)
    );
  }
  __name(NotificationResponse, "NotificationResponse");
  async function PortalSuspended() {
    try {
      const x = await Promise.resolve(query.cursorFn(result));
      rows = 0;
      x === CLOSE ? write(Close(query.portal)) : (result = new Result(), write(Execute("", query.cursorRows)));
    } catch (err2) {
      write(Sync);
      query.reject(err2);
    }
  }
  __name(PortalSuspended, "PortalSuspended");
  function CloseComplete() {
    result.count && query.cursorFn(result);
    query.resolve(result);
  }
  __name(CloseComplete, "CloseComplete");
  function CopyInResponse() {
    stream = new Stream.Writable({
      autoDestroy: true,
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error4, callback) {
        callback(error4);
        socket.write(bytes_default().f().str(error4 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  __name(CopyInResponse, "CopyInResponse");
  function CopyOutResponse() {
    stream = new Stream.Readable({
      read() {
        socket.resume();
      }
    });
    query.resolve(stream);
  }
  __name(CopyOutResponse, "CopyOutResponse");
  function CopyBothResponse() {
    stream = new Stream.Duplex({
      autoDestroy: true,
      read() {
        socket.resume();
      },
      /* c8 ignore next 11 */
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error4, callback) {
        callback(error4);
        socket.write(bytes_default().f().str(error4 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  __name(CopyBothResponse, "CopyBothResponse");
  function CopyData(x) {
    stream && (stream.push(x.subarray(5)) || socket.pause());
  }
  __name(CopyData, "CopyData");
  function CopyDone() {
    stream && stream.push(null);
    stream = null;
  }
  __name(CopyDone, "CopyDone");
  function NoticeResponse(x) {
    onnotice ? onnotice(parseError(x)) : console.log(parseError(x));
  }
  __name(NoticeResponse, "NoticeResponse");
  function EmptyQueryResponse() {
  }
  __name(EmptyQueryResponse, "EmptyQueryResponse");
  function FunctionCallResponse() {
    errored(Errors.notSupported("FunctionCallResponse"));
  }
  __name(FunctionCallResponse, "FunctionCallResponse");
  function NegotiateProtocolVersion() {
    errored(Errors.notSupported("NegotiateProtocolVersion"));
  }
  __name(NegotiateProtocolVersion, "NegotiateProtocolVersion");
  function UnknownMessage(x) {
    console.error("Postgres.js : Unknown Message:", x[0]);
  }
  __name(UnknownMessage, "UnknownMessage");
  function UnknownAuth(x, type) {
    console.error("Postgres.js : Unknown Auth:", type);
  }
  __name(UnknownAuth, "UnknownAuth");
  function Bind(parameters, types4, statement = "", portal = "") {
    let prev, type;
    bytes_default().B().str(portal + bytes_default.N).str(statement + bytes_default.N).i16(0).i16(parameters.length);
    parameters.forEach((x, i) => {
      if (x === null)
        return bytes_default.i32(4294967295);
      type = types4[i];
      parameters[i] = x = type in options2.serializers ? options2.serializers[type](x) : "" + x;
      prev = bytes_default.i;
      bytes_default.inc(4).str(x).i32(bytes_default.i - prev - 4, prev);
    });
    bytes_default.i16(0);
    return bytes_default.end();
  }
  __name(Bind, "Bind");
  function Parse(str, parameters, types4, name = "") {
    bytes_default().P().str(name + bytes_default.N).str(str + bytes_default.N).i16(parameters.length);
    parameters.forEach((x, i) => bytes_default.i32(types4[i] || 0));
    return bytes_default.end();
  }
  __name(Parse, "Parse");
  function Describe(x, name = "") {
    return bytes_default().D().str(x).str(name + bytes_default.N).end();
  }
  __name(Describe, "Describe");
  function Execute(portal = "", rows2 = 0) {
    return Buffer5.concat([
      bytes_default().E().str(portal + bytes_default.N).i32(rows2).end(),
      Flush
    ]);
  }
  __name(Execute, "Execute");
  function Close(portal = "") {
    return Buffer5.concat([
      bytes_default().C().str("P").str(portal + bytes_default.N).end(),
      bytes_default().S().end()
    ]);
  }
  __name(Close, "Close");
  function StartupMessage() {
    return cancelMessage || bytes_default().inc(4).i16(3).z(2).str(
      Object.entries(Object.assign(
        {
          user,
          database,
          client_encoding: "UTF8"
        },
        options2.connection
      )).filter(([, v]) => v).map(([k, v]) => k + bytes_default.N + v).join(bytes_default.N)
    ).z(2).end(0);
  }
  __name(StartupMessage, "StartupMessage");
}
function parseError(x) {
  const error3 = {};
  let start = 5;
  for (let i = 5; i < x.length - 1; i++) {
    if (x[i] === 0) {
      error3[errorFields[x[start]]] = x.toString("utf8", start + 1, i);
      start = i + 1;
    }
  }
  return error3;
}
function md5(x) {
  return crypto2.createHash("md5").update(x).digest("hex");
}
function hmac(key2, x) {
  return crypto2.createHmac("sha256", key2).update(x).digest();
}
function sha256(x) {
  return crypto2.createHash("sha256").update(x).digest();
}
function xor(a, b2) {
  const length = Math.max(a.length, b2.length);
  const buffer2 = Buffer5.allocUnsafe(length);
  for (let i = 0; i < length; i++)
    buffer2[i] = a[i] ^ b2[i];
  return buffer2;
}
function timer(fn, seconds) {
  seconds = typeof seconds === "function" ? seconds() : seconds;
  if (!seconds)
    return { cancel: noop2, start: noop2 };
  let timer2;
  return {
    cancel() {
      timer2 && (clearTimeout(timer2), timer2 = null);
    },
    start() {
      timer2 && clearTimeout(timer2);
      timer2 = setTimeout(done, seconds * 1e3, arguments);
    }
  };
  function done(args) {
    fn.apply(null, args);
    timer2 = null;
  }
  __name(done, "done");
}
var connection_default, uid, Sync, Flush, SSLRequest, ExecuteUnnamed, DescribeUnnamed, noop2, retryRoutines, errorFields;
var init_connection = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/connection.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_polyfills();
    init_polyfills();
    init_polyfills();
    init_polyfills();
    init_polyfills();
    init_types();
    init_errors();
    init_result();
    init_queue();
    init_query();
    init_bytes();
    connection_default = Connection;
    uid = 1;
    Sync = bytes_default().S().end();
    Flush = bytes_default().H().end();
    SSLRequest = bytes_default().i32(8).i32(80877103).end(8);
    ExecuteUnnamed = Buffer5.concat([bytes_default().E().str(bytes_default.N).i32(0).end(), Sync]);
    DescribeUnnamed = bytes_default().D().str("S").str(bytes_default.N).end();
    noop2 = /* @__PURE__ */ __name(() => {
    }, "noop");
    retryRoutines = /* @__PURE__ */ new Set([
      "FetchPreparedStatement",
      "RevalidateCachedQuery",
      "transformAssignedExpr"
    ]);
    errorFields = {
      83: "severity_local",
      // S
      86: "severity",
      // V
      67: "code",
      // C
      77: "message",
      // M
      68: "detail",
      // D
      72: "hint",
      // H
      80: "position",
      // P
      112: "internal_position",
      // p
      113: "internal_query",
      // q
      87: "where",
      // W
      115: "schema_name",
      // s
      116: "table_name",
      // t
      99: "column_name",
      // c
      100: "data type_name",
      // d
      110: "constraint_name",
      // n
      70: "file",
      // F
      76: "line",
      // L
      82: "routine"
      // R
    };
    __name(Connection, "Connection");
    __name(parseError, "parseError");
    __name(md5, "md5");
    __name(hmac, "hmac");
    __name(sha256, "sha256");
    __name(xor, "xor");
    __name(timer, "timer");
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/subscribe.js
import { Buffer as Buffer6 } from "node:buffer";
function Subscribe(postgres2, options2) {
  const subscribers = /* @__PURE__ */ new Map(), slot = "postgresjs_" + Math.random().toString(36).slice(2), state2 = {};
  let connection2, stream, ended = false;
  const sql2 = subscribe.sql = postgres2({
    ...options2,
    transform: { column: {}, value: {}, row: {} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: {
      ...options2.connection,
      replication: "database"
    },
    onclose: /* @__PURE__ */ __name(async function() {
      if (ended)
        return;
      stream = null;
      state2.pid = state2.secret = void 0;
      connected2(await init2(sql2, slot, options2.publications));
      subscribers.forEach((event) => event.forEach(({ onsubscribe }) => onsubscribe()));
    }, "onclose"),
    no_subscribe: true
  });
  const end = sql2.end, close = sql2.close;
  sql2.end = async () => {
    ended = true;
    stream && await new Promise((r3) => (stream.once("close", r3), stream.end()));
    return end();
  };
  sql2.close = async () => {
    stream && await new Promise((r3) => (stream.once("close", r3), stream.end()));
    return close();
  };
  return subscribe;
  async function subscribe(event, fn, onsubscribe = noop3, onerror = noop3) {
    event = parseEvent(event);
    if (!connection2)
      connection2 = init2(sql2, slot, options2.publications);
    const subscriber = { fn, onsubscribe };
    const fns = subscribers.has(event) ? subscribers.get(event).add(subscriber) : subscribers.set(event, /* @__PURE__ */ new Set([subscriber])).get(event);
    const unsubscribe = /* @__PURE__ */ __name(() => {
      fns.delete(subscriber);
      fns.size === 0 && subscribers.delete(event);
    }, "unsubscribe");
    return connection2.then((x) => {
      connected2(x);
      onsubscribe();
      stream && stream.on("error", onerror);
      return { unsubscribe, state: state2, sql: sql2 };
    });
  }
  __name(subscribe, "subscribe");
  function connected2(x) {
    stream = x.stream;
    state2.pid = x.state.pid;
    state2.secret = x.state.secret;
  }
  __name(connected2, "connected");
  async function init2(sql3, slot2, publications) {
    if (!publications)
      throw new Error("Missing publication names");
    const xs = await sql3.unsafe(
      `CREATE_REPLICATION_SLOT ${slot2} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`
    );
    const [x] = xs;
    const stream2 = await sql3.unsafe(
      `START_REPLICATION SLOT ${slot2} LOGICAL ${x.consistent_point} (proto_version '1', publication_names '${publications}')`
    ).writable();
    const state3 = {
      lsn: Buffer6.concat(x.consistent_point.split("/").map((x2) => Buffer6.from(("00000000" + x2).slice(-8), "hex")))
    };
    stream2.on("data", data);
    stream2.on("error", error3);
    stream2.on("close", sql3.close);
    return { stream: stream2, state: xs.state };
    function error3(e3) {
      console.error("Unexpected error during logical streaming - reconnecting", e3);
    }
    __name(error3, "error");
    function data(x2) {
      if (x2[0] === 119) {
        parse(x2.subarray(25), state3, sql3.options.parsers, handle2, options2.transform);
      } else if (x2[0] === 107 && x2[17]) {
        state3.lsn = x2.subarray(1, 9);
        pong();
      }
    }
    __name(data, "data");
    function handle2(a, b2) {
      const path2 = b2.relation.schema + "." + b2.relation.table;
      call("*", a, b2);
      call("*:" + path2, a, b2);
      b2.relation.keys.length && call("*:" + path2 + "=" + b2.relation.keys.map((x2) => a[x2.name]), a, b2);
      call(b2.command, a, b2);
      call(b2.command + ":" + path2, a, b2);
      b2.relation.keys.length && call(b2.command + ":" + path2 + "=" + b2.relation.keys.map((x2) => a[x2.name]), a, b2);
    }
    __name(handle2, "handle");
    function pong() {
      const x2 = Buffer6.alloc(34);
      x2[0] = "r".charCodeAt(0);
      x2.fill(state3.lsn, 1);
      x2.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2e3, 0, 1)) * BigInt(1e3), 25);
      stream2.write(x2);
    }
    __name(pong, "pong");
  }
  __name(init2, "init");
  function call(x, a, b2) {
    subscribers.has(x) && subscribers.get(x).forEach(({ fn }) => fn(a, b2, x));
  }
  __name(call, "call");
}
function Time(x) {
  return new Date(Date.UTC(2e3, 0, 1) + Number(x / BigInt(1e3)));
}
function parse(x, state2, parsers2, handle2, transform) {
  const char2 = /* @__PURE__ */ __name((acc, [k, v]) => (acc[k.charCodeAt(0)] = v, acc), "char");
  Object.entries({
    R: /* @__PURE__ */ __name((x2) => {
      let i = 1;
      const r3 = state2[x2.readUInt32BE(i)] = {
        schema: x2.toString("utf8", i += 4, i = x2.indexOf(0, i)) || "pg_catalog",
        table: x2.toString("utf8", i + 1, i = x2.indexOf(0, i + 1)),
        columns: Array(x2.readUInt16BE(i += 2)),
        keys: []
      };
      i += 2;
      let columnIndex = 0, column;
      while (i < x2.length) {
        column = r3.columns[columnIndex++] = {
          key: x2[i++],
          name: transform.column.from ? transform.column.from(x2.toString("utf8", i, i = x2.indexOf(0, i))) : x2.toString("utf8", i, i = x2.indexOf(0, i)),
          type: x2.readUInt32BE(i += 1),
          parser: parsers2[x2.readUInt32BE(i)],
          atttypmod: x2.readUInt32BE(i += 4)
        };
        column.key && r3.keys.push(column);
        i += 4;
      }
    }, "R"),
    Y: /* @__PURE__ */ __name(() => {
    }, "Y"),
    // Type
    O: /* @__PURE__ */ __name(() => {
    }, "O"),
    // Origin
    B: /* @__PURE__ */ __name((x2) => {
      state2.date = Time(x2.readBigInt64BE(9));
      state2.lsn = x2.subarray(1, 9);
    }, "B"),
    I: /* @__PURE__ */ __name((x2) => {
      let i = 1;
      const relation = state2[x2.readUInt32BE(i)];
      const { row } = tuples(x2, relation.columns, i += 7, transform);
      handle2(row, {
        command: "insert",
        relation
      });
    }, "I"),
    D: /* @__PURE__ */ __name((x2) => {
      let i = 1;
      const relation = state2[x2.readUInt32BE(i)];
      i += 4;
      const key2 = x2[i] === 75;
      handle2(
        key2 || x2[i] === 79 ? tuples(x2, relation.columns, i += 3, transform).row : null,
        {
          command: "delete",
          relation,
          key: key2
        }
      );
    }, "D"),
    U: /* @__PURE__ */ __name((x2) => {
      let i = 1;
      const relation = state2[x2.readUInt32BE(i)];
      i += 4;
      const key2 = x2[i] === 75;
      const xs = key2 || x2[i] === 79 ? tuples(x2, relation.columns, i += 3, transform) : null;
      xs && (i = xs.i);
      const { row } = tuples(x2, relation.columns, i + 3, transform);
      handle2(row, {
        command: "update",
        relation,
        key: key2,
        old: xs && xs.row
      });
    }, "U"),
    T: /* @__PURE__ */ __name(() => {
    }, "T"),
    // Truncate,
    C: /* @__PURE__ */ __name(() => {
    }, "C")
    // Commit
  }).reduce(char2, {})[x[0]](x);
}
function tuples(x, columns, xi, transform) {
  let type, column, value;
  const row = transform.raw ? new Array(columns.length) : {};
  for (let i = 0; i < columns.length; i++) {
    type = x[xi++];
    column = columns[i];
    value = type === 110 ? null : type === 117 ? void 0 : column.parser === void 0 ? x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)) : column.parser.array === true ? column.parser(x.toString("utf8", xi + 5, xi += 4 + x.readUInt32BE(xi))) : column.parser(x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)));
    transform.raw ? row[i] = transform.raw === true ? value : transform.value.from ? transform.value.from(value, column) : value : row[column.name] = transform.value.from ? transform.value.from(value, column) : value;
  }
  return { i: xi, row: transform.row.from ? transform.row.from(row) : row };
}
function parseEvent(x) {
  const xs = x.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!xs)
    throw new Error("Malformed subscribe pattern: " + x);
  const [, command, path2, key2] = xs;
  return (command || "*") + (path2 ? ":" + (path2.indexOf(".") === -1 ? "public." + path2 : path2) : "") + (key2 ? "=" + key2 : "");
}
var noop3;
var init_subscribe = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/subscribe.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop3 = /* @__PURE__ */ __name(() => {
    }, "noop");
    __name(Subscribe, "Subscribe");
    __name(Time, "Time");
    __name(parse, "parse");
    __name(tuples, "tuples");
    __name(parseEvent, "parseEvent");
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/large.js
import Stream2 from "node:stream";
function largeObject(sql2, oid, mode = 131072 | 262144) {
  return new Promise(async (resolve2, reject) => {
    await sql2.begin(async (sql3) => {
      let finish;
      !oid && ([{ oid }] = await sql3`select lo_creat(-1) as oid`);
      const [{ fd }] = await sql3`select lo_open(${oid}, ${mode}) as fd`;
      const lo = {
        writable: writable2,
        readable: readable2,
        close: /* @__PURE__ */ __name(() => sql3`select lo_close(${fd})`.then(finish), "close"),
        tell: /* @__PURE__ */ __name(() => sql3`select lo_tell64(${fd})`, "tell"),
        read: /* @__PURE__ */ __name((x) => sql3`select loread(${fd}, ${x}) as data`, "read"),
        write: /* @__PURE__ */ __name((x) => sql3`select lowrite(${fd}, ${x})`, "write"),
        truncate: /* @__PURE__ */ __name((x) => sql3`select lo_truncate64(${fd}, ${x})`, "truncate"),
        seek: /* @__PURE__ */ __name((x, whence = 0) => sql3`select lo_lseek64(${fd}, ${x}, ${whence})`, "seek"),
        size: /* @__PURE__ */ __name(() => sql3`
          select
            lo_lseek64(${fd}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `, "size")
      };
      resolve2(lo);
      return new Promise(async (r3) => finish = r3);
      async function readable2({
        highWaterMark = 2048 * 8,
        start = 0,
        end = Infinity
      } = {}) {
        let max = end - start;
        start && await lo.seek(start);
        return new Stream2.Readable({
          highWaterMark,
          async read(size2) {
            const l = size2 > max ? size2 - max : size2;
            max -= size2;
            const [{ data }] = await lo.read(l);
            this.push(data);
            if (data.length < size2)
              this.push(null);
          }
        });
      }
      __name(readable2, "readable");
      async function writable2({
        highWaterMark = 2048 * 8,
        start = 0
      } = {}) {
        start && await lo.seek(start);
        return new Stream2.Writable({
          highWaterMark,
          write(chunk, encoding, callback) {
            lo.write(chunk).then(() => callback(), callback);
          }
        });
      }
      __name(writable2, "writable");
    }).catch(reject);
  });
}
var init_large = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/large.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(largeObject, "largeObject");
  }
});

// node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/index.js
function Postgres(a, b2) {
  const options2 = parseOptions(a, b2), subscribe = options2.no_subscribe || Subscribe(Postgres, { ...options2 });
  let ending = false;
  const queries = queue_default(), connecting = queue_default(), reserved2 = queue_default(), closed = queue_default(), ended = queue_default(), open = queue_default(), busy = queue_default(), full = queue_default(), queues = { connecting, reserved: reserved2, closed, ended, open, busy, full };
  const connections = [...Array(options2.max)].map(() => connection_default(options2, queues, { onopen, onend, onclose }));
  const sql2 = Sql(handler);
  Object.assign(sql2, {
    get parameters() {
      return options2.parameters;
    },
    largeObject: largeObject.bind(null, sql2),
    subscribe,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options: options2,
    reserve,
    listen,
    begin,
    close,
    end
  });
  return sql2;
  function Sql(handler2) {
    handler2.debug = options2.debug;
    Object.entries(options2.types).reduce((acc, [name, type]) => {
      acc[name] = (x) => new Parameter(x, type.to);
      return acc;
    }, typed);
    Object.assign(sql3, {
      types: typed,
      typed,
      unsafe,
      notify,
      array: array3,
      json: json4,
      file
    });
    return sql3;
    function typed(value, type) {
      return new Parameter(value, type);
    }
    __name(typed, "typed");
    function sql3(strings, ...args) {
      const query = strings && Array.isArray(strings.raw) ? new Query(strings, args, handler2, cancel) : typeof strings === "string" && !args.length ? new Identifier(options2.transform.column.to ? options2.transform.column.to(strings) : strings) : new Builder(strings, args);
      return query;
    }
    __name(sql3, "sql");
    function unsafe(string2, args = [], options3 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options3 = args, args = []);
      const query = new Query([string2], args, handler2, cancel, {
        prepare: false,
        ...options3,
        simple: "simple" in options3 ? options3.simple : args.length === 0
      });
      return query;
    }
    __name(unsafe, "unsafe");
    function file(path2, args = [], options3 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options3 = args, args = []);
      const query = new Query([], args, (query2) => {
        fs.readFile(path2, "utf8", (err2, string2) => {
          if (err2)
            return query2.reject(err2);
          query2.strings = [string2];
          handler2(query2);
        });
      }, cancel, {
        ...options3,
        simple: "simple" in options3 ? options3.simple : args.length === 0
      });
      return query;
    }
    __name(file, "file");
  }
  __name(Sql, "Sql");
  async function listen(name, fn, onlisten) {
    const listener = { fn, onlisten };
    const sql3 = listen.sql || (listen.sql = Postgres({
      ...options2,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() {
        Object.entries(listen.channels).forEach(([name2, { listeners: listeners2 }]) => {
          delete listen.channels[name2];
          Promise.all(listeners2.map((l) => listen(name2, l.fn, l.onlisten).catch(() => {
          })));
        });
      },
      onnotify(c2, x) {
        c2 in listen.channels && listen.channels[c2].listeners.forEach((l) => l.fn(x));
      }
    }));
    const channels = listen.channels || (listen.channels = {}), exists2 = name in channels;
    if (exists2) {
      channels[name].listeners.push(listener);
      const result2 = await channels[name].result;
      listener.onlisten && listener.onlisten();
      return { state: result2.state, unlisten };
    }
    channels[name] = { result: sql3`listen ${sql3.unsafe('"' + name.replace(/"/g, '""') + '"')}`, listeners: [listener] };
    const result = await channels[name].result;
    listener.onlisten && listener.onlisten();
    return { state: result.state, unlisten };
    async function unlisten() {
      if (name in channels === false)
        return;
      channels[name].listeners = channels[name].listeners.filter((x) => x !== listener);
      if (channels[name].listeners.length)
        return;
      delete channels[name];
      return sql3`unlisten ${sql3.unsafe('"' + name.replace(/"/g, '""') + '"')}`;
    }
    __name(unlisten, "unlisten");
  }
  __name(listen, "listen");
  async function notify(channel2, payload) {
    return await sql2`select pg_notify(${channel2}, ${"" + payload})`;
  }
  __name(notify, "notify");
  async function reserve() {
    const queue = queue_default();
    const c2 = open.length ? open.shift() : await new Promise((resolve2, reject) => {
      const query = { reserve: resolve2, reject };
      queries.push(query);
      closed.length && connect(closed.shift(), query);
    });
    move(c2, reserved2);
    c2.reserved = () => queue.length ? c2.execute(queue.shift()) : move(c2, reserved2);
    c2.reserved.release = true;
    const sql3 = Sql(handler2);
    sql3.release = () => {
      c2.reserved = null;
      onopen(c2);
    };
    return sql3;
    function handler2(q) {
      c2.queue === full ? queue.push(q) : c2.execute(q) || move(c2, full);
    }
    __name(handler2, "handler");
  }
  __name(reserve, "reserve");
  async function begin(options3, fn) {
    !fn && (fn = options3, options3 = "");
    const queries2 = queue_default();
    let savepoints = 0, connection2, prepare = null;
    try {
      await sql2.unsafe("begin " + options3.replace(/[^a-z ]/ig, ""), [], { onexecute }).execute();
      return await Promise.race([
        scope(connection2, fn),
        new Promise((_, reject) => connection2.onclose = reject)
      ]);
    } catch (error3) {
      throw error3;
    }
    async function scope(c2, fn2, name) {
      const sql3 = Sql(handler2);
      sql3.savepoint = savepoint;
      sql3.prepare = (x) => prepare = x.replace(/[^a-z0-9$-_. ]/gi);
      let uncaughtError, result;
      name && await sql3`savepoint ${sql3(name)}`;
      try {
        result = await new Promise((resolve2, reject) => {
          const x = fn2(sql3);
          Promise.resolve(Array.isArray(x) ? Promise.all(x) : x).then(resolve2, reject);
        });
        if (uncaughtError)
          throw uncaughtError;
      } catch (e3) {
        await (name ? sql3`rollback to ${sql3(name)}` : sql3`rollback`);
        throw e3 instanceof PostgresError && e3.code === "25P02" && uncaughtError || e3;
      }
      if (!name) {
        prepare ? await sql3`prepare transaction '${sql3.unsafe(prepare)}'` : await sql3`commit`;
      }
      return result;
      function savepoint(name2, fn3) {
        if (name2 && Array.isArray(name2.raw))
          return savepoint((sql4) => sql4.apply(sql4, arguments));
        arguments.length === 1 && (fn3 = name2, name2 = null);
        return scope(c2, fn3, "s" + savepoints++ + (name2 ? "_" + name2 : ""));
      }
      __name(savepoint, "savepoint");
      function handler2(q) {
        q.catch((e3) => uncaughtError || (uncaughtError = e3));
        c2.queue === full ? queries2.push(q) : c2.execute(q) || move(c2, full);
      }
      __name(handler2, "handler");
    }
    __name(scope, "scope");
    function onexecute(c2) {
      connection2 = c2;
      move(c2, reserved2);
      c2.reserved = () => queries2.length ? c2.execute(queries2.shift()) : move(c2, reserved2);
    }
    __name(onexecute, "onexecute");
  }
  __name(begin, "begin");
  function move(c2, queue) {
    c2.queue.remove(c2);
    queue.push(c2);
    c2.queue = queue;
    queue === open ? c2.idleTimer.start() : c2.idleTimer.cancel();
    return c2;
  }
  __name(move, "move");
  function json4(x) {
    return new Parameter(x, 3802);
  }
  __name(json4, "json");
  function array3(x, type) {
    if (!Array.isArray(x))
      return array3(Array.from(arguments));
    return new Parameter(x, type || (x.length ? inferType(x) || 25 : 0), options2.shared.typeArrayMap);
  }
  __name(array3, "array");
  function handler(query) {
    if (ending)
      return query.reject(Errors.connection("CONNECTION_ENDED", options2, options2));
    if (open.length)
      return go(open.shift(), query);
    if (closed.length)
      return connect(closed.shift(), query);
    busy.length ? go(busy.shift(), query) : queries.push(query);
  }
  __name(handler, "handler");
  function go(c2, query) {
    return c2.execute(query) ? move(c2, busy) : move(c2, full);
  }
  __name(go, "go");
  function cancel(query) {
    return new Promise((resolve2, reject) => {
      query.state ? query.active ? connection_default(options2).cancel(query.state, resolve2, reject) : query.cancelled = { resolve: resolve2, reject } : (queries.remove(query), query.cancelled = true, query.reject(Errors.generic("57014", "canceling statement due to user request")), resolve2());
    });
  }
  __name(cancel, "cancel");
  async function end({ timeout = null } = {}) {
    if (ending)
      return ending;
    await 1;
    let timer2;
    return ending = Promise.race([
      new Promise((r3) => timeout !== null && (timer2 = setTimeout(destroy, timeout * 1e3, r3))),
      Promise.all(connections.map((c2) => c2.end()).concat(
        listen.sql ? listen.sql.end({ timeout: 0 }) : [],
        subscribe.sql ? subscribe.sql.end({ timeout: 0 }) : []
      ))
    ]).then(() => clearTimeout(timer2));
  }
  __name(end, "end");
  async function close() {
    await Promise.all(connections.map((c2) => c2.end()));
  }
  __name(close, "close");
  async function destroy(resolve2) {
    await Promise.all(connections.map((c2) => c2.terminate()));
    while (queries.length)
      queries.shift().reject(Errors.connection("CONNECTION_DESTROYED", options2));
    resolve2();
  }
  __name(destroy, "destroy");
  function connect(c2, query) {
    move(c2, connecting);
    c2.connect(query);
    return c2;
  }
  __name(connect, "connect");
  function onend(c2) {
    move(c2, ended);
  }
  __name(onend, "onend");
  function onopen(c2) {
    if (queries.length === 0)
      return move(c2, open);
    let max = Math.ceil(queries.length / (connecting.length + 1)), ready = true;
    while (ready && queries.length && max-- > 0) {
      const query = queries.shift();
      if (query.reserve)
        return query.reserve(c2);
      ready = c2.execute(query);
    }
    ready ? move(c2, busy) : move(c2, full);
  }
  __name(onopen, "onopen");
  function onclose(c2, e3) {
    move(c2, closed);
    c2.reserved = null;
    c2.onclose && (c2.onclose(e3), c2.onclose = null);
    options2.onclose && options2.onclose(c2.id);
    queries.length && connect(c2, queries.shift());
  }
  __name(onclose, "onclose");
}
function parseOptions(a, b2) {
  if (a && a.shared)
    return a;
  const env2 = process2.env, o2 = (!a || typeof a === "string" ? b2 : a) || {}, { url, multihost } = parseUrl(a), query = [...url.searchParams].reduce((a2, [b3, c2]) => (a2[b3] = c2, a2), {}), host = o2.hostname || o2.host || multihost || url.hostname || env2.PGHOST || "localhost", port = o2.port || url.port || env2.PGPORT || 5432, user = o2.user || o2.username || url.username || env2.PGUSERNAME || env2.PGUSER || osUsername();
  o2.no_prepare && (o2.prepare = false);
  query.sslmode && (query.ssl = query.sslmode, delete query.sslmode);
  "timeout" in o2 && (console.log("The timeout option is deprecated, use idle_timeout instead"), o2.idle_timeout = o2.timeout);
  query.sslrootcert === "system" && (query.ssl = "verify-full");
  const ints = ["idle_timeout", "connect_timeout", "max_lifetime", "max_pipeline", "backoff", "keep_alive"];
  const defaults = {
    max: 10,
    ssl: false,
    idle_timeout: null,
    connect_timeout: 30,
    max_lifetime,
    max_pipeline: 100,
    backoff,
    keep_alive: 60,
    prepare: true,
    debug: false,
    fetch_types: true,
    publications: "alltables",
    target_session_attrs: null
  };
  return {
    host: Array.isArray(host) ? host : host.split(",").map((x) => x.split(":")[0]),
    port: Array.isArray(port) ? port : host.split(",").map((x) => parseInt(x.split(":")[1] || port)),
    path: o2.path || host.indexOf("/") > -1 && host + "/.s.PGSQL." + port,
    database: o2.database || o2.db || (url.pathname || "").slice(1) || env2.PGDATABASE || user,
    user,
    pass: o2.pass || o2.password || url.password || env2.PGPASSWORD || "",
    ...Object.entries(defaults).reduce(
      (acc, [k, d]) => {
        const value = k in o2 ? o2[k] : k in query ? query[k] === "disable" || query[k] === "false" ? false : query[k] : env2["PG" + k.toUpperCase()] || d;
        acc[k] = typeof value === "string" && ints.includes(k) ? +value : value;
        return acc;
      },
      {}
    ),
    connection: {
      application_name: env2.PGAPPNAME || "postgres.js",
      ...o2.connection,
      ...Object.entries(query).reduce((acc, [k, v]) => (k in defaults || (acc[k] = v), acc), {})
    },
    types: o2.types || {},
    target_session_attrs: tsa(o2, url, env2),
    onnotice: o2.onnotice,
    onnotify: o2.onnotify,
    onclose: o2.onclose,
    onparameter: o2.onparameter,
    socket: o2.socket,
    transform: parseTransform(o2.transform || { undefined: void 0 }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...mergeUserTypes(o2.types)
  };
}
function tsa(o2, url, env2) {
  const x = o2.target_session_attrs || url.searchParams.get("target_session_attrs") || env2.PGTARGETSESSIONATTRS;
  if (!x || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(x))
    return x;
  throw new Error("target_session_attrs " + x + " is not supported");
}
function backoff(retries) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
}
function max_lifetime() {
  return 60 * (30 + Math.random() * 30);
}
function parseTransform(x) {
  return {
    undefined: x.undefined,
    column: {
      from: typeof x.column === "function" ? x.column : x.column && x.column.from,
      to: x.column && x.column.to
    },
    value: {
      from: typeof x.value === "function" ? x.value : x.value && x.value.from,
      to: x.value && x.value.to
    },
    row: {
      from: typeof x.row === "function" ? x.row : x.row && x.row.from,
      to: x.row && x.row.to
    }
  };
}
function parseUrl(url) {
  if (!url || typeof url !== "string")
    return { url: { searchParams: /* @__PURE__ */ new Map() } };
  let host = url;
  host = host.slice(host.indexOf("://") + 3).split(/[?/]/)[0];
  host = decodeURIComponent(host.slice(host.indexOf("@") + 1));
  const urlObj = new URL(url.replace(host, host.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
    },
    multihost: host.indexOf(",") > -1 && host
  };
}
function osUsername() {
  try {
    return os.userInfo().username;
  } catch (_) {
    return process2.env.USERNAME || process2.env.USER || process2.env.LOGNAME;
  }
}
var src_default;
var init_src = __esm({
  "node_modules/.pnpm/postgres@3.4.7/node_modules/postgres/cf/src/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_polyfills();
    init_polyfills();
    init_polyfills();
    init_types();
    init_connection();
    init_query();
    init_queue();
    init_errors();
    init_subscribe();
    init_large();
    Object.assign(Postgres, {
      PostgresError,
      toPascal,
      pascal,
      toCamel,
      camel,
      toKebab,
      kebab,
      fromPascal,
      fromCamel,
      fromKebab,
      BigInt: {
        to: 20,
        from: [20],
        parse: /* @__PURE__ */ __name((x) => BigInt(x), "parse"),
        // eslint-disable-line
        serialize: /* @__PURE__ */ __name((x) => x.toString(), "serialize")
      }
    });
    src_default = Postgres;
    __name(Postgres, "Postgres");
    __name(parseOptions, "parseOptions");
    __name(tsa, "tsa");
    __name(backoff, "backoff");
    __name(max_lifetime, "max_lifetime");
    __name(parseTransform, "parseTransform");
    __name(parseUrl, "parseUrl");
    __name(osUsername, "osUsername");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/entity.js
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
var entityKind, hasOwnEntityKind;
var init_entity = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/entity.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    entityKind = Symbol.for("drizzle:entityKind");
    hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
    __name(is, "is");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/logger.js
var ConsoleLogWriter, DefaultLogger, NoopLogger;
var init_logger = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/logger.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    ConsoleLogWriter = class {
      static {
        __name(this, "ConsoleLogWriter");
      }
      static [entityKind] = "ConsoleLogWriter";
      write(message) {
        console.log(message);
      }
    };
    DefaultLogger = class {
      static {
        __name(this, "DefaultLogger");
      }
      static [entityKind] = "DefaultLogger";
      writer;
      constructor(config2) {
        this.writer = config2?.writer ?? new ConsoleLogWriter();
      }
      logQuery(query, params) {
        const stringifiedParams = params.map((p) => {
          try {
            return JSON.stringify(p);
          } catch {
            return String(p);
          }
        });
        const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
        this.writer.write(`Query: ${query}${paramsStr}`);
      }
    };
    NoopLogger = class {
      static {
        __name(this, "NoopLogger");
      }
      static [entityKind] = "NoopLogger";
      logQuery() {
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/query-promise.js
var QueryPromise;
var init_query_promise = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/query-promise.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    QueryPromise = class {
      static {
        __name(this, "QueryPromise");
      }
      static [entityKind] = "QueryPromise";
      [Symbol.toStringTag] = "QueryPromise";
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
      then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/column.js
var Column;
var init_column = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/column.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    Column = class {
      static {
        __name(this, "Column");
      }
      constructor(table4, config2) {
        this.table = table4;
        this.config = config2;
        this.name = config2.name;
        this.keyAsName = config2.keyAsName;
        this.notNull = config2.notNull;
        this.default = config2.default;
        this.defaultFn = config2.defaultFn;
        this.onUpdateFn = config2.onUpdateFn;
        this.hasDefault = config2.hasDefault;
        this.primary = config2.primaryKey;
        this.isUnique = config2.isUnique;
        this.uniqueName = config2.uniqueName;
        this.uniqueType = config2.uniqueType;
        this.dataType = config2.dataType;
        this.columnType = config2.columnType;
        this.generated = config2.generated;
        this.generatedIdentity = config2.generatedIdentity;
      }
      static [entityKind] = "Column";
      name;
      keyAsName;
      primary;
      notNull;
      default;
      defaultFn;
      onUpdateFn;
      hasDefault;
      isUnique;
      uniqueName;
      uniqueType;
      dataType;
      columnType;
      enumValues = void 0;
      generated = void 0;
      generatedIdentity = void 0;
      config;
      mapFromDriverValue(value) {
        return value;
      }
      mapToDriverValue(value) {
        return value;
      }
      // ** @internal */
      shouldDisableInsert() {
        return this.config.generated !== void 0 && this.config.generated.type !== "byDefault";
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/column-builder.js
var ColumnBuilder;
var init_column_builder = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/column-builder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    ColumnBuilder = class {
      static {
        __name(this, "ColumnBuilder");
      }
      static [entityKind] = "ColumnBuilder";
      config;
      constructor(name, dataType, columnType) {
        this.config = {
          name,
          keyAsName: name === "",
          notNull: false,
          default: void 0,
          hasDefault: false,
          primaryKey: false,
          isUnique: false,
          uniqueName: void 0,
          uniqueType: void 0,
          dataType,
          columnType,
          generated: void 0
        };
      }
      /**
       * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
       *
       * @example
       * ```ts
       * const users = pgTable('users', {
       * 	id: integer('id').$type<UserId>().primaryKey(),
       * 	details: json('details').$type<UserDetails>().notNull(),
       * });
       * ```
       */
      $type() {
        return this;
      }
      /**
       * Adds a `not null` clause to the column definition.
       *
       * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
       */
      notNull() {
        this.config.notNull = true;
        return this;
      }
      /**
       * Adds a `default <value>` clause to the column definition.
       *
       * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
       *
       * If you need to set a dynamic default value, use {@link $defaultFn} instead.
       */
      default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Adds a dynamic default value to the column.
       * The function will be called when the row is inserted, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $defaultFn(fn) {
        this.config.defaultFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $defaultFn}.
       */
      $default = this.$defaultFn;
      /**
       * Adds a dynamic update value to the column.
       * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.
       * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $onUpdateFn(fn) {
        this.config.onUpdateFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $onUpdateFn}.
       */
      $onUpdate = this.$onUpdateFn;
      /**
       * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
       *
       * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
       */
      primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
      }
      /** @internal Sets the name of the column to the key within the table definition if a name was not given. */
      setName(name) {
        if (this.config.name !== "")
          return;
        this.config.name = name;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/table.utils.js
var TableName;
var init_table_utils = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/table.utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    TableName = Symbol.for("drizzle:Name");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/foreign-keys.js
var ForeignKeyBuilder, ForeignKey;
var init_foreign_keys = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/foreign-keys.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table_utils();
    ForeignKeyBuilder = class {
      static {
        __name(this, "ForeignKeyBuilder");
      }
      static [entityKind] = "PgForeignKeyBuilder";
      /** @internal */
      reference;
      /** @internal */
      _onUpdate = "no action";
      /** @internal */
      _onDelete = "no action";
      constructor(config2, actions3) {
        this.reference = () => {
          const { name, columns, foreignColumns } = config2();
          return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions3) {
          this._onUpdate = actions3.onUpdate;
          this._onDelete = actions3.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action === void 0 ? "no action" : action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action === void 0 ? "no action" : action;
        return this;
      }
      /** @internal */
      build(table4) {
        return new ForeignKey(table4, this);
      }
    };
    ForeignKey = class {
      static {
        __name(this, "ForeignKey");
      }
      constructor(table4, builder) {
        this.table = table4;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      static [entityKind] = "PgForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[TableName],
          ...columnNames,
          foreignColumns[0].table[TableName],
          ...foreignColumnNames
        ];
        return name ?? `${chunks.join("_")}_fk`;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}
var init_tracing_utils = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/tracing-utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(iife, "iife");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table4, columns) {
  return `${table4[TableName]}_${columns.join("_")}_unique`;
}
var UniqueConstraintBuilder, UniqueOnConstraintBuilder, UniqueConstraint;
var init_unique_constraint = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/unique-constraint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table_utils();
    __name(uniqueKeyName, "uniqueKeyName");
    UniqueConstraintBuilder = class {
      static {
        __name(this, "UniqueConstraintBuilder");
      }
      constructor(columns, name) {
        this.name = name;
        this.columns = columns;
      }
      static [entityKind] = "PgUniqueConstraintBuilder";
      /** @internal */
      columns;
      /** @internal */
      nullsNotDistinctConfig = false;
      nullsNotDistinct() {
        this.nullsNotDistinctConfig = true;
        return this;
      }
      /** @internal */
      build(table4) {
        return new UniqueConstraint(table4, this.columns, this.nullsNotDistinctConfig, this.name);
      }
    };
    UniqueOnConstraintBuilder = class {
      static {
        __name(this, "UniqueOnConstraintBuilder");
      }
      static [entityKind] = "PgUniqueOnConstraintBuilder";
      /** @internal */
      name;
      constructor(name) {
        this.name = name;
      }
      on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
      }
    };
    UniqueConstraint = class {
      static {
        __name(this, "UniqueConstraint");
      }
      constructor(table4, columns, nullsNotDistinct, name) {
        this.table = table4;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
        this.nullsNotDistinct = nullsNotDistinct;
      }
      static [entityKind] = "PgUniqueConstraint";
      columns;
      name;
      nullsNotDistinct = false;
      getName() {
        return this.name;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom; i < arrayString.length; i++) {
    const char2 = arrayString[i];
    if (char2 === "\\") {
      i++;
      continue;
    }
    if (char2 === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char2 === "," || char2 === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char2 = arrayString[i];
    if (char2 === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char2 === "\\") {
      i += 2;
      continue;
    }
    if (char2 === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char2 === "}") {
      return [result, i + 1];
    }
    if (char2 === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array3) {
  return `{${array3.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}
var init_array = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/utils/array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(parsePgArrayValue, "parsePgArrayValue");
    __name(parsePgNestedArray, "parsePgNestedArray");
    __name(parsePgArray, "parsePgArray");
    __name(makePgArray, "makePgArray");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/common.js
var PgColumnBuilder, PgColumn, ExtraConfigColumn, IndexedColumn, PgArrayBuilder, PgArray;
var init_common = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column_builder();
    init_column();
    init_entity();
    init_foreign_keys();
    init_tracing_utils();
    init_unique_constraint();
    init_array();
    PgColumnBuilder = class extends ColumnBuilder {
      static {
        __name(this, "PgColumnBuilder");
      }
      foreignKeyConfigs = [];
      static [entityKind] = "PgColumnBuilder";
      array(size2) {
        return new PgArrayBuilder(this.config.name, this, size2);
      }
      references(ref, actions3 = {}) {
        this.foreignKeyConfigs.push({ ref, actions: actions3 });
        return this;
      }
      unique(name, config2) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        this.config.uniqueType = config2?.nulls;
        return this;
      }
      generatedAlwaysAs(as) {
        this.config.generated = {
          as,
          type: "always",
          mode: "stored"
        };
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table4) {
        return this.foreignKeyConfigs.map(({ ref, actions: actions3 }) => {
          return iife(
            (ref2, actions22) => {
              const builder = new ForeignKeyBuilder(() => {
                const foreignColumn = ref2();
                return { columns: [column], foreignColumns: [foreignColumn] };
              });
              if (actions22.onUpdate) {
                builder.onUpdate(actions22.onUpdate);
              }
              if (actions22.onDelete) {
                builder.onDelete(actions22.onDelete);
              }
              return builder.build(table4);
            },
            ref,
            actions3
          );
        });
      }
      /** @internal */
      buildExtraConfigColumn(table4) {
        return new ExtraConfigColumn(table4, this.config);
      }
    };
    PgColumn = class extends Column {
      static {
        __name(this, "PgColumn");
      }
      constructor(table4, config2) {
        if (!config2.uniqueName) {
          config2.uniqueName = uniqueKeyName(table4, [config2.name]);
        }
        super(table4, config2);
        this.table = table4;
      }
      static [entityKind] = "PgColumn";
    };
    ExtraConfigColumn = class extends PgColumn {
      static {
        __name(this, "ExtraConfigColumn");
      }
      static [entityKind] = "ExtraConfigColumn";
      getSQLType() {
        return this.getSQLType();
      }
      indexConfig = {
        order: this.config.order ?? "asc",
        nulls: this.config.nulls ?? "last",
        opClass: this.config.opClass
      };
      defaultConfig = {
        order: "asc",
        nulls: "last",
        opClass: void 0
      };
      asc() {
        this.indexConfig.order = "asc";
        return this;
      }
      desc() {
        this.indexConfig.order = "desc";
        return this;
      }
      nullsFirst() {
        this.indexConfig.nulls = "first";
        return this;
      }
      nullsLast() {
        this.indexConfig.nulls = "last";
        return this;
      }
      /**
       * ### PostgreSQL documentation quote
       *
       * > An operator class with optional parameters can be specified for each column of an index.
       * The operator class identifies the operators to be used by the index for that column.
       * For example, a B-tree index on four-byte integers would use the int4_ops class;
       * this operator class includes comparison functions for four-byte integers.
       * In practice the default operator class for the column's data type is usually sufficient.
       * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.
       * For example, we might want to sort a complex-number data type either by absolute value or by real part.
       * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.
       * More information about operator classes check:
       *
       * ### Useful links
       * https://www.postgresql.org/docs/current/sql-createindex.html
       *
       * https://www.postgresql.org/docs/current/indexes-opclass.html
       *
       * https://www.postgresql.org/docs/current/xindex.html
       *
       * ### Additional types
       * If you have the `pg_vector` extension installed in your database, you can use the
       * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.
       *
       * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**
       *
       * @param opClass
       * @returns
       */
      op(opClass) {
        this.indexConfig.opClass = opClass;
        return this;
      }
    };
    IndexedColumn = class {
      static {
        __name(this, "IndexedColumn");
      }
      static [entityKind] = "IndexedColumn";
      constructor(name, keyAsName, type, indexConfig) {
        this.name = name;
        this.keyAsName = keyAsName;
        this.type = type;
        this.indexConfig = indexConfig;
      }
      name;
      keyAsName;
      type;
      indexConfig;
    };
    PgArrayBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgArrayBuilder");
      }
      static [entityKind] = "PgArrayBuilder";
      constructor(name, baseBuilder, size2) {
        super(name, "array", "PgArray");
        this.config.baseBuilder = baseBuilder;
        this.config.size = size2;
      }
      /** @internal */
      build(table4) {
        const baseColumn = this.config.baseBuilder.build(table4);
        return new PgArray(
          table4,
          this.config,
          baseColumn
        );
      }
    };
    PgArray = class _PgArray extends PgColumn {
      static {
        __name(this, "PgArray");
      }
      constructor(table4, config2, baseColumn, range) {
        super(table4, config2);
        this.baseColumn = baseColumn;
        this.range = range;
        this.size = config2.size;
      }
      size;
      static [entityKind] = "PgArray";
      getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          value = parsePgArray(value);
        }
        return value.map((v) => this.baseColumn.mapFromDriverValue(v));
      }
      mapToDriverValue(value, isNestedArray = false) {
        const a = value.map(
          (v) => v === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v)
        );
        if (isNestedArray)
          return a;
        return makePgArray(a);
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/enum.js
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
function pgEnumWithSchema(enumName, values2, schema2) {
  const enumInstance = Object.assign(
    (name) => new PgEnumColumnBuilder(name ?? "", enumInstance),
    {
      enumName,
      enumValues: values2,
      schema: schema2,
      [isPgEnumSym]: true
    }
  );
  return enumInstance;
}
var isPgEnumSym, PgEnumColumnBuilder, PgEnumColumn;
var init_enum = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/enum.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    isPgEnumSym = Symbol.for("drizzle:isPgEnum");
    __name(isPgEnum, "isPgEnum");
    PgEnumColumnBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgEnumColumnBuilder");
      }
      static [entityKind] = "PgEnumColumnBuilder";
      constructor(name, enumInstance) {
        super(name, "string", "PgEnumColumn");
        this.config.enum = enumInstance;
      }
      /** @internal */
      build(table4) {
        return new PgEnumColumn(
          table4,
          this.config
        );
      }
    };
    PgEnumColumn = class extends PgColumn {
      static {
        __name(this, "PgEnumColumn");
      }
      static [entityKind] = "PgEnumColumn";
      enum = this.config.enum;
      enumValues = this.config.enum.enumValues;
      constructor(table4, config2) {
        super(table4, config2);
        this.enum = config2.enum;
      }
      getSQLType() {
        return this.enum.enumName;
      }
    };
    __name(pgEnumWithSchema, "pgEnumWithSchema");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/subquery.js
var Subquery, WithSubquery;
var init_subquery = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/subquery.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    Subquery = class {
      static {
        __name(this, "Subquery");
      }
      static [entityKind] = "Subquery";
      constructor(sql2, selection, alias, isWith = false) {
        this._ = {
          brand: "Subquery",
          sql: sql2,
          selectedFields: selection,
          alias,
          isWith
        };
      }
      // getSQL(): SQL<unknown> {
      // 	return new SQL([this]);
      // }
    };
    WithSubquery = class extends Subquery {
      static {
        __name(this, "WithSubquery");
      }
      static [entityKind] = "WithSubquery";
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/version.js
var version2;
var init_version = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/version.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    version2 = "0.40.1";
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/tracing.js
var otel, rawTracer, tracer;
var init_tracing = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/tracing.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tracing_utils();
    init_version();
    tracer = {
      startActiveSpan(name, fn) {
        if (!otel) {
          return fn();
        }
        if (!rawTracer) {
          rawTracer = otel.trace.getTracer("drizzle-orm", version2);
        }
        return iife(
          (otel2, rawTracer2) => rawTracer2.startActiveSpan(
            name,
            (span) => {
              try {
                return fn(span);
              } catch (e3) {
                span.setStatus({
                  code: otel2.SpanStatusCode.ERROR,
                  message: e3 instanceof Error ? e3.message : "Unknown error"
                  // eslint-disable-line no-instanceof/no-instanceof
                });
                throw e3;
              } finally {
                span.end();
              }
            }
          ),
          otel,
          rawTracer
        );
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/view-common.js
var ViewBaseConfig;
var init_view_common = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/view-common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/table.js
function getTableName(table4) {
  return table4[TableName];
}
function getTableUniqueName(table4) {
  return `${table4[Schema] ?? "public"}.${table4[TableName]}`;
}
var Schema, Columns, ExtraConfigColumns, OriginalName, BaseName, IsAlias, ExtraConfigBuilder, IsDrizzleTable, Table;
var init_table = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/table.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table_utils();
    Schema = Symbol.for("drizzle:Schema");
    Columns = Symbol.for("drizzle:Columns");
    ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
    OriginalName = Symbol.for("drizzle:OriginalName");
    BaseName = Symbol.for("drizzle:BaseName");
    IsAlias = Symbol.for("drizzle:IsAlias");
    ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
    IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
    Table = class {
      static {
        __name(this, "Table");
      }
      static [entityKind] = "Table";
      /** @internal */
      static Symbol = {
        Name: TableName,
        Schema,
        OriginalName,
        Columns,
        ExtraConfigColumns,
        BaseName,
        IsAlias,
        ExtraConfigBuilder
      };
      /**
       * @internal
       * Can be changed if the table is aliased.
       */
      [TableName];
      /**
       * @internal
       * Used to store the original name of the table, before any aliasing.
       */
      [OriginalName];
      /** @internal */
      [Schema];
      /** @internal */
      [Columns];
      /** @internal */
      [ExtraConfigColumns];
      /**
       *  @internal
       * Used to store the table name before the transformation via the `tableCreator` functions.
       */
      [BaseName];
      /** @internal */
      [IsAlias] = false;
      /** @internal */
      [IsDrizzleTable] = true;
      /** @internal */
      [ExtraConfigBuilder] = void 0;
      constructor(name, schema2, baseName) {
        this[TableName] = this[OriginalName] = name;
        this[Schema] = schema2;
        this[BaseName] = baseName;
      }
    };
    __name(getTableName, "getTableName");
    __name(getTableUniqueName, "getTableUniqueName");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== void 0 && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
function fillPlaceholders(params, values2) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values2)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values2[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values2)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values2[p.value.name]);
    }
    return p;
  });
}
var FakePrimitiveParam, StringChunk, SQL, Name, noopDecoder, noopEncoder, noopMapper, Param, Placeholder, IsDrizzleView, View;
var init_sql = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/sql.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_enum();
    init_subquery();
    init_tracing();
    init_view_common();
    init_column();
    init_table();
    FakePrimitiveParam = class {
      static {
        __name(this, "FakePrimitiveParam");
      }
      static [entityKind] = "FakePrimitiveParam";
    };
    __name(isSQLWrapper, "isSQLWrapper");
    __name(mergeQueries, "mergeQueries");
    StringChunk = class {
      static {
        __name(this, "StringChunk");
      }
      static [entityKind] = "StringChunk";
      value;
      constructor(value) {
        this.value = Array.isArray(value) ? value : [value];
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    SQL = class _SQL {
      static {
        __name(this, "SQL");
      }
      constructor(queryChunks) {
        this.queryChunks = queryChunks;
      }
      static [entityKind] = "SQL";
      /** @internal */
      decoder = noopDecoder;
      shouldInlineParams = false;
      append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
      }
      toQuery(config2) {
        return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
          const query = this.buildQueryFromSourceParams(this.queryChunks, config2);
          span?.setAttributes({
            "drizzle.query.text": query.sql,
            "drizzle.query.params": JSON.stringify(query.params)
          });
          return query;
        });
      }
      buildQueryFromSourceParams(chunks, _config) {
        const config2 = Object.assign({}, _config, {
          inlineParams: _config.inlineParams || this.shouldInlineParams,
          paramStartIndex: _config.paramStartIndex || { value: 0 }
        });
        const {
          casing,
          escapeName,
          escapeParam,
          prepareTyping,
          inlineParams,
          paramStartIndex
        } = config2;
        return mergeQueries(chunks.map((chunk) => {
          if (is(chunk, StringChunk)) {
            return { sql: chunk.value.join(""), params: [] };
          }
          if (is(chunk, Name)) {
            return { sql: escapeName(chunk.value), params: [] };
          }
          if (chunk === void 0) {
            return { sql: "", params: [] };
          }
          if (Array.isArray(chunk)) {
            const result = [new StringChunk("(")];
            for (const [i, p] of chunk.entries()) {
              result.push(p);
              if (i < chunk.length - 1) {
                result.push(new StringChunk(", "));
              }
            }
            result.push(new StringChunk(")"));
            return this.buildQueryFromSourceParams(result, config2);
          }
          if (is(chunk, _SQL)) {
            return this.buildQueryFromSourceParams(chunk.queryChunks, {
              ...config2,
              inlineParams: inlineParams || chunk.shouldInlineParams
            });
          }
          if (is(chunk, Table)) {
            const schemaName = chunk[Table.Symbol.Schema];
            const tableName = chunk[Table.Symbol.Name];
            return {
              sql: schemaName === void 0 || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
              params: []
            };
          }
          if (is(chunk, Column)) {
            const columnName = casing.getColumnCasing(chunk);
            if (_config.invokeSource === "indexes") {
              return { sql: escapeName(columnName), params: [] };
            }
            const schemaName = chunk.table[Table.Symbol.Schema];
            return {
              sql: chunk.table[IsAlias] || schemaName === void 0 ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
              params: []
            };
          }
          if (is(chunk, View)) {
            const schemaName = chunk[ViewBaseConfig].schema;
            const viewName = chunk[ViewBaseConfig].name;
            return {
              sql: schemaName === void 0 || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
              params: []
            };
          }
          if (is(chunk, Param)) {
            if (is(chunk.value, Placeholder)) {
              return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
            }
            const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
            if (is(mappedValue, _SQL)) {
              return this.buildQueryFromSourceParams([mappedValue], config2);
            }
            if (inlineParams) {
              return { sql: this.mapInlineParam(mappedValue, config2), params: [] };
            }
            let typings = ["none"];
            if (prepareTyping) {
              typings = [prepareTyping(chunk.encoder)];
            }
            return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
          }
          if (is(chunk, Placeholder)) {
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
          }
          if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
            return { sql: escapeName(chunk.fieldAlias), params: [] };
          }
          if (is(chunk, Subquery)) {
            if (chunk._.isWith) {
              return { sql: escapeName(chunk._.alias), params: [] };
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk._.sql,
              new StringChunk(") "),
              new Name(chunk._.alias)
            ], config2);
          }
          if (isPgEnum(chunk)) {
            if (chunk.schema) {
              return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
            }
            return { sql: escapeName(chunk.enumName), params: [] };
          }
          if (isSQLWrapper(chunk)) {
            if (chunk.shouldOmitSQLParens?.()) {
              return this.buildQueryFromSourceParams([chunk.getSQL()], config2);
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk.getSQL(),
              new StringChunk(")")
            ], config2);
          }
          if (inlineParams) {
            return { sql: this.mapInlineParam(chunk, config2), params: [] };
          }
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }));
      }
      mapInlineParam(chunk, { escapeString }) {
        if (chunk === null) {
          return "null";
        }
        if (typeof chunk === "number" || typeof chunk === "boolean") {
          return chunk.toString();
        }
        if (typeof chunk === "string") {
          return escapeString(chunk);
        }
        if (typeof chunk === "object") {
          const mappedValueAsString = chunk.toString();
          if (mappedValueAsString === "[object Object]") {
            return escapeString(JSON.stringify(chunk));
          }
          return escapeString(mappedValueAsString);
        }
        throw new Error("Unexpected param value: " + chunk);
      }
      getSQL() {
        return this;
      }
      as(alias) {
        if (alias === void 0) {
          return this;
        }
        return new _SQL.Aliased(this, alias);
      }
      mapWith(decoder) {
        this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
        return this;
      }
      inlineParams() {
        this.shouldInlineParams = true;
        return this;
      }
      /**
       * This method is used to conditionally include a part of the query.
       *
       * @param condition - Condition to check
       * @returns itself if the condition is `true`, otherwise `undefined`
       */
      if(condition) {
        return condition ? this : void 0;
      }
    };
    Name = class {
      static {
        __name(this, "Name");
      }
      constructor(value) {
        this.value = value;
      }
      static [entityKind] = "Name";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(isDriverValueEncoder, "isDriverValueEncoder");
    noopDecoder = {
      mapFromDriverValue: /* @__PURE__ */ __name((value) => value, "mapFromDriverValue")
    };
    noopEncoder = {
      mapToDriverValue: /* @__PURE__ */ __name((value) => value, "mapToDriverValue")
    };
    noopMapper = {
      ...noopDecoder,
      ...noopEncoder
    };
    Param = class {
      static {
        __name(this, "Param");
      }
      /**
       * @param value - Parameter value
       * @param encoder - Encoder to convert the value to a driver parameter
       */
      constructor(value, encoder4 = noopEncoder) {
        this.value = value;
        this.encoder = encoder4;
      }
      static [entityKind] = "Param";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(sql, "sql");
    ((sql2) => {
      function empty() {
        return new SQL([]);
      }
      __name(empty, "empty");
      sql2.empty = empty;
      function fromList(list) {
        return new SQL(list);
      }
      __name(fromList, "fromList");
      sql2.fromList = fromList;
      function raw(str) {
        return new SQL([new StringChunk(str)]);
      }
      __name(raw, "raw");
      sql2.raw = raw;
      function join(chunks, separator) {
        const result = [];
        for (const [i, chunk] of chunks.entries()) {
          if (i > 0 && separator !== void 0) {
            result.push(separator);
          }
          result.push(chunk);
        }
        return new SQL(result);
      }
      __name(join, "join");
      sql2.join = join;
      function identifier(value) {
        return new Name(value);
      }
      __name(identifier, "identifier");
      sql2.identifier = identifier;
      function placeholder2(name2) {
        return new Placeholder(name2);
      }
      __name(placeholder2, "placeholder2");
      sql2.placeholder = placeholder2;
      function param2(value, encoder4) {
        return new Param(value, encoder4);
      }
      __name(param2, "param2");
      sql2.param = param2;
    })(sql || (sql = {}));
    ((SQL2) => {
      class Aliased {
        static {
          __name(this, "Aliased");
        }
        constructor(sql2, fieldAlias) {
          this.sql = sql2;
          this.fieldAlias = fieldAlias;
        }
        static [entityKind] = "SQL.Aliased";
        /** @internal */
        isSelectionField = false;
        getSQL() {
          return this.sql;
        }
        /** @internal */
        clone() {
          return new Aliased(this.sql, this.fieldAlias);
        }
      }
      SQL2.Aliased = Aliased;
    })(SQL || (SQL = {}));
    Placeholder = class {
      static {
        __name(this, "Placeholder");
      }
      constructor(name2) {
        this.name = name2;
      }
      static [entityKind] = "Placeholder";
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(fillPlaceholders, "fillPlaceholders");
    IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");
    View = class {
      static {
        __name(this, "View");
      }
      static [entityKind] = "View";
      /** @internal */
      [ViewBaseConfig];
      /** @internal */
      [IsDrizzleView] = true;
      constructor({ name: name2, schema: schema2, selectedFields, query }) {
        this[ViewBaseConfig] = {
          name: name2,
          originalName: name2,
          schema: schema2,
          selectedFields,
          query,
          isExisting: !query,
          isAlias: false
        };
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    Column.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Table.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Subquery.prototype.getSQL = function() {
      return new SQL([this]);
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/alias.js
function aliasedTable(table4, tableAlias) {
  return new Proxy(table4, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c2) => {
    if (is(c2, Column)) {
      return aliasedTableColumn(c2, alias);
    }
    if (is(c2, SQL)) {
      return mapColumnsInSQLToAlias(c2, alias);
    }
    if (is(c2, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c2, alias);
    }
    return c2;
  }));
}
var ColumnAliasProxyHandler, TableAliasProxyHandler, RelationTableAliasProxyHandler;
var init_alias = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/alias.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column();
    init_entity();
    init_sql();
    init_table();
    init_view_common();
    ColumnAliasProxyHandler = class {
      static {
        __name(this, "ColumnAliasProxyHandler");
      }
      constructor(table4) {
        this.table = table4;
      }
      static [entityKind] = "ColumnAliasProxyHandler";
      get(columnObj, prop) {
        if (prop === "table") {
          return this.table;
        }
        return columnObj[prop];
      }
    };
    TableAliasProxyHandler = class {
      static {
        __name(this, "TableAliasProxyHandler");
      }
      constructor(alias, replaceOriginalName) {
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
      }
      static [entityKind] = "TableAliasProxyHandler";
      get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
          return true;
        }
        if (prop === Table.Symbol.Name) {
          return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
          return this.alias;
        }
        if (prop === ViewBaseConfig) {
          return {
            ...target[ViewBaseConfig],
            name: this.alias,
            isAlias: true
          };
        }
        if (prop === Table.Symbol.Columns) {
          const columns = target[Table.Symbol.Columns];
          if (!columns) {
            return columns;
          }
          const proxiedColumns = {};
          Object.keys(columns).map((key2) => {
            proxiedColumns[key2] = new Proxy(
              columns[key2],
              new ColumnAliasProxyHandler(new Proxy(target, this))
            );
          });
          return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
          return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
      }
    };
    RelationTableAliasProxyHandler = class {
      static {
        __name(this, "RelationTableAliasProxyHandler");
      }
      constructor(alias) {
        this.alias = alias;
      }
      static [entityKind] = "RelationTableAliasProxyHandler";
      get(target, prop) {
        if (prop === "sourceTable") {
          return aliasedTable(target.sourceTable, this.alias);
        }
        return target[prop];
      }
    };
    __name(aliasedTable, "aliasedTable");
    __name(aliasedTableColumn, "aliasedTableColumn");
    __name(mapColumnsInAliasedSQLToAlias, "mapColumnsInAliasedSQLToAlias");
    __name(mapColumnsInSQLToAlias, "mapColumnsInSQLToAlias");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/selection-proxy.js
var SelectionProxyHandler;
var init_selection_proxy = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/selection-proxy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias();
    init_column();
    init_entity();
    init_sql();
    init_subquery();
    init_view_common();
    SelectionProxyHandler = class _SelectionProxyHandler {
      static {
        __name(this, "SelectionProxyHandler");
      }
      static [entityKind] = "SelectionProxyHandler";
      config;
      constructor(config2) {
        this.config = { ...config2 };
      }
      get(subquery, prop) {
        if (prop === "_") {
          return {
            ...subquery["_"],
            selectedFields: new Proxy(
              subquery._.selectedFields,
              this
            )
          };
        }
        if (prop === ViewBaseConfig) {
          return {
            ...subquery[ViewBaseConfig],
            selectedFields: new Proxy(
              subquery[ViewBaseConfig].selectedFields,
              this
            )
          };
        }
        if (typeof prop === "symbol") {
          return subquery[prop];
        }
        const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
          if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
            return value.sql;
          }
          const newValue = value.clone();
          newValue.isSelectionField = true;
          return newValue;
        }
        if (is(value, SQL)) {
          if (this.config.sqlBehavior === "sql") {
            return value;
          }
          throw new Error(
            `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
          );
        }
        if (is(value, Column)) {
          if (this.config.alias) {
            return new Proxy(
              value,
              new ColumnAliasProxyHandler(
                new Proxy(
                  value.table,
                  new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
                )
              )
            );
          }
          return value;
        }
        if (typeof value !== "object" || value === null) {
          return value;
        }
        return new Proxy(value, new _SelectionProxyHandler(this.config));
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path: path2, field }, columnIndex) => {
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path2.entries()) {
        if (pathChunkIndex < path2.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path2.length === 2) {
            const objectName = path2[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index10, key2] of leftKeys.entries()) {
    if (key2 !== rightKeys[index10]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table4, values2) {
  const entries = Object.entries(values2).filter(([, value]) => value !== void 0).map(([key2, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key2, value];
    } else {
      return [key2, new Param(value, table4[Table.Symbol.Columns][key2])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
function getTableColumns(table4) {
  return table4[Table.Symbol.Columns];
}
function getTableLikeName(table4) {
  return is(table4, Subquery) ? table4._.alias : is(table4, View) ? table4[ViewBaseConfig].name : is(table4, SQL) ? void 0 : table4[Table.Symbol.IsAlias] ? table4[Table.Symbol.Name] : table4[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b2) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b2
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["logger"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["logger"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== void 0)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}
var init_utils2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column();
    init_entity();
    init_sql();
    init_subquery();
    init_table();
    init_view_common();
    __name(mapResultRow, "mapResultRow");
    __name(orderSelectedFields, "orderSelectedFields");
    __name(haveSameKeys, "haveSameKeys");
    __name(mapUpdateSet, "mapUpdateSet");
    __name(applyMixins, "applyMixins");
    __name(getTableColumns, "getTableColumns");
    __name(getTableLikeName, "getTableLikeName");
    __name(getColumnNameAndConfig, "getColumnNameAndConfig");
    __name(isConfig, "isConfig");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/delete.js
var PgDeleteBase;
var init_delete = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/delete.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_selection_proxy();
    init_table();
    init_tracing();
    init_utils2();
    PgDeleteBase = class extends QueryPromise {
      static {
        __name(this, "PgDeleteBase");
      }
      constructor(table4, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table4, withList };
      }
      static [entityKind] = "PgDelete";
      config;
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will delete only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be deleted.
       *
       * ```ts
       * // Delete all cars with green color
       * await db.delete(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.delete(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Delete all BMW cars with a green color
       * await db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Delete all cars with the green or blue color
       * await db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returningFields = fields;
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(name) {
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
        });
      }
      prepare(name) {
        return this._prepare(name);
      }
      authToken;
      /** @internal */
      setToken(token) {
        this.authToken = token;
        return this;
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute(placeholderValues, this.authToken);
        });
      }, "execute");
      /** @internal */
      getSelectedFields() {
        return this.config.returningFields ? new Proxy(
          this.config.returningFields,
          new SelectionProxyHandler({
            alias: getTableName(this.config.table),
            sqlAliasedBehavior: "alias",
            sqlBehavior: "error"
          })
        ) : void 0;
      }
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}
var CasingCache;
var init_casing = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/casing.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table();
    __name(toSnakeCase, "toSnakeCase");
    __name(toCamelCase, "toCamelCase");
    __name(noopCase, "noopCase");
    CasingCache = class {
      static {
        __name(this, "CasingCache");
      }
      static [entityKind] = "CasingCache";
      /** @internal */
      cache = {};
      cachedTables = {};
      convert;
      constructor(casing) {
        this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
      }
      getColumnCasing(column) {
        if (!column.keyAsName)
          return column.name;
        const schema2 = column.table[Table.Symbol.Schema] ?? "public";
        const tableName = column.table[Table.Symbol.OriginalName];
        const key2 = `${schema2}.${tableName}.${column.name}`;
        if (!this.cache[key2]) {
          this.cacheTable(column.table);
        }
        return this.cache[key2];
      }
      cacheTable(table4) {
        const schema2 = table4[Table.Symbol.Schema] ?? "public";
        const tableName = table4[Table.Symbol.OriginalName];
        const tableKey = `${schema2}.${tableName}`;
        if (!this.cachedTables[tableKey]) {
          for (const column of Object.values(table4[Table.Symbol.Columns])) {
            const columnKey = `${tableKey}.${column.name}`;
            this.cache[columnKey] = this.convert(column.name);
          }
          this.cachedTables[tableKey] = true;
        }
      }
      clearCache() {
        this.cache = {};
        this.cachedTables = {};
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/errors.js
var DrizzleError, TransactionRollbackError;
var init_errors2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    DrizzleError = class extends Error {
      static {
        __name(this, "DrizzleError");
      }
      static [entityKind] = "DrizzleError";
      constructor({ message, cause }) {
        super(message);
        this.name = "DrizzleError";
        this.cause = cause;
      }
    };
    TransactionRollbackError = class extends DrizzleError {
      static {
        __name(this, "TransactionRollbackError");
      }
      static [entityKind] = "TransactionRollbackError";
      constructor() {
        super({ message: "Rollback" });
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/int.common.js
var PgIntColumnBaseBuilder;
var init_int_common = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/int.common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgIntColumnBaseBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgIntColumnBaseBuilder");
      }
      static [entityKind] = "PgIntColumnBaseBuilder";
      generatedAlwaysAsIdentity(sequence) {
        if (sequence) {
          const { name, ...options2 } = sequence;
          this.config.generatedIdentity = {
            type: "always",
            sequenceName: name,
            sequenceOptions: options2
          };
        } else {
          this.config.generatedIdentity = {
            type: "always"
          };
        }
        this.config.hasDefault = true;
        this.config.notNull = true;
        return this;
      }
      generatedByDefaultAsIdentity(sequence) {
        if (sequence) {
          const { name, ...options2 } = sequence;
          this.config.generatedIdentity = {
            type: "byDefault",
            sequenceName: name,
            sequenceOptions: options2
          };
        } else {
          this.config.generatedIdentity = {
            type: "byDefault"
          };
        }
        this.config.hasDefault = true;
        this.config.notNull = true;
        return this;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/bigint.js
function bigint2(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  if (config2.mode === "number") {
    return new PgBigInt53Builder(name);
  }
  return new PgBigInt64Builder(name);
}
var PgBigInt53Builder, PgBigInt53, PgBigInt64Builder, PgBigInt64;
var init_bigint = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/bigint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    init_int_common();
    PgBigInt53Builder = class extends PgIntColumnBaseBuilder {
      static {
        __name(this, "PgBigInt53Builder");
      }
      static [entityKind] = "PgBigInt53Builder";
      constructor(name) {
        super(name, "number", "PgBigInt53");
      }
      /** @internal */
      build(table4) {
        return new PgBigInt53(table4, this.config);
      }
    };
    PgBigInt53 = class extends PgColumn {
      static {
        __name(this, "PgBigInt53");
      }
      static [entityKind] = "PgBigInt53";
      getSQLType() {
        return "bigint";
      }
      mapFromDriverValue(value) {
        if (typeof value === "number") {
          return value;
        }
        return Number(value);
      }
    };
    PgBigInt64Builder = class extends PgIntColumnBaseBuilder {
      static {
        __name(this, "PgBigInt64Builder");
      }
      static [entityKind] = "PgBigInt64Builder";
      constructor(name) {
        super(name, "bigint", "PgBigInt64");
      }
      /** @internal */
      build(table4) {
        return new PgBigInt64(
          table4,
          this.config
        );
      }
    };
    PgBigInt64 = class extends PgColumn {
      static {
        __name(this, "PgBigInt64");
      }
      static [entityKind] = "PgBigInt64";
      getSQLType() {
        return "bigint";
      }
      // eslint-disable-next-line unicorn/prefer-native-coercion-functions
      mapFromDriverValue(value) {
        return BigInt(value);
      }
    };
    __name(bigint2, "bigint");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/bigserial.js
function bigserial(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  if (config2.mode === "number") {
    return new PgBigSerial53Builder(name);
  }
  return new PgBigSerial64Builder(name);
}
var PgBigSerial53Builder, PgBigSerial53, PgBigSerial64Builder, PgBigSerial64;
var init_bigserial = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/bigserial.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgBigSerial53Builder = class extends PgColumnBuilder {
      static {
        __name(this, "PgBigSerial53Builder");
      }
      static [entityKind] = "PgBigSerial53Builder";
      constructor(name) {
        super(name, "number", "PgBigSerial53");
        this.config.hasDefault = true;
        this.config.notNull = true;
      }
      /** @internal */
      build(table4) {
        return new PgBigSerial53(
          table4,
          this.config
        );
      }
    };
    PgBigSerial53 = class extends PgColumn {
      static {
        __name(this, "PgBigSerial53");
      }
      static [entityKind] = "PgBigSerial53";
      getSQLType() {
        return "bigserial";
      }
      mapFromDriverValue(value) {
        if (typeof value === "number") {
          return value;
        }
        return Number(value);
      }
    };
    PgBigSerial64Builder = class extends PgColumnBuilder {
      static {
        __name(this, "PgBigSerial64Builder");
      }
      static [entityKind] = "PgBigSerial64Builder";
      constructor(name) {
        super(name, "bigint", "PgBigSerial64");
        this.config.hasDefault = true;
      }
      /** @internal */
      build(table4) {
        return new PgBigSerial64(
          table4,
          this.config
        );
      }
    };
    PgBigSerial64 = class extends PgColumn {
      static {
        __name(this, "PgBigSerial64");
      }
      static [entityKind] = "PgBigSerial64";
      getSQLType() {
        return "bigserial";
      }
      // eslint-disable-next-line unicorn/prefer-native-coercion-functions
      mapFromDriverValue(value) {
        return BigInt(value);
      }
    };
    __name(bigserial, "bigserial");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/boolean.js
function boolean(name) {
  return new PgBooleanBuilder(name ?? "");
}
var PgBooleanBuilder, PgBoolean;
var init_boolean = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/boolean.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgBooleanBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgBooleanBuilder");
      }
      static [entityKind] = "PgBooleanBuilder";
      constructor(name) {
        super(name, "boolean", "PgBoolean");
      }
      /** @internal */
      build(table4) {
        return new PgBoolean(table4, this.config);
      }
    };
    PgBoolean = class extends PgColumn {
      static {
        __name(this, "PgBoolean");
      }
      static [entityKind] = "PgBoolean";
      getSQLType() {
        return "boolean";
      }
    };
    __name(boolean, "boolean");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/char.js
function char(a, b2 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgCharBuilder(name, config2);
}
var PgCharBuilder, PgChar;
var init_char = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/char.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgCharBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgCharBuilder");
      }
      static [entityKind] = "PgCharBuilder";
      constructor(name, config2) {
        super(name, "string", "PgChar");
        this.config.length = config2.length;
        this.config.enumValues = config2.enum;
      }
      /** @internal */
      build(table4) {
        return new PgChar(
          table4,
          this.config
        );
      }
    };
    PgChar = class extends PgColumn {
      static {
        __name(this, "PgChar");
      }
      static [entityKind] = "PgChar";
      length = this.config.length;
      enumValues = this.config.enumValues;
      getSQLType() {
        return this.length === void 0 ? `char` : `char(${this.length})`;
      }
    };
    __name(char, "char");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/cidr.js
function cidr(name) {
  return new PgCidrBuilder(name ?? "");
}
var PgCidrBuilder, PgCidr;
var init_cidr = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/cidr.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgCidrBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgCidrBuilder");
      }
      static [entityKind] = "PgCidrBuilder";
      constructor(name) {
        super(name, "string", "PgCidr");
      }
      /** @internal */
      build(table4) {
        return new PgCidr(table4, this.config);
      }
    };
    PgCidr = class extends PgColumn {
      static {
        __name(this, "PgCidr");
      }
      static [entityKind] = "PgCidr";
      getSQLType() {
        return "cidr";
      }
    };
    __name(cidr, "cidr");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/custom.js
function customType(customTypeParams) {
  return (a, b2) => {
    const { name, config: config2 } = getColumnNameAndConfig(a, b2);
    return new PgCustomColumnBuilder(name, config2, customTypeParams);
  };
}
var PgCustomColumnBuilder, PgCustomColumn;
var init_custom = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/custom.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgCustomColumnBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgCustomColumnBuilder");
      }
      static [entityKind] = "PgCustomColumnBuilder";
      constructor(name, fieldConfig, customTypeParams) {
        super(name, "custom", "PgCustomColumn");
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
      }
      /** @internal */
      build(table4) {
        return new PgCustomColumn(
          table4,
          this.config
        );
      }
    };
    PgCustomColumn = class extends PgColumn {
      static {
        __name(this, "PgCustomColumn");
      }
      static [entityKind] = "PgCustomColumn";
      sqlName;
      mapTo;
      mapFrom;
      constructor(table4, config2) {
        super(table4, config2);
        this.sqlName = config2.customTypeParams.dataType(config2.fieldConfig);
        this.mapTo = config2.customTypeParams.toDriver;
        this.mapFrom = config2.customTypeParams.fromDriver;
      }
      getSQLType() {
        return this.sqlName;
      }
      mapFromDriverValue(value) {
        return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
      }
      mapToDriverValue(value) {
        return typeof this.mapTo === "function" ? this.mapTo(value) : value;
      }
    };
    __name(customType, "customType");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/date.common.js
var PgDateColumnBaseBuilder;
var init_date_common = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/date.common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    init_common();
    PgDateColumnBaseBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgDateColumnBaseBuilder");
      }
      static [entityKind] = "PgDateColumnBaseBuilder";
      defaultNow() {
        return this.default(sql`now()`);
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/date.js
function date(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  if (config2?.mode === "date") {
    return new PgDateBuilder(name);
  }
  return new PgDateStringBuilder(name);
}
var PgDateBuilder, PgDate, PgDateStringBuilder, PgDateString;
var init_date = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/date.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    init_date_common();
    PgDateBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgDateBuilder");
      }
      static [entityKind] = "PgDateBuilder";
      constructor(name) {
        super(name, "date", "PgDate");
      }
      /** @internal */
      build(table4) {
        return new PgDate(table4, this.config);
      }
    };
    PgDate = class extends PgColumn {
      static {
        __name(this, "PgDate");
      }
      static [entityKind] = "PgDate";
      getSQLType() {
        return "date";
      }
      mapFromDriverValue(value) {
        return new Date(value);
      }
      mapToDriverValue(value) {
        return value.toISOString();
      }
    };
    PgDateStringBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgDateStringBuilder");
      }
      static [entityKind] = "PgDateStringBuilder";
      constructor(name) {
        super(name, "string", "PgDateString");
      }
      /** @internal */
      build(table4) {
        return new PgDateString(
          table4,
          this.config
        );
      }
    };
    PgDateString = class extends PgColumn {
      static {
        __name(this, "PgDateString");
      }
      static [entityKind] = "PgDateString";
      getSQLType() {
        return "date";
      }
    };
    __name(date, "date");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/double-precision.js
function doublePrecision(name) {
  return new PgDoublePrecisionBuilder(name ?? "");
}
var PgDoublePrecisionBuilder, PgDoublePrecision;
var init_double_precision = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/double-precision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgDoublePrecisionBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgDoublePrecisionBuilder");
      }
      static [entityKind] = "PgDoublePrecisionBuilder";
      constructor(name) {
        super(name, "number", "PgDoublePrecision");
      }
      /** @internal */
      build(table4) {
        return new PgDoublePrecision(
          table4,
          this.config
        );
      }
    };
    PgDoublePrecision = class extends PgColumn {
      static {
        __name(this, "PgDoublePrecision");
      }
      static [entityKind] = "PgDoublePrecision";
      getSQLType() {
        return "double precision";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number.parseFloat(value);
        }
        return value;
      }
    };
    __name(doublePrecision, "doublePrecision");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/inet.js
function inet(name) {
  return new PgInetBuilder(name ?? "");
}
var PgInetBuilder, PgInet;
var init_inet = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/inet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgInetBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgInetBuilder");
      }
      static [entityKind] = "PgInetBuilder";
      constructor(name) {
        super(name, "string", "PgInet");
      }
      /** @internal */
      build(table4) {
        return new PgInet(table4, this.config);
      }
    };
    PgInet = class extends PgColumn {
      static {
        __name(this, "PgInet");
      }
      static [entityKind] = "PgInet";
      getSQLType() {
        return "inet";
      }
    };
    __name(inet, "inet");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/integer.js
function integer(name) {
  return new PgIntegerBuilder(name ?? "");
}
var PgIntegerBuilder, PgInteger;
var init_integer = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/integer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    init_int_common();
    PgIntegerBuilder = class extends PgIntColumnBaseBuilder {
      static {
        __name(this, "PgIntegerBuilder");
      }
      static [entityKind] = "PgIntegerBuilder";
      constructor(name) {
        super(name, "number", "PgInteger");
      }
      /** @internal */
      build(table4) {
        return new PgInteger(table4, this.config);
      }
    };
    PgInteger = class extends PgColumn {
      static {
        __name(this, "PgInteger");
      }
      static [entityKind] = "PgInteger";
      getSQLType() {
        return "integer";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number.parseInt(value);
        }
        return value;
      }
    };
    __name(integer, "integer");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/interval.js
function interval(a, b2 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgIntervalBuilder(name, config2);
}
var PgIntervalBuilder, PgInterval;
var init_interval = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/interval.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgIntervalBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgIntervalBuilder");
      }
      static [entityKind] = "PgIntervalBuilder";
      constructor(name, intervalConfig) {
        super(name, "string", "PgInterval");
        this.config.intervalConfig = intervalConfig;
      }
      /** @internal */
      build(table4) {
        return new PgInterval(table4, this.config);
      }
    };
    PgInterval = class extends PgColumn {
      static {
        __name(this, "PgInterval");
      }
      static [entityKind] = "PgInterval";
      fields = this.config.intervalConfig.fields;
      precision = this.config.intervalConfig.precision;
      getSQLType() {
        const fields = this.fields ? ` ${this.fields}` : "";
        const precision = this.precision ? `(${this.precision})` : "";
        return `interval${fields}${precision}`;
      }
    };
    __name(interval, "interval");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/json.js
function json(name) {
  return new PgJsonBuilder(name ?? "");
}
var PgJsonBuilder, PgJson;
var init_json = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/json.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgJsonBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgJsonBuilder");
      }
      static [entityKind] = "PgJsonBuilder";
      constructor(name) {
        super(name, "json", "PgJson");
      }
      /** @internal */
      build(table4) {
        return new PgJson(table4, this.config);
      }
    };
    PgJson = class extends PgColumn {
      static {
        __name(this, "PgJson");
      }
      static [entityKind] = "PgJson";
      constructor(table4, config2) {
        super(table4, config2);
      }
      getSQLType() {
        return "json";
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          try {
            return JSON.parse(value);
          } catch {
            return value;
          }
        }
        return value;
      }
    };
    __name(json, "json");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/jsonb.js
function jsonb(name) {
  return new PgJsonbBuilder(name ?? "");
}
var PgJsonbBuilder, PgJsonb;
var init_jsonb = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/jsonb.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgJsonbBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgJsonbBuilder");
      }
      static [entityKind] = "PgJsonbBuilder";
      constructor(name) {
        super(name, "json", "PgJsonb");
      }
      /** @internal */
      build(table4) {
        return new PgJsonb(table4, this.config);
      }
    };
    PgJsonb = class extends PgColumn {
      static {
        __name(this, "PgJsonb");
      }
      static [entityKind] = "PgJsonb";
      constructor(table4, config2) {
        super(table4, config2);
      }
      getSQLType() {
        return "jsonb";
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          try {
            return JSON.parse(value);
          } catch {
            return value;
          }
        }
        return value;
      }
    };
    __name(jsonb, "jsonb");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/line.js
function line(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  if (!config2?.mode || config2.mode === "tuple") {
    return new PgLineBuilder(name);
  }
  return new PgLineABCBuilder(name);
}
var PgLineBuilder, PgLineTuple, PgLineABCBuilder, PgLineABC;
var init_line = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/line.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgLineBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgLineBuilder");
      }
      static [entityKind] = "PgLineBuilder";
      constructor(name) {
        super(name, "array", "PgLine");
      }
      /** @internal */
      build(table4) {
        return new PgLineTuple(
          table4,
          this.config
        );
      }
    };
    PgLineTuple = class extends PgColumn {
      static {
        __name(this, "PgLineTuple");
      }
      static [entityKind] = "PgLine";
      getSQLType() {
        return "line";
      }
      mapFromDriverValue(value) {
        const [a, b2, c2] = value.slice(1, -1).split(",");
        return [Number.parseFloat(a), Number.parseFloat(b2), Number.parseFloat(c2)];
      }
      mapToDriverValue(value) {
        return `{${value[0]},${value[1]},${value[2]}}`;
      }
    };
    PgLineABCBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgLineABCBuilder");
      }
      static [entityKind] = "PgLineABCBuilder";
      constructor(name) {
        super(name, "json", "PgLineABC");
      }
      /** @internal */
      build(table4) {
        return new PgLineABC(
          table4,
          this.config
        );
      }
    };
    PgLineABC = class extends PgColumn {
      static {
        __name(this, "PgLineABC");
      }
      static [entityKind] = "PgLineABC";
      getSQLType() {
        return "line";
      }
      mapFromDriverValue(value) {
        const [a, b2, c2] = value.slice(1, -1).split(",");
        return { a: Number.parseFloat(a), b: Number.parseFloat(b2), c: Number.parseFloat(c2) };
      }
      mapToDriverValue(value) {
        return `{${value.a},${value.b},${value.c}}`;
      }
    };
    __name(line, "line");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/macaddr.js
function macaddr(name) {
  return new PgMacaddrBuilder(name ?? "");
}
var PgMacaddrBuilder, PgMacaddr;
var init_macaddr = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/macaddr.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgMacaddrBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgMacaddrBuilder");
      }
      static [entityKind] = "PgMacaddrBuilder";
      constructor(name) {
        super(name, "string", "PgMacaddr");
      }
      /** @internal */
      build(table4) {
        return new PgMacaddr(table4, this.config);
      }
    };
    PgMacaddr = class extends PgColumn {
      static {
        __name(this, "PgMacaddr");
      }
      static [entityKind] = "PgMacaddr";
      getSQLType() {
        return "macaddr";
      }
    };
    __name(macaddr, "macaddr");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/macaddr8.js
function macaddr8(name) {
  return new PgMacaddr8Builder(name ?? "");
}
var PgMacaddr8Builder, PgMacaddr8;
var init_macaddr8 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/macaddr8.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgMacaddr8Builder = class extends PgColumnBuilder {
      static {
        __name(this, "PgMacaddr8Builder");
      }
      static [entityKind] = "PgMacaddr8Builder";
      constructor(name) {
        super(name, "string", "PgMacaddr8");
      }
      /** @internal */
      build(table4) {
        return new PgMacaddr8(table4, this.config);
      }
    };
    PgMacaddr8 = class extends PgColumn {
      static {
        __name(this, "PgMacaddr8");
      }
      static [entityKind] = "PgMacaddr8";
      getSQLType() {
        return "macaddr8";
      }
    };
    __name(macaddr8, "macaddr8");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/numeric.js
function numeric(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgNumericBuilder(name, config2?.precision, config2?.scale);
}
var PgNumericBuilder, PgNumeric;
var init_numeric = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/numeric.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgNumericBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgNumericBuilder");
      }
      static [entityKind] = "PgNumericBuilder";
      constructor(name, precision, scale) {
        super(name, "string", "PgNumeric");
        this.config.precision = precision;
        this.config.scale = scale;
      }
      /** @internal */
      build(table4) {
        return new PgNumeric(table4, this.config);
      }
    };
    PgNumeric = class extends PgColumn {
      static {
        __name(this, "PgNumeric");
      }
      static [entityKind] = "PgNumeric";
      precision;
      scale;
      constructor(table4, config2) {
        super(table4, config2);
        this.precision = config2.precision;
        this.scale = config2.scale;
      }
      getSQLType() {
        if (this.precision !== void 0 && this.scale !== void 0) {
          return `numeric(${this.precision}, ${this.scale})`;
        } else if (this.precision === void 0) {
          return "numeric";
        } else {
          return `numeric(${this.precision})`;
        }
      }
    };
    __name(numeric, "numeric");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/point.js
function point(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  if (!config2?.mode || config2.mode === "tuple") {
    return new PgPointTupleBuilder(name);
  }
  return new PgPointObjectBuilder(name);
}
var PgPointTupleBuilder, PgPointTuple, PgPointObjectBuilder, PgPointObject;
var init_point = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/point.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgPointTupleBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgPointTupleBuilder");
      }
      static [entityKind] = "PgPointTupleBuilder";
      constructor(name) {
        super(name, "array", "PgPointTuple");
      }
      /** @internal */
      build(table4) {
        return new PgPointTuple(
          table4,
          this.config
        );
      }
    };
    PgPointTuple = class extends PgColumn {
      static {
        __name(this, "PgPointTuple");
      }
      static [entityKind] = "PgPointTuple";
      getSQLType() {
        return "point";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          const [x, y] = value.slice(1, -1).split(",");
          return [Number.parseFloat(x), Number.parseFloat(y)];
        }
        return [value.x, value.y];
      }
      mapToDriverValue(value) {
        return `(${value[0]},${value[1]})`;
      }
    };
    PgPointObjectBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgPointObjectBuilder");
      }
      static [entityKind] = "PgPointObjectBuilder";
      constructor(name) {
        super(name, "json", "PgPointObject");
      }
      /** @internal */
      build(table4) {
        return new PgPointObject(
          table4,
          this.config
        );
      }
    };
    PgPointObject = class extends PgColumn {
      static {
        __name(this, "PgPointObject");
      }
      static [entityKind] = "PgPointObject";
      getSQLType() {
        return "point";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          const [x, y] = value.slice(1, -1).split(",");
          return { x: Number.parseFloat(x), y: Number.parseFloat(y) };
        }
        return value;
      }
      mapToDriverValue(value) {
        return `(${value.x},${value.y})`;
      }
    };
    __name(point, "point");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c2 = 0; c2 < hex.length; c2 += 2) {
    bytes.push(Number.parseInt(hex.slice(c2, c2 + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer2 = new ArrayBuffer(8);
  const view = new DataView(buffer2);
  for (let i = 0; i < 8; i++) {
    view.setUint8(i, bytes[offset + i]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x, y];
  }
  throw new Error("Unsupported geometry type");
}
var init_utils3 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(hexToBytes, "hexToBytes");
    __name(bytesToFloat64, "bytesToFloat64");
    __name(parseEWKB, "parseEWKB");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
function geometry(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  if (!config2?.mode || config2.mode === "tuple") {
    return new PgGeometryBuilder(name);
  }
  return new PgGeometryObjectBuilder(name);
}
var PgGeometryBuilder, PgGeometry, PgGeometryObjectBuilder, PgGeometryObject;
var init_geometry = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    init_utils3();
    PgGeometryBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgGeometryBuilder");
      }
      static [entityKind] = "PgGeometryBuilder";
      constructor(name) {
        super(name, "array", "PgGeometry");
      }
      /** @internal */
      build(table4) {
        return new PgGeometry(
          table4,
          this.config
        );
      }
    };
    PgGeometry = class extends PgColumn {
      static {
        __name(this, "PgGeometry");
      }
      static [entityKind] = "PgGeometry";
      getSQLType() {
        return "geometry(point)";
      }
      mapFromDriverValue(value) {
        return parseEWKB(value);
      }
      mapToDriverValue(value) {
        return `point(${value[0]} ${value[1]})`;
      }
    };
    PgGeometryObjectBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgGeometryObjectBuilder");
      }
      static [entityKind] = "PgGeometryObjectBuilder";
      constructor(name) {
        super(name, "json", "PgGeometryObject");
      }
      /** @internal */
      build(table4) {
        return new PgGeometryObject(
          table4,
          this.config
        );
      }
    };
    PgGeometryObject = class extends PgColumn {
      static {
        __name(this, "PgGeometryObject");
      }
      static [entityKind] = "PgGeometryObject";
      getSQLType() {
        return "geometry(point)";
      }
      mapFromDriverValue(value) {
        const parsed = parseEWKB(value);
        return { x: parsed[0], y: parsed[1] };
      }
      mapToDriverValue(value) {
        return `point(${value.x} ${value.y})`;
      }
    };
    __name(geometry, "geometry");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/real.js
function real(name) {
  return new PgRealBuilder(name ?? "");
}
var PgRealBuilder, PgReal;
var init_real = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/real.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgRealBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgRealBuilder");
      }
      static [entityKind] = "PgRealBuilder";
      constructor(name, length) {
        super(name, "number", "PgReal");
        this.config.length = length;
      }
      /** @internal */
      build(table4) {
        return new PgReal(table4, this.config);
      }
    };
    PgReal = class extends PgColumn {
      static {
        __name(this, "PgReal");
      }
      static [entityKind] = "PgReal";
      constructor(table4, config2) {
        super(table4, config2);
      }
      getSQLType() {
        return "real";
      }
      mapFromDriverValue = /* @__PURE__ */ __name((value) => {
        if (typeof value === "string") {
          return Number.parseFloat(value);
        }
        return value;
      }, "mapFromDriverValue");
    };
    __name(real, "real");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/serial.js
function serial(name) {
  return new PgSerialBuilder(name ?? "");
}
var PgSerialBuilder, PgSerial;
var init_serial = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/serial.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgSerialBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgSerialBuilder");
      }
      static [entityKind] = "PgSerialBuilder";
      constructor(name) {
        super(name, "number", "PgSerial");
        this.config.hasDefault = true;
        this.config.notNull = true;
      }
      /** @internal */
      build(table4) {
        return new PgSerial(table4, this.config);
      }
    };
    PgSerial = class extends PgColumn {
      static {
        __name(this, "PgSerial");
      }
      static [entityKind] = "PgSerial";
      getSQLType() {
        return "serial";
      }
    };
    __name(serial, "serial");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/smallint.js
function smallint(name) {
  return new PgSmallIntBuilder(name ?? "");
}
var PgSmallIntBuilder, PgSmallInt;
var init_smallint = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/smallint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    init_int_common();
    PgSmallIntBuilder = class extends PgIntColumnBaseBuilder {
      static {
        __name(this, "PgSmallIntBuilder");
      }
      static [entityKind] = "PgSmallIntBuilder";
      constructor(name) {
        super(name, "number", "PgSmallInt");
      }
      /** @internal */
      build(table4) {
        return new PgSmallInt(table4, this.config);
      }
    };
    PgSmallInt = class extends PgColumn {
      static {
        __name(this, "PgSmallInt");
      }
      static [entityKind] = "PgSmallInt";
      getSQLType() {
        return "smallint";
      }
      mapFromDriverValue = /* @__PURE__ */ __name((value) => {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }, "mapFromDriverValue");
    };
    __name(smallint, "smallint");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/smallserial.js
function smallserial(name) {
  return new PgSmallSerialBuilder(name ?? "");
}
var PgSmallSerialBuilder, PgSmallSerial;
var init_smallserial = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/smallserial.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgSmallSerialBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgSmallSerialBuilder");
      }
      static [entityKind] = "PgSmallSerialBuilder";
      constructor(name) {
        super(name, "number", "PgSmallSerial");
        this.config.hasDefault = true;
        this.config.notNull = true;
      }
      /** @internal */
      build(table4) {
        return new PgSmallSerial(
          table4,
          this.config
        );
      }
    };
    PgSmallSerial = class extends PgColumn {
      static {
        __name(this, "PgSmallSerial");
      }
      static [entityKind] = "PgSmallSerial";
      getSQLType() {
        return "smallserial";
      }
    };
    __name(smallserial, "smallserial");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/text.js
function text(a, b2 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgTextBuilder(name, config2);
}
var PgTextBuilder, PgText;
var init_text = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/text.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgTextBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgTextBuilder");
      }
      static [entityKind] = "PgTextBuilder";
      constructor(name, config2) {
        super(name, "string", "PgText");
        this.config.enumValues = config2.enum;
      }
      /** @internal */
      build(table4) {
        return new PgText(table4, this.config);
      }
    };
    PgText = class extends PgColumn {
      static {
        __name(this, "PgText");
      }
      static [entityKind] = "PgText";
      enumValues = this.config.enumValues;
      getSQLType() {
        return "text";
      }
    };
    __name(text, "text");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/time.js
function time3(a, b2 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgTimeBuilder(name, config2.withTimezone ?? false, config2.precision);
}
var PgTimeBuilder, PgTime;
var init_time = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/time.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    init_date_common();
    PgTimeBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgTimeBuilder");
      }
      constructor(name, withTimezone, precision) {
        super(name, "string", "PgTime");
        this.withTimezone = withTimezone;
        this.precision = precision;
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
      }
      static [entityKind] = "PgTimeBuilder";
      /** @internal */
      build(table4) {
        return new PgTime(table4, this.config);
      }
    };
    PgTime = class extends PgColumn {
      static {
        __name(this, "PgTime");
      }
      static [entityKind] = "PgTime";
      withTimezone;
      precision;
      constructor(table4, config2) {
        super(table4, config2);
        this.withTimezone = config2.withTimezone;
        this.precision = config2.precision;
      }
      getSQLType() {
        const precision = this.precision === void 0 ? "" : `(${this.precision})`;
        return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
      }
    };
    __name(time3, "time");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/timestamp.js
function timestamp(a, b2 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  if (config2?.mode === "string") {
    return new PgTimestampStringBuilder(name, config2.withTimezone ?? false, config2.precision);
  }
  return new PgTimestampBuilder(name, config2?.withTimezone ?? false, config2?.precision);
}
var PgTimestampBuilder, PgTimestamp, PgTimestampStringBuilder, PgTimestampString;
var init_timestamp = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/timestamp.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    init_date_common();
    PgTimestampBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgTimestampBuilder");
      }
      static [entityKind] = "PgTimestampBuilder";
      constructor(name, withTimezone, precision) {
        super(name, "date", "PgTimestamp");
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
      }
      /** @internal */
      build(table4) {
        return new PgTimestamp(table4, this.config);
      }
    };
    PgTimestamp = class extends PgColumn {
      static {
        __name(this, "PgTimestamp");
      }
      static [entityKind] = "PgTimestamp";
      withTimezone;
      precision;
      constructor(table4, config2) {
        super(table4, config2);
        this.withTimezone = config2.withTimezone;
        this.precision = config2.precision;
      }
      getSQLType() {
        const precision = this.precision === void 0 ? "" : ` (${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
      }
      mapFromDriverValue = /* @__PURE__ */ __name((value) => {
        return new Date(this.withTimezone ? value : value + "+0000");
      }, "mapFromDriverValue");
      mapToDriverValue = /* @__PURE__ */ __name((value) => {
        return value.toISOString();
      }, "mapToDriverValue");
    };
    PgTimestampStringBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgTimestampStringBuilder");
      }
      static [entityKind] = "PgTimestampStringBuilder";
      constructor(name, withTimezone, precision) {
        super(name, "string", "PgTimestampString");
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
      }
      /** @internal */
      build(table4) {
        return new PgTimestampString(
          table4,
          this.config
        );
      }
    };
    PgTimestampString = class extends PgColumn {
      static {
        __name(this, "PgTimestampString");
      }
      static [entityKind] = "PgTimestampString";
      withTimezone;
      precision;
      constructor(table4, config2) {
        super(table4, config2);
        this.withTimezone = config2.withTimezone;
        this.precision = config2.precision;
      }
      getSQLType() {
        const precision = this.precision === void 0 ? "" : `(${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
      }
    };
    __name(timestamp, "timestamp");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/uuid.js
function uuid(name) {
  return new PgUUIDBuilder(name ?? "");
}
var PgUUIDBuilder, PgUUID;
var init_uuid = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/uuid.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    init_common();
    PgUUIDBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgUUIDBuilder");
      }
      static [entityKind] = "PgUUIDBuilder";
      constructor(name) {
        super(name, "string", "PgUUID");
      }
      /**
       * Adds `default gen_random_uuid()` to the column definition.
       */
      defaultRandom() {
        return this.default(sql`gen_random_uuid()`);
      }
      /** @internal */
      build(table4) {
        return new PgUUID(table4, this.config);
      }
    };
    PgUUID = class extends PgColumn {
      static {
        __name(this, "PgUUID");
      }
      static [entityKind] = "PgUUID";
      getSQLType() {
        return "uuid";
      }
    };
    __name(uuid, "uuid");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/varchar.js
function varchar(a, b2 = {}) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgVarcharBuilder(name, config2);
}
var PgVarcharBuilder, PgVarchar;
var init_varchar = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/varchar.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgVarcharBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgVarcharBuilder");
      }
      static [entityKind] = "PgVarcharBuilder";
      constructor(name, config2) {
        super(name, "string", "PgVarchar");
        this.config.length = config2.length;
        this.config.enumValues = config2.enum;
      }
      /** @internal */
      build(table4) {
        return new PgVarchar(
          table4,
          this.config
        );
      }
    };
    PgVarchar = class extends PgColumn {
      static {
        __name(this, "PgVarchar");
      }
      static [entityKind] = "PgVarchar";
      length = this.config.length;
      enumValues = this.config.enumValues;
      getSQLType() {
        return this.length === void 0 ? `varchar` : `varchar(${this.length})`;
      }
    };
    __name(varchar, "varchar");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
function bit(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgBinaryVectorBuilder(name, config2);
}
var PgBinaryVectorBuilder, PgBinaryVector;
var init_bit = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgBinaryVectorBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgBinaryVectorBuilder");
      }
      static [entityKind] = "PgBinaryVectorBuilder";
      constructor(name, config2) {
        super(name, "string", "PgBinaryVector");
        this.config.dimensions = config2.dimensions;
      }
      /** @internal */
      build(table4) {
        return new PgBinaryVector(
          table4,
          this.config
        );
      }
    };
    PgBinaryVector = class extends PgColumn {
      static {
        __name(this, "PgBinaryVector");
      }
      static [entityKind] = "PgBinaryVector";
      dimensions = this.config.dimensions;
      getSQLType() {
        return `bit(${this.dimensions})`;
      }
    };
    __name(bit, "bit");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
function halfvec(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgHalfVectorBuilder(name, config2);
}
var PgHalfVectorBuilder, PgHalfVector;
var init_halfvec = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgHalfVectorBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgHalfVectorBuilder");
      }
      static [entityKind] = "PgHalfVectorBuilder";
      constructor(name, config2) {
        super(name, "array", "PgHalfVector");
        this.config.dimensions = config2.dimensions;
      }
      /** @internal */
      build(table4) {
        return new PgHalfVector(
          table4,
          this.config
        );
      }
    };
    PgHalfVector = class extends PgColumn {
      static {
        __name(this, "PgHalfVector");
      }
      static [entityKind] = "PgHalfVector";
      dimensions = this.config.dimensions;
      getSQLType() {
        return `halfvec(${this.dimensions})`;
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
      }
    };
    __name(halfvec, "halfvec");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
function sparsevec(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgSparseVectorBuilder(name, config2);
}
var PgSparseVectorBuilder, PgSparseVector;
var init_sparsevec = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgSparseVectorBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgSparseVectorBuilder");
      }
      static [entityKind] = "PgSparseVectorBuilder";
      constructor(name, config2) {
        super(name, "string", "PgSparseVector");
        this.config.dimensions = config2.dimensions;
      }
      /** @internal */
      build(table4) {
        return new PgSparseVector(
          table4,
          this.config
        );
      }
    };
    PgSparseVector = class extends PgColumn {
      static {
        __name(this, "PgSparseVector");
      }
      static [entityKind] = "PgSparseVector";
      dimensions = this.config.dimensions;
      getSQLType() {
        return `sparsevec(${this.dimensions})`;
      }
    };
    __name(sparsevec, "sparsevec");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
function vector(a, b2) {
  const { name, config: config2 } = getColumnNameAndConfig(a, b2);
  return new PgVectorBuilder(name, config2);
}
var PgVectorBuilder, PgVector;
var init_vector = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_utils2();
    init_common();
    PgVectorBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgVectorBuilder");
      }
      static [entityKind] = "PgVectorBuilder";
      constructor(name, config2) {
        super(name, "array", "PgVector");
        this.config.dimensions = config2.dimensions;
      }
      /** @internal */
      build(table4) {
        return new PgVector(
          table4,
          this.config
        );
      }
    };
    PgVector = class extends PgColumn {
      static {
        __name(this, "PgVector");
      }
      static [entityKind] = "PgVector";
      dimensions = this.config.dimensions;
      getSQLType() {
        return `vector(${this.dimensions})`;
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
      }
    };
    __name(vector, "vector");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/index.js
var init_columns = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_bigint();
    init_bigserial();
    init_boolean();
    init_char();
    init_cidr();
    init_common();
    init_custom();
    init_date();
    init_double_precision();
    init_enum();
    init_inet();
    init_int_common();
    init_integer();
    init_interval();
    init_json();
    init_jsonb();
    init_line();
    init_macaddr();
    init_macaddr8();
    init_numeric();
    init_point();
    init_geometry();
    init_real();
    init_serial();
    init_smallint();
    init_smallserial();
    init_text();
    init_time();
    init_timestamp();
    init_uuid();
    init_varchar();
    init_bit();
    init_halfvec();
    init_sparsevec();
    init_vector();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint: bigint2,
    bigserial,
    boolean,
    char,
    cidr,
    customType,
    date,
    doublePrecision,
    inet,
    integer,
    interval,
    json,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time: time3,
    timestamp,
    uuid,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}
var init_all = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/columns/all.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_bigint();
    init_bigserial();
    init_boolean();
    init_char();
    init_cidr();
    init_custom();
    init_date();
    init_double_precision();
    init_inet();
    init_integer();
    init_interval();
    init_json();
    init_jsonb();
    init_line();
    init_macaddr();
    init_macaddr8();
    init_numeric();
    init_point();
    init_geometry();
    init_real();
    init_serial();
    init_smallint();
    init_smallserial();
    init_text();
    init_time();
    init_timestamp();
    init_uuid();
    init_varchar();
    init_bit();
    init_halfvec();
    init_sparsevec();
    init_vector();
    __name(getPgColumnBuilders, "getPgColumnBuilders");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/table.js
function pgTableWithSchema(name, columns, extraConfig, schema2, baseName = name) {
  const rawTable = new PgTable(name, schema2, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(
    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name2);
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const builtColumnsForExtraConfig = Object.fromEntries(
    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name2);
      const column = colBuilder.buildExtraConfigColumn(rawTable);
      return [name2, column];
    })
  );
  const table4 = Object.assign(rawTable, builtColumns);
  table4[Table.Symbol.Columns] = builtColumns;
  table4[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table4[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table4, {
    enableRLS: /* @__PURE__ */ __name(() => {
      table4[PgTable.Symbol.EnableRLS] = true;
      return table4;
    }, "enableRLS")
  });
}
var InlineForeignKeys, EnableRLS, PgTable, pgTable;
var init_table2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/table.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table();
    init_all();
    InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
    EnableRLS = Symbol.for("drizzle:EnableRLS");
    PgTable = class extends Table {
      static {
        __name(this, "PgTable");
      }
      static [entityKind] = "PgTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys,
        EnableRLS
      });
      /**@internal */
      [InlineForeignKeys] = [];
      /** @internal */
      [EnableRLS] = false;
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
      /** @internal */
      [Table.Symbol.ExtraConfigColumns] = {};
    };
    __name(pgTableWithSchema, "pgTableWithSchema");
    pgTable = /* @__PURE__ */ __name((name, columns, extraConfig) => {
      return pgTableWithSchema(name, columns, extraConfig, void 0);
    }, "pgTable");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/primary-keys.js
var PrimaryKeyBuilder, PrimaryKey;
var init_primary_keys = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/primary-keys.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table2();
    PrimaryKeyBuilder = class {
      static {
        __name(this, "PrimaryKeyBuilder");
      }
      static [entityKind] = "PgPrimaryKeyBuilder";
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name) {
        this.columns = columns;
        this.name = name;
      }
      /** @internal */
      build(table4) {
        return new PrimaryKey(table4, this.columns, this.name);
      }
    };
    PrimaryKey = class {
      static {
        __name(this, "PrimaryKey");
      }
      constructor(table4, columns, name) {
        this.table = table4;
        this.columns = columns;
        this.name = name;
      }
      static [entityKind] = "PgPrimaryKey";
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
function inArray(column, values2) {
  if (Array.isArray(values2)) {
    if (values2.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values2.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values2, column)}`;
}
function notInArray(column, values2) {
  if (Array.isArray(values2)) {
    if (values2.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values2.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values2, column)}`;
}
function isNull2(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(
    max,
    column
  )}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(
    min,
    column
  )} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
var eq, ne, gt, gte, lt, lte;
var init_conditions = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/expressions/conditions.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column();
    init_entity();
    init_table();
    init_sql();
    __name(bindIfParam, "bindIfParam");
    eq = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} = ${bindIfParam(right, left)}`;
    }, "eq");
    ne = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <> ${bindIfParam(right, left)}`;
    }, "ne");
    __name(and, "and");
    __name(or, "or");
    __name(not, "not");
    gt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} > ${bindIfParam(right, left)}`;
    }, "gt");
    gte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} >= ${bindIfParam(right, left)}`;
    }, "gte");
    lt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} < ${bindIfParam(right, left)}`;
    }, "lt");
    lte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <= ${bindIfParam(right, left)}`;
    }, "lte");
    __name(inArray, "inArray");
    __name(notInArray, "notInArray");
    __name(isNull2, "isNull");
    __name(isNotNull, "isNotNull");
    __name(exists, "exists");
    __name(notExists, "notExists");
    __name(between, "between");
    __name(notBetween, "notBetween");
    __name(like, "like");
    __name(notLike, "notLike");
    __name(ilike, "ilike");
    __name(notIlike, "notIlike");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}
var init_select = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/expressions/select.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_sql();
    __name(asc, "asc");
    __name(desc, "desc");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/expressions/index.js
var init_expressions = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/expressions/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_conditions();
    init_select();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/relations.js
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull: isNull2,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema2, configHelpers) {
  if (Object.keys(schema2).length === 1 && "default" in schema2 && !is(schema2["default"], Table)) {
    schema2 = schema2["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key2, value] of Object.entries(schema2)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key2;
      tablesConfig[key2] = {
        tsName: key2,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key2].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key2].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table4, relations2) {
  return new Relations(
    table4,
    (helpers) => Object.fromEntries(
      Object.entries(relations2(helpers)).map(([key2, value]) => [
        key2,
        value.withFieldName(key2)
      ])
    )
  );
}
function createOne(sourceTable) {
  return /* @__PURE__ */ __name(function one2(table4, config2) {
    return new One(
      sourceTable,
      table4,
      config2,
      config2?.fields.reduce((res, f) => res && f.notNull, true) ?? false
    );
  }, "one");
}
function createMany(sourceTable) {
  return /* @__PURE__ */ __name(function many2(referencedTable, config2) {
    return new Many(sourceTable, referencedTable, config2);
  }, "many");
}
function normalizeRelation(schema2, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema2[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}
var Relation, Relations, One, Many;
var init_relations = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/relations.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_table();
    init_column();
    init_entity();
    init_primary_keys();
    init_expressions();
    init_sql();
    Relation = class {
      static {
        __name(this, "Relation");
      }
      constructor(sourceTable, referencedTable, relationName) {
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
      }
      static [entityKind] = "Relation";
      referencedTableName;
      fieldName;
    };
    Relations = class {
      static {
        __name(this, "Relations");
      }
      constructor(table4, config2) {
        this.table = table4;
        this.config = config2;
      }
      static [entityKind] = "Relations";
    };
    One = class _One extends Relation {
      static {
        __name(this, "One");
      }
      constructor(sourceTable, referencedTable, config2, isNullable) {
        super(sourceTable, referencedTable, config2?.relationName);
        this.config = config2;
        this.isNullable = isNullable;
      }
      static [entityKind] = "One";
      withFieldName(fieldName) {
        const relation = new _One(
          this.sourceTable,
          this.referencedTable,
          this.config,
          this.isNullable
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    Many = class _Many extends Relation {
      static {
        __name(this, "Many");
      }
      constructor(sourceTable, referencedTable, config2) {
        super(sourceTable, referencedTable, config2?.relationName);
        this.config = config2;
      }
      static [entityKind] = "Many";
      withFieldName(fieldName) {
        const relation = new _Many(
          this.sourceTable,
          this.referencedTable,
          this.config
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    __name(getOperators, "getOperators");
    __name(getOrderByOperators, "getOrderByOperators");
    __name(extractTablesRelationalConfig, "extractTablesRelationalConfig");
    __name(relations, "relations");
    __name(createOne, "createOne");
    __name(createMany, "createMany");
    __name(normalizeRelation, "normalizeRelation");
    __name(createTableRelationsHelpers, "createTableRelationsHelpers");
    __name(mapRelationalRow, "mapRelationalRow");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/functions/aggregate.js
var init_aggregate = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/functions/aggregate.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/functions/vector.js
var init_vector2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/functions/vector.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/functions/index.js
var init_functions = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/functions/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_aggregate();
    init_vector2();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/index.js
var init_sql2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/sql/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_expressions();
    init_functions();
    init_sql();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/view-base.js
var PgViewBase;
var init_view_base = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/view-base.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    PgViewBase = class extends View {
      static {
        __name(this, "PgViewBase");
      }
      static [entityKind] = "PgViewBase";
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/dialect.js
var PgDialect;
var init_dialect = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/dialect.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias();
    init_casing();
    init_column();
    init_entity();
    init_errors2();
    init_columns();
    init_table2();
    init_relations();
    init_sql2();
    init_sql();
    init_subquery();
    init_table();
    init_utils2();
    init_view_common();
    init_view_base();
    PgDialect = class {
      static {
        __name(this, "PgDialect");
      }
      static [entityKind] = "PgDialect";
      /** @internal */
      casing;
      constructor(config2) {
        this.casing = new CasingCache(config2?.casing);
      }
      async migrate(migrations, session, config2) {
        const migrationsTable = typeof config2 === "string" ? "__drizzle_migrations" : config2.migrationsTable ?? "__drizzle_migrations";
        const migrationsSchema = typeof config2 === "string" ? "drizzle" : config2.migrationsSchema ?? "drizzle";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
        await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
        await session.execute(migrationTableCreate);
        const dbMigrations = await session.all(
          sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`
        );
        const lastDbMigration = dbMigrations[0];
        await session.transaction(async (tx) => {
          for await (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.execute(sql.raw(stmt));
              }
              await tx.execute(
                sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
        });
      }
      escapeName(name) {
        return `"${name}"`;
      }
      escapeParam(num) {
        return `$${num + 1}`;
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildWithCTE(queries) {
        if (!queries?.length)
          return void 0;
        const withSqlChunks = [sql`with `];
        for (const [i, w] of queries.entries()) {
          withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
          if (i < queries.length - 1) {
            withSqlChunks.push(sql`, `);
          }
        }
        withSqlChunks.push(sql` `);
        return sql.join(withSqlChunks);
      }
      buildDeleteQuery({ table: table4, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}delete from ${table4}${whereSql}${returningSql}`;
      }
      buildUpdateSet(table4, set2) {
        const tableColumns = table4[Table.Symbol.Columns];
        const columnNames = Object.keys(tableColumns).filter(
          (colName) => set2[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
        );
        const setSize = columnNames.length;
        return sql.join(columnNames.flatMap((colName, i) => {
          const col = tableColumns[colName];
          const value = set2[colName] ?? sql.param(col.onUpdateFn(), col);
          const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
          if (i < setSize - 1) {
            return [res, sql.raw(", ")];
          }
          return [res];
        }));
      }
      buildUpdateQuery({ table: table4, set: set2, where, returning, withList, from, joins }) {
        const withSql = this.buildWithCTE(withList);
        const tableName = table4[PgTable.Symbol.Name];
        const tableSchema = table4[PgTable.Symbol.Schema];
        const origTableName = table4[PgTable.Symbol.OriginalName];
        const alias = tableName === origTableName ? void 0 : tableName;
        const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;
        const setSql = this.buildUpdateSet(table4, set2);
        const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
        const joinsSql = this.buildJoins(joins);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(
                new SQL(
                  query.queryChunks.map((c2) => {
                    if (is(c2, PgColumn)) {
                      return sql.identifier(this.casing.getColumnCasing(c2));
                    }
                    return c2;
                  })
                )
              );
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            if (isSingleTable) {
              chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
            } else {
              chunk.push(field);
            }
          }
          if (i < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildJoins(joins) {
        if (!joins || joins.length === 0) {
          return void 0;
        }
        const joinsArray = [];
        for (const [index10, joinMeta] of joins.entries()) {
          if (index10 === 0) {
            joinsArray.push(sql` `);
          }
          const table4 = joinMeta.table;
          const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
          if (is(table4, PgTable)) {
            const tableName = table4[PgTable.Symbol.Name];
            const tableSchema = table4[PgTable.Symbol.Schema];
            const origTableName = table4[PgTable.Symbol.OriginalName];
            const alias = tableName === origTableName ? void 0 : joinMeta.alias;
            joinsArray.push(
              sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
            );
          } else if (is(table4, View)) {
            const viewName = table4[ViewBaseConfig].name;
            const viewSchema = table4[ViewBaseConfig].schema;
            const origViewName = table4[ViewBaseConfig].originalName;
            const alias = viewName === origViewName ? void 0 : joinMeta.alias;
            joinsArray.push(
              sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
            );
          } else {
            joinsArray.push(
              sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table4} on ${joinMeta.on}`
            );
          }
          if (index10 < joins.length - 1) {
            joinsArray.push(sql` `);
          }
        }
        return sql.join(joinsArray);
      }
      buildFromTable(table4) {
        if (is(table4, Table) && table4[Table.Symbol.OriginalName] !== table4[Table.Symbol.Name]) {
          let fullName = sql`${sql.identifier(table4[Table.Symbol.OriginalName])}`;
          if (table4[Table.Symbol.Schema]) {
            fullName = sql`${sql.identifier(table4[Table.Symbol.Schema])}.${fullName}`;
          }
          return sql`${fullName} ${sql.identifier(table4[Table.Symbol.Name])}`;
        }
        return table4;
      }
      buildSelectQuery({
        withList,
        fields,
        fieldsFlat,
        where,
        having,
        table: table4,
        joins,
        orderBy,
        groupBy,
        limit,
        offset,
        lockingClause,
        distinct,
        setOperators
      }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
          if (is(f.field, Column) && getTableName(f.field.table) !== (is(table4, Subquery) ? table4._.alias : is(table4, PgViewBase) ? table4[ViewBaseConfig].name : is(table4, SQL) ? void 0 : getTableName(table4)) && !((table22) => joins?.some(
            ({ alias }) => alias === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])
          ))(f.field.table)) {
            const tableName = getTableName(f.field.table);
            throw new Error(
              `Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
            );
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        const withSql = this.buildWithCTE(withList);
        let distinctSql;
        if (distinct) {
          distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
        }
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = this.buildFromTable(table4);
        const joinsSql = this.buildJoins(joins);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
        }
        let groupBySql;
        if (groupBy && groupBy.length > 0) {
          groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        const lockingClauseSql = sql.empty();
        if (lockingClause) {
          const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
          if (lockingClause.config.of) {
            clauseSql.append(
              sql` of ${sql.join(
                Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of],
                sql`, `
              )}`
            );
          }
          if (lockingClause.config.noWait) {
            clauseSql.append(sql` no wait`);
          } else if (lockingClause.config.skipLocked) {
            clauseSql.append(sql` skip locked`);
          }
          lockingClauseSql.append(clauseSql);
        }
        const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
        if (setOperators.length > 0) {
          return this.buildSetOperations(finalQuery, setOperators);
        }
        return finalQuery;
      }
      buildSetOperations(leftSelect, setOperators) {
        const [setOperator, ...rest] = setOperators;
        if (!setOperator) {
          throw new Error("Cannot pass undefined values to any set operator");
        }
        if (rest.length === 0) {
          return this.buildSetOperationQuery({ leftSelect, setOperator });
        }
        return this.buildSetOperations(
          this.buildSetOperationQuery({ leftSelect, setOperator }),
          rest
        );
      }
      buildSetOperationQuery({
        leftSelect,
        setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
      }) {
        const leftChunk = sql`(${leftSelect.getSQL()}) `;
        const rightChunk = sql`(${rightSelect.getSQL()})`;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          const orderByValues = [];
          for (const singleOrderBy of orderBy) {
            if (is(singleOrderBy, PgColumn)) {
              orderByValues.push(sql.identifier(singleOrderBy.name));
            } else if (is(singleOrderBy, SQL)) {
              for (let i = 0; i < singleOrderBy.queryChunks.length; i++) {
                const chunk = singleOrderBy.queryChunks[i];
                if (is(chunk, PgColumn)) {
                  singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);
                }
              }
              orderByValues.push(sql`${singleOrderBy}`);
            } else {
              orderByValues.push(sql`${singleOrderBy}`);
            }
          }
          orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
      }
      buildInsertQuery({ table: table4, values: valuesOrSelect, onConflict, returning, withList, select: select2, overridingSystemValue_ }) {
        const valuesSqlList = [];
        const columns = table4[Table.Symbol.Columns];
        const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
        const insertOrder = colEntries.map(
          ([, column]) => sql.identifier(this.casing.getColumnCasing(column))
        );
        if (select2) {
          const select22 = valuesOrSelect;
          if (is(select22, SQL)) {
            valuesSqlList.push(select22);
          } else {
            valuesSqlList.push(select22.getSQL());
          }
        } else {
          const values2 = valuesOrSelect;
          valuesSqlList.push(sql.raw("values "));
          for (const [valueIndex, value] of values2.entries()) {
            const valueList = [];
            for (const [fieldName, col] of colEntries) {
              const colValue = value[fieldName];
              if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
                if (col.defaultFn !== void 0) {
                  const defaultFnResult = col.defaultFn();
                  const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                  valueList.push(defaultValue);
                } else if (!col.default && col.onUpdateFn !== void 0) {
                  const onUpdateFnResult = col.onUpdateFn();
                  const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
                  valueList.push(newValue);
                } else {
                  valueList.push(sql`default`);
                }
              } else {
                valueList.push(colValue);
              }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values2.length - 1) {
              valuesSqlList.push(sql`, `);
            }
          }
        }
        const withSql = this.buildWithCTE(withList);
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
        const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : void 0;
        return sql`${withSql}insert into ${table4} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;
      }
      buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
        const concurrentlySql = concurrently ? sql` concurrently` : void 0;
        const withNoDataSql = withNoData ? sql` with no data` : void 0;
        return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
      }
      prepareTyping(encoder4) {
        if (is(encoder4, PgJsonb) || is(encoder4, PgJson)) {
          return "json";
        } else if (is(encoder4, PgNumeric)) {
          return "decimal";
        } else if (is(encoder4, PgTime)) {
          return "time";
        } else if (is(encoder4, PgTimestamp) || is(encoder4, PgTimestampString)) {
          return "timestamp";
        } else if (is(encoder4, PgDate) || is(encoder4, PgDateString)) {
          return "date";
        } else if (is(encoder4, PgUUID)) {
          return "uuid";
        } else {
          return "none";
        }
      }
      sqlToQuery(sql2, invokeSource) {
        return sql2.toQuery({
          casing: this.casing,
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString,
          prepareTyping: this.prepareTyping,
          invokeSource
        });
      }
      // buildRelationalQueryWithPK({
      // 	fullSchema,
      // 	schema,
      // 	tableNamesMap,
      // 	table,
      // 	tableConfig,
      // 	queryConfig: config,
      // 	tableAlias,
      // 	isRoot = false,
      // 	joinOn,
      // }: {
      // 	fullSchema: Record<string, unknown>;
      // 	schema: TablesRelationalConfig;
      // 	tableNamesMap: Record<string, string>;
      // 	table: PgTable;
      // 	tableConfig: TableRelationalConfig;
      // 	queryConfig: true | DBQueryConfig<'many', true>;
      // 	tableAlias: string;
      // 	isRoot?: boolean;
      // 	joinOn?: SQL;
      // }): BuildRelationalQueryResult<PgTable, PgColumn> {
      // 	// For { "<relation>": true }, return a table with selection of all columns
      // 	if (config === true) {
      // 		const selectionEntries = Object.entries(tableConfig.columns);
      // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
      // 			[key, value],
      // 		) => ({
      // 			dbKey: value.name,
      // 			tsKey: key,
      // 			field: value as PgColumn,
      // 			relationTableTsKey: undefined,
      // 			isJson: false,
      // 			selection: [],
      // 		}));
      // 		return {
      // 			tableTsKey: tableConfig.tsName,
      // 			sql: table,
      // 			selection,
      // 		};
      // 	}
      // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
      // 	// let selectionForBuild = selection;
      // 	const aliasedColumns = Object.fromEntries(
      // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
      // 	);
      // 	const aliasedRelations = Object.fromEntries(
      // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
      // 	);
      // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
      // 	let where, hasUserDefinedWhere;
      // 	if (config.where) {
      // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
      // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      // 		hasUserDefinedWhere = !!where;
      // 	}
      // 	where = and(joinOn, where);
      // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
      // 	let joins: Join[] = [];
      // 	let selectedColumns: string[] = [];
      // 	// Figure out which columns to select
      // 	if (config.columns) {
      // 		let isIncludeMode = false;
      // 		for (const [field, value] of Object.entries(config.columns)) {
      // 			if (value === undefined) {
      // 				continue;
      // 			}
      // 			if (field in tableConfig.columns) {
      // 				if (!isIncludeMode && value === true) {
      // 					isIncludeMode = true;
      // 				}
      // 				selectedColumns.push(field);
      // 			}
      // 		}
      // 		if (selectedColumns.length > 0) {
      // 			selectedColumns = isIncludeMode
      // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
      // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
      // 		}
      // 	} else {
      // 		// Select all columns if selection is not specified
      // 		selectedColumns = Object.keys(tableConfig.columns);
      // 	}
      // 	// for (const field of selectedColumns) {
      // 	// 	const column = tableConfig.columns[field]! as PgColumn;
      // 	// 	fieldsSelection.push({ tsKey: field, value: column });
      // 	// }
      // 	let initiallySelectedRelations: {
      // 		tsKey: string;
      // 		queryConfig: true | DBQueryConfig<'many', false>;
      // 		relation: Relation;
      // 	}[] = [];
      // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
      // 	// Figure out which relations to select
      // 	if (config.with) {
      // 		initiallySelectedRelations = Object.entries(config.with)
      // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
      // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
      // 	}
      // 	const manyRelations = initiallySelectedRelations.filter((r) =>
      // 		is(r.relation, Many)
      // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
      // 	);
      // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
      // 	const isInnermostQuery = manyRelations.length < 2;
      // 	const selectedExtras: {
      // 		tsKey: string;
      // 		value: SQL.Aliased;
      // 	}[] = [];
      // 	// Figure out which extras to select
      // 	if (isInnermostQuery && config.extras) {
      // 		const extras = typeof config.extras === 'function'
      // 			? config.extras(aliasedFields, { sql })
      // 			: config.extras;
      // 		for (const [tsKey, value] of Object.entries(extras)) {
      // 			selectedExtras.push({
      // 				tsKey,
      // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
      // 			});
      // 		}
      // 	}
      // 	// Transform `fieldsSelection` into `selection`
      // 	// `fieldsSelection` shouldn't be used after this point
      // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
      // 	// 	selection.push({
      // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
      // 	// 		tsKey,
      // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
      // 	// 		relationTableTsKey: undefined,
      // 	// 		isJson: false,
      // 	// 		isExtra,
      // 	// 		selection: [],
      // 	// 	});
      // 	// }
      // 	let orderByOrig = typeof config.orderBy === 'function'
      // 		? config.orderBy(aliasedFields, orderByOperators)
      // 		: config.orderBy ?? [];
      // 	if (!Array.isArray(orderByOrig)) {
      // 		orderByOrig = [orderByOrig];
      // 	}
      // 	const orderBy = orderByOrig.map((orderByValue) => {
      // 		if (is(orderByValue, Column)) {
      // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
      // 		}
      // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      // 	});
      // 	const limit = isInnermostQuery ? config.limit : undefined;
      // 	const offset = isInnermostQuery ? config.offset : undefined;
      // 	// For non-root queries without additional config except columns, return a table with selection
      // 	if (
      // 		!isRoot
      // 		&& initiallySelectedRelations.length === 0
      // 		&& selectedExtras.length === 0
      // 		&& !where
      // 		&& orderBy.length === 0
      // 		&& limit === undefined
      // 		&& offset === undefined
      // 	) {
      // 		return {
      // 			tableTsKey: tableConfig.tsName,
      // 			sql: table,
      // 			selection: selectedColumns.map((key) => ({
      // 				dbKey: tableConfig.columns[key]!.name,
      // 				tsKey: key,
      // 				field: tableConfig.columns[key] as PgColumn,
      // 				relationTableTsKey: undefined,
      // 				isJson: false,
      // 				selection: [],
      // 			})),
      // 		};
      // 	}
      // 	const selectedRelationsWithoutPK:
      // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
      // 	for (
      // 		const {
      // 			tsKey: selectedRelationTsKey,
      // 			queryConfig: selectedRelationConfigValue,
      // 			relation,
      // 		} of initiallySelectedRelations
      // 	) {
      // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
      // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
      // 		const relationTableTsName = tableNamesMap[relationTableName]!;
      // 		const relationTable = schema[relationTableTsName]!;
      // 		if (relationTable.primaryKey.length > 0) {
      // 			continue;
      // 		}
      // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
      // 		const joinOn = and(
      // 			...normalizedRelation.fields.map((field, i) =>
      // 				eq(
      // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
      // 					aliasedTableColumn(field, tableAlias),
      // 				)
      // 			),
      // 		);
      // 		const builtRelation = this.buildRelationalQueryWithoutPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table: fullSchema[relationTableTsName] as PgTable,
      // 			tableConfig: schema[relationTableTsName]!,
      // 			queryConfig: selectedRelationConfigValue,
      // 			tableAlias: relationTableAlias,
      // 			joinOn,
      // 			nestedQueryRelation: relation,
      // 		});
      // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
      // 		joins.push({
      // 			on: sql`true`,
      // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
      // 			alias: relationTableAlias,
      // 			joinType: 'left',
      // 			lateral: true,
      // 		});
      // 		selectedRelations.push({
      // 			dbKey: selectedRelationTsKey,
      // 			tsKey: selectedRelationTsKey,
      // 			field,
      // 			relationTableTsKey: relationTableTsName,
      // 			isJson: true,
      // 			selection: builtRelation.selection,
      // 		});
      // 	}
      // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
      // 		is(r.relation, One)
      // 	);
      // 	// Process all One relations with PKs, because they can all be joined on the same level
      // 	for (
      // 		const {
      // 			tsKey: selectedRelationTsKey,
      // 			queryConfig: selectedRelationConfigValue,
      // 			relation,
      // 		} of oneRelations
      // 	) {
      // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
      // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
      // 		const relationTableTsName = tableNamesMap[relationTableName]!;
      // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
      // 		const relationTable = schema[relationTableTsName]!;
      // 		if (relationTable.primaryKey.length === 0) {
      // 			continue;
      // 		}
      // 		const joinOn = and(
      // 			...normalizedRelation.fields.map((field, i) =>
      // 				eq(
      // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
      // 					aliasedTableColumn(field, tableAlias),
      // 				)
      // 			),
      // 		);
      // 		const builtRelation = this.buildRelationalQueryWithPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table: fullSchema[relationTableTsName] as PgTable,
      // 			tableConfig: schema[relationTableTsName]!,
      // 			queryConfig: selectedRelationConfigValue,
      // 			tableAlias: relationTableAlias,
      // 			joinOn,
      // 		});
      // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
      // 			sql.join(
      // 				builtRelation.selection.map(({ field }) =>
      // 					is(field, SQL.Aliased)
      // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
      // 						: is(field, Column)
      // 						? aliasedTableColumn(field, relationTableAlias)
      // 						: field
      // 				),
      // 				sql`, `,
      // 			)
      // 		}) end`.as(selectedRelationTsKey);
      // 		const isLateralJoin = is(builtRelation.sql, SQL);
      // 		joins.push({
      // 			on: isLateralJoin ? sql`true` : joinOn,
      // 			table: is(builtRelation.sql, SQL)
      // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
      // 				: aliasedTable(builtRelation.sql, relationTableAlias),
      // 			alias: relationTableAlias,
      // 			joinType: 'left',
      // 			lateral: is(builtRelation.sql, SQL),
      // 		});
      // 		selectedRelations.push({
      // 			dbKey: selectedRelationTsKey,
      // 			tsKey: selectedRelationTsKey,
      // 			field,
      // 			relationTableTsKey: relationTableTsName,
      // 			isJson: true,
      // 			selection: builtRelation.selection,
      // 		});
      // 	}
      // 	let distinct: PgSelectConfig['distinct'];
      // 	let tableFrom: PgTable | Subquery = table;
      // 	// Process first Many relation - each one requires a nested subquery
      // 	const manyRelation = manyRelations[0];
      // 	if (manyRelation) {
      // 		const {
      // 			tsKey: selectedRelationTsKey,
      // 			queryConfig: selectedRelationQueryConfig,
      // 			relation,
      // 		} = manyRelation;
      // 		distinct = {
      // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
      // 		};
      // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
      // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
      // 		const relationTableTsName = tableNamesMap[relationTableName]!;
      // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
      // 		const joinOn = and(
      // 			...normalizedRelation.fields.map((field, i) =>
      // 				eq(
      // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
      // 					aliasedTableColumn(field, tableAlias),
      // 				)
      // 			),
      // 		);
      // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table: fullSchema[relationTableTsName] as PgTable,
      // 			tableConfig: schema[relationTableTsName]!,
      // 			queryConfig: selectedRelationQueryConfig,
      // 			tableAlias: relationTableAlias,
      // 			joinOn,
      // 		});
      // 		const builtRelationSelectionField = sql`case when ${
      // 			sql.identifier(relationTableAlias)
      // 		} is null then '[]' else json_agg(json_build_array(${
      // 			sql.join(
      // 				builtRelationJoin.selection.map(({ field }) =>
      // 					is(field, SQL.Aliased)
      // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
      // 						: is(field, Column)
      // 						? aliasedTableColumn(field, relationTableAlias)
      // 						: field
      // 				),
      // 				sql`, `,
      // 			)
      // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
      // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
      // 		joins.push({
      // 			on: isLateralJoin ? sql`true` : joinOn,
      // 			table: isLateralJoin
      // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
      // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
      // 			alias: relationTableAlias,
      // 			joinType: 'left',
      // 			lateral: isLateralJoin,
      // 		});
      // 		// Build the "from" subquery with the remaining Many relations
      // 		const builtTableFrom = this.buildRelationalQueryWithPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table,
      // 			tableConfig,
      // 			queryConfig: {
      // 				...config,
      // 				where: undefined,
      // 				orderBy: undefined,
      // 				limit: undefined,
      // 				offset: undefined,
      // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
      // 					(result, { tsKey, queryConfig: configValue }) => {
      // 						result[tsKey] = configValue;
      // 						return result;
      // 					},
      // 					{},
      // 				),
      // 			},
      // 			tableAlias,
      // 		});
      // 		selectedRelations.push({
      // 			dbKey: selectedRelationTsKey,
      // 			tsKey: selectedRelationTsKey,
      // 			field: builtRelationSelectionField,
      // 			relationTableTsKey: relationTableTsName,
      // 			isJson: true,
      // 			selection: builtRelationJoin.selection,
      // 		});
      // 		// selection = builtTableFrom.selection.map((item) =>
      // 		// 	is(item.field, SQL.Aliased)
      // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
      // 		// 		: item
      // 		// );
      // 		// selectionForBuild = [{
      // 		// 	dbKey: '*',
      // 		// 	tsKey: '*',
      // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
      // 		// 	selection: [],
      // 		// 	isJson: false,
      // 		// 	relationTableTsKey: undefined,
      // 		// }];
      // 		// const newSelectionItem: (typeof selection)[number] = {
      // 		// 	dbKey: selectedRelationTsKey,
      // 		// 	tsKey: selectedRelationTsKey,
      // 		// 	field,
      // 		// 	relationTableTsKey: relationTableTsName,
      // 		// 	isJson: true,
      // 		// 	selection: builtRelationJoin.selection,
      // 		// };
      // 		// selection.push(newSelectionItem);
      // 		// selectionForBuild.push(newSelectionItem);
      // 		tableFrom = is(builtTableFrom.sql, PgTable)
      // 			? builtTableFrom.sql
      // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
      // 	}
      // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
      // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
      // 	}
      // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
      // 	function prepareSelectedColumns() {
      // 		return selectedColumns.map((key) => ({
      // 			dbKey: tableConfig.columns[key]!.name,
      // 			tsKey: key,
      // 			field: tableConfig.columns[key] as PgColumn,
      // 			relationTableTsKey: undefined,
      // 			isJson: false,
      // 			selection: [],
      // 		}));
      // 	}
      // 	function prepareSelectedExtras() {
      // 		return selectedExtras.map((item) => ({
      // 			dbKey: item.value.fieldAlias,
      // 			tsKey: item.tsKey,
      // 			field: item.value,
      // 			relationTableTsKey: undefined,
      // 			isJson: false,
      // 			selection: [],
      // 		}));
      // 	}
      // 	if (isRoot) {
      // 		selection = [
      // 			...prepareSelectedColumns(),
      // 			...prepareSelectedExtras(),
      // 		];
      // 	}
      // 	if (hasUserDefinedWhere || orderBy.length > 0) {
      // 		tableFrom = new Subquery(
      // 			this.buildSelectQuery({
      // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
      // 				fields: {},
      // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
      // 					path: [],
      // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
      // 				})),
      // 				joins,
      // 				distinct,
      // 			}),
      // 			{},
      // 			tableAlias,
      // 		);
      // 		selectionForBuild = selection.map((item) =>
      // 			is(item.field, SQL.Aliased)
      // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
      // 				: item
      // 		);
      // 		joins = [];
      // 		distinct = undefined;
      // 	}
      // 	const result = this.buildSelectQuery({
      // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
      // 		fields: {},
      // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
      // 			path: [],
      // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
      // 		})),
      // 		where,
      // 		limit,
      // 		offset,
      // 		joins,
      // 		orderBy,
      // 		distinct,
      // 	});
      // 	return {
      // 		tableTsKey: tableConfig.tsName,
      // 		sql: result,
      // 		selection,
      // 	};
      // }
      buildRelationalQueryWithoutPK({
        fullSchema,
        schema: schema2,
        tableNamesMap,
        table: table4,
        tableConfig,
        queryConfig: config2,
        tableAlias,
        nestedQueryRelation,
        joinOn
      }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        const joins = [];
        if (config2 === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key2, value]) => ({
            dbKey: value.name,
            tsKey: key2,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(
            Object.entries(tableConfig.columns).map(([key2, value]) => [key2, aliasedTableColumn(value, tableAlias)])
          );
          if (config2.where) {
            const whereSql = typeof config2.where === "function" ? config2.where(aliasedColumns, getOperators()) : config2.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config2.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config2.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config2.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key2) => !selectedColumns.includes(key2));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config2.with) {
            selectedRelations = Object.entries(config2.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config2.extras) {
            extras = typeof config2.extras === "function" ? config2.extras(aliasedColumns, { sql }) : config2.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config2.orderBy === "function" ? config2.orderBy(aliasedColumns, getOrderByOperators()) : config2.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config2.limit;
          offset = config2.offset;
          for (const {
            tsKey: selectedRelationTsKey,
            queryConfig: selectedRelationConfigValue,
            relation
          } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema2, tableNamesMap, relation);
            const relationTableName = getTableUniqueName(relation.referencedTable);
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(
              ...normalizedRelation.fields.map(
                (field2, i) => eq(
                  aliasedTableColumn(normalizedRelation.references[i], relationTableAlias),
                  aliasedTableColumn(field2, tableAlias)
                )
              )
            );
            const builtRelation = this.buildRelationalQueryWithoutPK({
              fullSchema,
              schema: schema2,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema2[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
            joins.push({
              on: sql`true`,
              table: new Subquery(builtRelation.sql, {}, relationTableAlias),
              alias: relationTableAlias,
              joinType: "left",
              lateral: true
            });
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_build_array(${sql.join(
            selection.map(
              ({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2
            ),
            sql`, `
          )})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : void 0}), '[]'::json)`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table4, tableAlias),
              fields: {},
              fieldsFlat: [{
                path: [],
                field: sql.raw("*")
              }],
              where,
              limit,
              offset,
              orderBy,
              setOperators: []
            });
            where = void 0;
            limit = void 0;
            offset = void 0;
            orderBy = [];
          } else {
            result = aliasedTable(table4, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table4, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/query-builders/query-builder.js
var TypedQueryBuilder;
var init_query_builder = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/query-builders/query-builder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    TypedQueryBuilder = class {
      static {
        __name(this, "TypedQueryBuilder");
      }
      static [entityKind] = "TypedQueryBuilder";
      /** @internal */
      getSelectedFields() {
        return this._.selectedFields;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/select.js
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select2) => ({
      type,
      isAll,
      rightSelect: select2
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var PgSelectBuilder, PgSelectQueryBuilderBase, PgSelectBase, getPgSetOperators, union, unionAll, intersect, intersectAll, except, exceptAll;
var init_select2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/select.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_view_base();
    init_query_builder();
    init_query_promise();
    init_selection_proxy();
    init_sql();
    init_subquery();
    init_table();
    init_tracing();
    init_utils2();
    init_utils2();
    init_view_common();
    PgSelectBuilder = class {
      static {
        __name(this, "PgSelectBuilder");
      }
      static [entityKind] = "PgSelectBuilder";
      fields;
      session;
      dialect;
      withList = [];
      distinct;
      constructor(config2) {
        this.fields = config2.fields;
        this.session = config2.session;
        this.dialect = config2.dialect;
        if (config2.withList) {
          this.withList = config2.withList;
        }
        this.distinct = config2.distinct;
      }
      authToken;
      /** @internal */
      setToken(token) {
        this.authToken = token;
        return this;
      }
      /**
       * Specify the table, subquery, or other target that you're
       * building a select query against.
       *
       * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM | Postgres from documentation}
       */
      from(source2) {
        const isPartialSelect = !!this.fields;
        const src = source2;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(src, Subquery)) {
          fields = Object.fromEntries(
            Object.keys(src._.selectedFields).map((key2) => [key2, src[key2]])
          );
        } else if (is(src, PgViewBase)) {
          fields = src[ViewBaseConfig].selectedFields;
        } else if (is(src, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(src);
        }
        return new PgSelectBase({
          table: src,
          fields,
          isPartialSelect,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct
        }).setToken(this.authToken);
      }
    };
    PgSelectQueryBuilderBase = class extends TypedQueryBuilder {
      static {
        __name(this, "PgSelectQueryBuilderBase");
      }
      static [entityKind] = "PgSelectQueryBuilder";
      _;
      config;
      joinsNotNullableMap;
      tableName;
      isPartialSelect;
      session;
      dialect;
      constructor({ table: table4, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
          withList,
          table: table4,
          fields: { ...fields },
          distinct,
          setOperators: []
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields
        };
        this.tableName = getTableLikeName(table4);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      createJoin(joinType) {
        return (table4, on2) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table4);
          if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table4, SQL)) {
              const selection = is(table4, Subquery) ? table4._.selectedFields : is(table4, View) ? table4[ViewBaseConfig].selectedFields : table4[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on2 === "function") {
            on2 = on2(
              new Proxy(
                this.config.fields,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on: on2, table: table4, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false])
                );
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false])
                );
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      /**
       * Executes a `left join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      leftJoin = this.createJoin("left");
      /**
       * Executes a `right join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      rightJoin = this.createJoin("right");
      /**
       * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
       *
       * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      innerJoin = this.createJoin("inner");
      /**
       * Executes a `full join` operation by combining rows from two tables into a new table.
       *
       * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      fullJoin = this.createJoin("full");
      createSetOperator(type, isAll) {
        return (rightSelection) => {
          const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
          if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
            throw new Error(
              "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
            );
          }
          this.config.setOperators.push({ type, isAll, rightSelect });
          return this;
        };
      }
      /**
       * Adds `union` set operator to the query.
       *
       * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
       *
       * @example
       *
       * ```ts
       * // Select all unique names from customers and users tables
       * await db.select({ name: users.name })
       *   .from(users)
       *   .union(
       *     db.select({ name: customers.name }).from(customers)
       *   );
       * // or
       * import { union } from 'drizzle-orm/pg-core'
       *
       * await union(
       *   db.select({ name: users.name }).from(users),
       *   db.select({ name: customers.name }).from(customers)
       * );
       * ```
       */
      union = this.createSetOperator("union", false);
      /**
       * Adds `union all` set operator to the query.
       *
       * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
       *
       * @example
       *
       * ```ts
       * // Select all transaction ids from both online and in-store sales
       * await db.select({ transaction: onlineSales.transactionId })
       *   .from(onlineSales)
       *   .unionAll(
       *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       *   );
       * // or
       * import { unionAll } from 'drizzle-orm/pg-core'
       *
       * await unionAll(
       *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
       *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       * );
       * ```
       */
      unionAll = this.createSetOperator("union", true);
      /**
       * Adds `intersect` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
       *
       * @example
       *
       * ```ts
       * // Select course names that are offered in both departments A and B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .intersect(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { intersect } from 'drizzle-orm/pg-core'
       *
       * await intersect(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      intersect = this.createSetOperator("intersect", false);
      /**
       * Adds `intersect all` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets including all duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}
       *
       * @example
       *
       * ```ts
       * // Select all products and quantities that are ordered by both regular and VIP customers
       * await db.select({
       *   productId: regularCustomerOrders.productId,
       *   quantityOrdered: regularCustomerOrders.quantityOrdered
       * })
       * .from(regularCustomerOrders)
       * .intersectAll(
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered
       *   })
       *   .from(vipCustomerOrders)
       * );
       * // or
       * import { intersectAll } from 'drizzle-orm/pg-core'
       *
       * await intersectAll(
       *   db.select({
       *     productId: regularCustomerOrders.productId,
       *     quantityOrdered: regularCustomerOrders.quantityOrdered
       *   })
       *   .from(regularCustomerOrders),
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered
       *   })
       *   .from(vipCustomerOrders)
       * );
       * ```
       */
      intersectAll = this.createSetOperator("intersect", true);
      /**
       * Adds `except` set operator to the query.
       *
       * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
       *
       * @example
       *
       * ```ts
       * // Select all courses offered in department A but not in department B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .except(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { except } from 'drizzle-orm/pg-core'
       *
       * await except(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      except = this.createSetOperator("except", false);
      /**
       * Adds `except all` set operator to the query.
       *
       * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}
       *
       * @example
       *
       * ```ts
       * // Select all products that are ordered by regular customers but not by VIP customers
       * await db.select({
       *   productId: regularCustomerOrders.productId,
       *   quantityOrdered: regularCustomerOrders.quantityOrdered,
       * })
       * .from(regularCustomerOrders)
       * .exceptAll(
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered,
       *   })
       *   .from(vipCustomerOrders)
       * );
       * // or
       * import { exceptAll } from 'drizzle-orm/pg-core'
       *
       * await exceptAll(
       *   db.select({
       *     productId: regularCustomerOrders.productId,
       *     quantityOrdered: regularCustomerOrders.quantityOrdered
       *   })
       *   .from(regularCustomerOrders),
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered
       *   })
       *   .from(vipCustomerOrders)
       * );
       * ```
       */
      exceptAll = this.createSetOperator("except", true);
      /** @internal */
      addSetOperators(setOperators) {
        this.config.setOperators.push(...setOperators);
        return this;
      }
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be selected.
       *
       * ```ts
       * // Select all cars with green color
       * await db.select().from(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Select all BMW cars with a green color
       * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Select all cars with the green or blue color
       * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        if (typeof where === "function") {
          where = where(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.where = where;
        return this;
      }
      /**
       * Adds a `having` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
       *
       * @param having the `having` clause.
       *
       * @example
       *
       * ```ts
       * // Select all brands with more than one car
       * await db.select({
       * 	brand: cars.brand,
       * 	count: sql<number>`cast(count(${cars.id}) as int)`,
       * })
       *   .from(cars)
       *   .groupBy(cars.brand)
       *   .having(({ count }) => gt(count, 1));
       * ```
       */
      having(having) {
        if (typeof having === "function") {
          having = having(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        } else {
          const orderByArray = columns;
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        }
        return this;
      }
      /**
       * Adds a `limit` clause to the query.
       *
       * Calling this method will set the maximum number of rows that will be returned by this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param limit the `limit` clause.
       *
       * @example
       *
       * ```ts
       * // Get the first 10 people from this query.
       * await db.select().from(people).limit(10);
       * ```
       */
      limit(limit) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).limit = limit;
        } else {
          this.config.limit = limit;
        }
        return this;
      }
      /**
       * Adds an `offset` clause to the query.
       *
       * Calling this method will skip a number of rows when returning results from this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param offset the `offset` clause.
       *
       * @example
       *
       * ```ts
       * // Get the 10th-20th people from this query.
       * await db.select().from(people).offset(10).limit(10);
       * ```
       */
      offset(offset) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).offset = offset;
        } else {
          this.config.offset = offset;
        }
        return this;
      }
      /**
       * Adds a `for` clause to the query.
       *
       * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.
       *
       * See docs: {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE}
       *
       * @param strength the lock strength.
       * @param config the lock configuration.
       */
      for(strength, config2 = {}) {
        this.config.lockingClause = { strength, config: config2 };
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        return new Proxy(
          new Subquery(this.getSQL(), this.config.fields, alias),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      /** @internal */
      getSelectedFields() {
        return new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      $dynamic() {
        return this;
      }
    };
    PgSelectBase = class extends PgSelectQueryBuilderBase {
      static {
        __name(this, "PgSelectBase");
      }
      static [entityKind] = "PgSelect";
      /** @internal */
      _prepare(name) {
        const { session, config: config2, dialect, joinsNotNullableMap, authToken } = this;
        if (!session) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          const fieldsList = orderSelectedFields(config2.fields);
          const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true);
          query.joinsNotNullableMap = joinsNotNullableMap;
          return query.setToken(authToken);
        });
      }
      /**
       * Create a prepared statement for this query. This allows
       * the database to remember this query for the given session
       * and call it by name, rather than specifying the full query.
       *
       * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}
       */
      prepare(name) {
        return this._prepare(name);
      }
      authToken;
      /** @internal */
      setToken(token) {
        this.authToken = token;
        return this;
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute(placeholderValues, this.authToken);
        });
      }, "execute");
    };
    applyMixins(PgSelectBase, [QueryPromise]);
    __name(createSetOperator, "createSetOperator");
    getPgSetOperators = /* @__PURE__ */ __name(() => ({
      union,
      unionAll,
      intersect,
      intersectAll,
      except,
      exceptAll
    }), "getPgSetOperators");
    union = createSetOperator("union", false);
    unionAll = createSetOperator("union", true);
    intersect = createSetOperator("intersect", false);
    intersectAll = createSetOperator("intersect", true);
    except = createSetOperator("except", false);
    exceptAll = createSetOperator("except", true);
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
var QueryBuilder;
var init_query_builder2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/query-builder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_dialect();
    init_selection_proxy();
    init_subquery();
    init_select2();
    QueryBuilder = class {
      static {
        __name(this, "QueryBuilder");
      }
      static [entityKind] = "PgQueryBuilder";
      dialect;
      dialectConfig;
      constructor(dialect) {
        this.dialect = is(dialect, PgDialect) ? dialect : void 0;
        this.dialectConfig = is(dialect, PgDialect) ? void 0 : dialect;
      }
      $with = /* @__PURE__ */ __name((alias, selection) => {
        const queryBuilder = this;
        const as = /* @__PURE__ */ __name((qb) => {
          if (typeof qb === "function") {
            qb = qb(queryBuilder);
          }
          return new Proxy(
            new WithSubquery(
              qb.getSQL(),
              selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
              alias,
              true
            ),
            new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
          );
        }, "as");
        return { as };
      }, "$with");
      with(...queries) {
        const self = this;
        function select2(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        __name(select2, "select");
        function selectDistinct(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        function selectDistinctOn(on2, fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            distinct: { on: on2 }
          });
        }
        __name(selectDistinctOn, "selectDistinctOn");
        return { select: select2, selectDistinct, selectDistinctOn };
      }
      select(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect()
        });
      }
      selectDistinct(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      selectDistinctOn(on2, fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: { on: on2 }
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new PgDialect(this.dialectConfig);
        }
        return this.dialect;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/insert.js
var PgInsertBuilder, PgInsertBase;
var init_insert = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/insert.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_selection_proxy();
    init_sql();
    init_table();
    init_tracing();
    init_utils2();
    init_query_builder2();
    PgInsertBuilder = class {
      static {
        __name(this, "PgInsertBuilder");
      }
      constructor(table4, session, dialect, withList, overridingSystemValue_) {
        this.table = table4;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
        this.overridingSystemValue_ = overridingSystemValue_;
      }
      static [entityKind] = "PgInsertBuilder";
      authToken;
      /** @internal */
      setToken(token) {
        this.authToken = token;
        return this;
      }
      overridingSystemValue() {
        this.overridingSystemValue_ = true;
        return this;
      }
      values(values2) {
        values2 = Array.isArray(values2) ? values2 : [values2];
        if (values2.length === 0) {
          throw new Error("values() must be called with at least one value");
        }
        const mappedValues = values2.map((entry) => {
          const result = {};
          const cols = this.table[Table.Symbol.Columns];
          for (const colKey of Object.keys(entry)) {
            const colValue = entry[colKey];
            result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
          }
          return result;
        });
        return new PgInsertBase(
          this.table,
          mappedValues,
          this.session,
          this.dialect,
          this.withList,
          false,
          this.overridingSystemValue_
        ).setToken(this.authToken);
      }
      select(selectQuery) {
        const select2 = typeof selectQuery === "function" ? selectQuery(new QueryBuilder()) : selectQuery;
        if (!is(select2, SQL) && !haveSameKeys(this.table[Columns], select2._.selectedFields)) {
          throw new Error(
            "Insert select error: selected fields are not the same or are in a different order compared to the table definition"
          );
        }
        return new PgInsertBase(this.table, select2, this.session, this.dialect, this.withList, true);
      }
    };
    PgInsertBase = class extends QueryPromise {
      static {
        __name(this, "PgInsertBase");
      }
      constructor(table4, values2, session, dialect, withList, select2, overridingSystemValue_) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table4, values: values2, withList, select: select2, overridingSystemValue_ };
      }
      static [entityKind] = "PgInsert";
      config;
      returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returningFields = fields;
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /**
       * Adds an `on conflict do nothing` clause to the query.
       *
       * Calling this method simply avoids inserting a row as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
       *
       * @param config The `target` and `where` clauses.
       *
       * @example
       * ```ts
       * // Insert one row and cancel the insert if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing();
       *
       * // Explicitly specify conflict target
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing({ target: cars.id });
       * ```
       */
      onConflictDoNothing(config2 = {}) {
        if (config2.target === void 0) {
          this.config.onConflict = sql`do nothing`;
        } else {
          let targetColumn = "";
          targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config2.target));
          const whereSql = config2.where ? sql` where ${config2.where}` : void 0;
          this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
        }
        return this;
      }
      /**
       * Adds an `on conflict do update` clause to the query.
       *
       * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
       *
       * @param config The `target`, `set` and `where` clauses.
       *
       * @example
       * ```ts
       * // Update the row if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'Porsche' }
       *   });
       *
       * // Upsert with 'where' clause
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'newBMW' },
       *     targetWhere: sql`${cars.createdAt} > '2023-01-01'::date`,
       *   });
       * ```
       */
      onConflictDoUpdate(config2) {
        if (config2.where && (config2.targetWhere || config2.setWhere)) {
          throw new Error(
            'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
          );
        }
        const whereSql = config2.where ? sql` where ${config2.where}` : void 0;
        const targetWhereSql = config2.targetWhere ? sql` where ${config2.targetWhere}` : void 0;
        const setWhereSql = config2.setWhere ? sql` where ${config2.setWhere}` : void 0;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config2.set));
        let targetColumn = "";
        targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config2.target));
        this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildInsertQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(name) {
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
        });
      }
      prepare(name) {
        return this._prepare(name);
      }
      authToken;
      /** @internal */
      setToken(token) {
        this.authToken = token;
        return this;
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute(placeholderValues, this.authToken);
        });
      }, "execute");
      /** @internal */
      getSelectedFields() {
        return this.config.returningFields ? new Proxy(
          this.config.returningFields,
          new SelectionProxyHandler({
            alias: getTableName(this.config.table),
            sqlAliasedBehavior: "alias",
            sqlBehavior: "error"
          })
        ) : void 0;
      }
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
var PgRefreshMaterializedView;
var init_refresh_materialized_view = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_tracing();
    PgRefreshMaterializedView = class extends QueryPromise {
      static {
        __name(this, "PgRefreshMaterializedView");
      }
      constructor(view, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { view };
      }
      static [entityKind] = "PgRefreshMaterializedView";
      config;
      concurrently() {
        if (this.config.withNoData !== void 0) {
          throw new Error("Cannot use concurrently and withNoData together");
        }
        this.config.concurrently = true;
        return this;
      }
      withNoData() {
        if (this.config.concurrently !== void 0) {
          throw new Error("Cannot use concurrently and withNoData together");
        }
        this.config.withNoData = true;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildRefreshMaterializedViewQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(name) {
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0, name, true);
        });
      }
      prepare(name) {
        return this._prepare(name);
      }
      authToken;
      /** @internal */
      setToken(token) {
        this.authToken = token;
        return this;
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute(placeholderValues, this.authToken);
        });
      }, "execute");
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/select.types.js
var init_select_types = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/select.types.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/update.js
var PgUpdateBuilder, PgUpdateBase;
var init_update = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/update.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table2();
    init_query_promise();
    init_selection_proxy();
    init_sql();
    init_subquery();
    init_table();
    init_utils2();
    init_view_common();
    PgUpdateBuilder = class {
      static {
        __name(this, "PgUpdateBuilder");
      }
      constructor(table4, session, dialect, withList) {
        this.table = table4;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "PgUpdateBuilder";
      authToken;
      setToken(token) {
        this.authToken = token;
        return this;
      }
      set(values2) {
        return new PgUpdateBase(
          this.table,
          mapUpdateSet(this.table, values2),
          this.session,
          this.dialect,
          this.withList
        ).setToken(this.authToken);
      }
    };
    PgUpdateBase = class extends QueryPromise {
      static {
        __name(this, "PgUpdateBase");
      }
      constructor(table4, set2, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set: set2, table: table4, withList, joins: [] };
        this.tableName = getTableLikeName(table4);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      static [entityKind] = "PgUpdate";
      config;
      tableName;
      joinsNotNullableMap;
      from(source2) {
        const src = source2;
        const tableName = getTableLikeName(src);
        if (typeof tableName === "string") {
          this.joinsNotNullableMap[tableName] = true;
        }
        this.config.from = src;
        return this;
      }
      getTableLikeFields(table4) {
        if (is(table4, PgTable)) {
          return table4[Table.Symbol.Columns];
        } else if (is(table4, Subquery)) {
          return table4._.selectedFields;
        }
        return table4[ViewBaseConfig].selectedFields;
      }
      createJoin(joinType) {
        return (table4, on2) => {
          const tableName = getTableLikeName(table4);
          if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (typeof on2 === "function") {
            const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : void 0;
            on2 = on2(
              new Proxy(
                this.config.table[Table.Symbol.Columns],
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              ),
              from && new Proxy(
                from,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          this.config.joins.push({ on: on2, table: table4, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false])
                );
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false])
                );
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      leftJoin = this.createJoin("left");
      rightJoin = this.createJoin("right");
      innerJoin = this.createJoin("inner");
      fullJoin = this.createJoin("full");
      /**
       * Adds a 'where' clause to the query.
       *
       * Calling this method will update only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param where the 'where' clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be updated.
       *
       * ```ts
       * // Update all cars with green color
       * await db.update(cars).set({ color: 'red' })
       *   .where(eq(cars.color, 'green'));
       * // or
       * await db.update(cars).set({ color: 'red' })
       *   .where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Update all BMW cars with a green color
       * await db.update(cars).set({ color: 'red' })
       *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Update all cars with the green or blue color
       * await db.update(cars).set({ color: 'red' })
       *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields) {
        if (!fields) {
          fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);
          if (this.config.from) {
            const tableName = getTableLikeName(this.config.from);
            if (typeof tableName === "string" && this.config.from && !is(this.config.from, SQL)) {
              const fromFields = this.getTableLikeFields(this.config.from);
              fields[tableName] = fromFields;
            }
            for (const join of this.config.joins) {
              const tableName2 = getTableLikeName(join.table);
              if (typeof tableName2 === "string" && !is(join.table, SQL)) {
                const fromFields = this.getTableLikeFields(join.table);
                fields[tableName2] = fromFields;
              }
            }
          }
        }
        this.config.returningFields = fields;
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(name) {
        const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
      }
      prepare(name) {
        return this._prepare(name);
      }
      authToken;
      /** @internal */
      setToken(token) {
        this.authToken = token;
        return this;
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().execute(placeholderValues, this.authToken);
      }, "execute");
      /** @internal */
      getSelectedFields() {
        return this.config.returningFields ? new Proxy(
          this.config.returningFields,
          new SelectionProxyHandler({
            alias: getTableName(this.config.table),
            sqlAliasedBehavior: "alias",
            sqlBehavior: "error"
          })
        ) : void 0;
      }
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/index.js
var init_query_builders = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_delete();
    init_insert();
    init_query_builder2();
    init_refresh_materialized_view();
    init_select2();
    init_select_types();
    init_update();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/count.js
var PgCountBuilder;
var init_count = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/count.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    PgCountBuilder = class _PgCountBuilder extends SQL {
      static {
        __name(this, "PgCountBuilder");
      }
      constructor(params) {
        super(_PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
        this.params = params;
        this.mapWith(Number);
        this.session = params.session;
        this.sql = _PgCountBuilder.buildCount(
          params.source,
          params.filters
        );
      }
      sql;
      token;
      static [entityKind] = "PgCountBuilder";
      [Symbol.toStringTag] = "PgCountBuilder";
      session;
      static buildEmbeddedCount(source2, filters) {
        return sql`(select count(*) from ${source2}${sql.raw(" where ").if(filters)}${filters})`;
      }
      static buildCount(source2, filters) {
        return sql`select count(*) as count from ${source2}${sql.raw(" where ").if(filters)}${filters};`;
      }
      /** @intrnal */
      setToken(token) {
        this.token = token;
        return this;
      }
      then(onfulfilled, onrejected) {
        return Promise.resolve(this.session.count(this.sql, this.token)).then(
          onfulfilled,
          onrejected
        );
      }
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/query.js
var RelationalQueryBuilder, PgRelationalQuery;
var init_query2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/query.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_relations();
    init_tracing();
    RelationalQueryBuilder = class {
      static {
        __name(this, "RelationalQueryBuilder");
      }
      constructor(fullSchema, schema2, tableNamesMap, table4, tableConfig, dialect, session) {
        this.fullSchema = fullSchema;
        this.schema = schema2;
        this.tableNamesMap = tableNamesMap;
        this.table = table4;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
      }
      static [entityKind] = "PgRelationalQueryBuilder";
      findMany(config2) {
        return new PgRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? config2 : {},
          "many"
        );
      }
      findFirst(config2) {
        return new PgRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? { ...config2, limit: 1 } : { limit: 1 },
          "first"
        );
      }
    };
    PgRelationalQuery = class extends QueryPromise {
      static {
        __name(this, "PgRelationalQuery");
      }
      constructor(fullSchema, schema2, tableNamesMap, table4, tableConfig, dialect, session, config2, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema2;
        this.tableNamesMap = tableNamesMap;
        this.table = table4;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config2;
        this.mode = mode;
      }
      static [entityKind] = "PgRelationalQuery";
      /** @internal */
      _prepare(name) {
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          const { query, builtQuery } = this._toSQL();
          return this.session.prepareQuery(
            builtQuery,
            void 0,
            name,
            true,
            (rawRows, mapColumnValue) => {
              const rows = rawRows.map(
                (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
              );
              if (this.mode === "first") {
                return rows[0];
              }
              return rows;
            }
          );
        });
      }
      prepare(name) {
        return this._prepare(name);
      }
      _getQuery() {
        return this.dialect.buildRelationalQueryWithoutPK({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        });
      }
      /** @internal */
      getSQL() {
        return this._getQuery().sql;
      }
      _toSQL() {
        const query = this._getQuery();
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { query, builtQuery };
      }
      toSQL() {
        return this._toSQL().builtQuery;
      }
      authToken;
      /** @internal */
      setToken(token) {
        this.authToken = token;
        return this;
      }
      execute() {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute(void 0, this.authToken);
        });
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/raw.js
var PgRaw;
var init_raw = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/query-builders/raw.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    PgRaw = class extends QueryPromise {
      static {
        __name(this, "PgRaw");
      }
      constructor(execute, sql2, query, mapBatchResult) {
        super();
        this.execute = execute;
        this.sql = sql2;
        this.query = query;
        this.mapBatchResult = mapBatchResult;
      }
      static [entityKind] = "PgRaw";
      /** @internal */
      getSQL() {
        return this.sql;
      }
      getQuery() {
        return this.query;
      }
      mapResult(result, isFromBatch) {
        return isFromBatch ? this.mapBatchResult(result) : result;
      }
      _prepare() {
        return this;
      }
      /** @internal */
      isResponseInArrayMode() {
        return false;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/db.js
var PgDatabase;
var init_db = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/db.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_builders();
    init_selection_proxy();
    init_sql();
    init_subquery();
    init_count();
    init_query2();
    init_raw();
    init_refresh_materialized_view();
    PgDatabase = class {
      static {
        __name(this, "PgDatabase");
      }
      constructor(dialect, session, schema2) {
        this.dialect = dialect;
        this.session = session;
        this._ = schema2 ? {
          schema: schema2.schema,
          fullSchema: schema2.fullSchema,
          tableNamesMap: schema2.tableNamesMap,
          session
        } : {
          schema: void 0,
          fullSchema: {},
          tableNamesMap: {},
          session
        };
        this.query = {};
        if (this._.schema) {
          for (const [tableName, columns] of Object.entries(this._.schema)) {
            this.query[tableName] = new RelationalQueryBuilder(
              schema2.fullSchema,
              this._.schema,
              this._.tableNamesMap,
              schema2.fullSchema[tableName],
              columns,
              dialect,
              session
            );
          }
        }
      }
      static [entityKind] = "PgDatabase";
      query;
      /**
       * Creates a subquery that defines a temporary named result set as a CTE.
       *
       * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param alias The alias for the subquery.
       *
       * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
       *
       * @example
       *
       * ```ts
       * // Create a subquery with alias 'sq' and use it in the select query
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * const result = await db.with(sq).select().from(sq);
       * ```
       *
       * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
       *
       * ```ts
       * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
       * const sq = db.$with('sq').as(db.select({
       *   name: sql<string>`upper(${users.name})`.as('name'),
       * })
       * .from(users));
       *
       * const result = await db.with(sq).select({ name: sq.name }).from(sq);
       * ```
       */
      $with = /* @__PURE__ */ __name((alias, selection) => {
        const self = this;
        const as = /* @__PURE__ */ __name((qb) => {
          if (typeof qb === "function") {
            qb = qb(new QueryBuilder(self.dialect));
          }
          return new Proxy(
            new WithSubquery(
              qb.getSQL(),
              selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
              alias,
              true
            ),
            new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
          );
        }, "as");
        return { as };
      }, "$with");
      $count(source2, filters) {
        return new PgCountBuilder({ source: source2, filters, session: this.session });
      }
      /**
       * Incorporates a previously defined CTE (using `$with`) into the main query.
       *
       * This method allows the main query to reference a temporary named result set.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param queries The CTEs to incorporate into the main query.
       *
       * @example
       *
       * ```ts
       * // Define a subquery 'sq' as a CTE using $with
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * // Incorporate the CTE 'sq' into the main query and select from it
       * const result = await db.with(sq).select().from(sq);
       * ```
       */
      with(...queries) {
        const self = this;
        function select2(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries
          });
        }
        __name(select2, "select");
        function selectDistinct(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        function selectDistinctOn(on2, fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: { on: on2 }
          });
        }
        __name(selectDistinctOn, "selectDistinctOn");
        function update(table4) {
          return new PgUpdateBuilder(table4, self.session, self.dialect, queries);
        }
        __name(update, "update");
        function insert(table4) {
          return new PgInsertBuilder(table4, self.session, self.dialect, queries);
        }
        __name(insert, "insert");
        function delete_(table4) {
          return new PgDeleteBase(table4, self.session, self.dialect, queries);
        }
        __name(delete_, "delete_");
        return { select: select2, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
      }
      select(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect
        });
      }
      selectDistinct(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: true
        });
      }
      selectDistinctOn(on2, fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: { on: on2 }
        });
      }
      /**
       * Creates an update query.
       *
       * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
       *
       * Use `.set()` method to specify which values to update.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param table The table to update.
       *
       * @example
       *
       * ```ts
       * // Update all rows in the 'cars' table
       * await db.update(cars).set({ color: 'red' });
       *
       * // Update rows with filters and conditions
       * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
       *
       * // Update with returning clause
       * const updatedCar: Car[] = await db.update(cars)
       *   .set({ color: 'red' })
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      update(table4) {
        return new PgUpdateBuilder(table4, this.session, this.dialect);
      }
      /**
       * Creates an insert query.
       *
       * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert}
       *
       * @param table The table to insert into.
       *
       * @example
       *
       * ```ts
       * // Insert one row
       * await db.insert(cars).values({ brand: 'BMW' });
       *
       * // Insert multiple rows
       * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
       *
       * // Insert with returning clause
       * const insertedCar: Car[] = await db.insert(cars)
       *   .values({ brand: 'BMW' })
       *   .returning();
       * ```
       */
      insert(table4) {
        return new PgInsertBuilder(table4, this.session, this.dialect);
      }
      /**
       * Creates a delete query.
       *
       * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param table The table to delete from.
       *
       * @example
       *
       * ```ts
       * // Delete all rows in the 'cars' table
       * await db.delete(cars);
       *
       * // Delete rows with filters and conditions
       * await db.delete(cars).where(eq(cars.color, 'green'));
       *
       * // Delete with returning clause
       * const deletedCar: Car[] = await db.delete(cars)
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      delete(table4) {
        return new PgDeleteBase(table4, this.session, this.dialect);
      }
      refreshMaterializedView(view) {
        return new PgRefreshMaterializedView(view, this.session, this.dialect);
      }
      authToken;
      execute(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        const builtQuery = this.dialect.sqlToQuery(sequel);
        const prepared = this.session.prepareQuery(
          builtQuery,
          void 0,
          void 0,
          false
        );
        return new PgRaw(
          () => prepared.execute(void 0, this.authToken),
          sequel,
          builtQuery,
          (result) => prepared.mapResult(result, true)
        );
      }
      transaction(transaction, config2) {
        return this.session.transaction(transaction, config2);
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/alias.js
var init_alias2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/alias.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/checks.js
var CheckBuilder, Check;
var init_checks = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/checks.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    CheckBuilder = class {
      static {
        __name(this, "CheckBuilder");
      }
      constructor(name, value) {
        this.name = name;
        this.value = value;
      }
      static [entityKind] = "PgCheckBuilder";
      brand;
      /** @internal */
      build(table4) {
        return new Check(table4, this);
      }
    };
    Check = class {
      static {
        __name(this, "Check");
      }
      constructor(table4, builder) {
        this.table = table4;
        this.name = builder.name;
        this.value = builder.value;
      }
      static [entityKind] = "PgCheck";
      name;
      value;
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/indexes.js
var IndexBuilderOn, IndexBuilder, Index;
var init_indexes = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/indexes.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_sql();
    init_entity();
    init_columns();
    IndexBuilderOn = class {
      static {
        __name(this, "IndexBuilderOn");
      }
      constructor(unique, name) {
        this.unique = unique;
        this.name = name;
      }
      static [entityKind] = "PgIndexBuilderOn";
      on(...columns) {
        return new IndexBuilder(
          columns.map((it) => {
            if (is(it, SQL)) {
              return it;
            }
            it = it;
            const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
            it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
            return clonedIndexedColumn;
          }),
          this.unique,
          false,
          this.name
        );
      }
      onOnly(...columns) {
        return new IndexBuilder(
          columns.map((it) => {
            if (is(it, SQL)) {
              return it;
            }
            it = it;
            const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
            it.indexConfig = it.defaultConfig;
            return clonedIndexedColumn;
          }),
          this.unique,
          true,
          this.name
        );
      }
      /**
       * Specify what index method to use. Choices are `btree`, `hash`, `gist`, `spgist`, `gin`, `brin`, or user-installed access methods like `bloom`. The default method is `btree.
       *
       * If you have the `pg_vector` extension installed in your database, you can use the `hnsw` and `ivfflat` options, which are predefined types.
       *
       * **You can always specify any string you want in the method, in case Drizzle doesn't have it natively in its types**
       *
       * @param method The name of the index method to be used
       * @param columns
       * @returns
       */
      using(method, ...columns) {
        return new IndexBuilder(
          columns.map((it) => {
            if (is(it, SQL)) {
              return it;
            }
            it = it;
            const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
            it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
            return clonedIndexedColumn;
          }),
          this.unique,
          true,
          this.name,
          method
        );
      }
    };
    IndexBuilder = class {
      static {
        __name(this, "IndexBuilder");
      }
      static [entityKind] = "PgIndexBuilder";
      /** @internal */
      config;
      constructor(columns, unique, only, name, method = "btree") {
        this.config = {
          name,
          columns,
          unique,
          only,
          method
        };
      }
      concurrently() {
        this.config.concurrently = true;
        return this;
      }
      with(obj) {
        this.config.with = obj;
        return this;
      }
      where(condition) {
        this.config.where = condition;
        return this;
      }
      /** @internal */
      build(table4) {
        return new Index(this.config, table4);
      }
    };
    Index = class {
      static {
        __name(this, "Index");
      }
      static [entityKind] = "PgIndex";
      config;
      constructor(config2, table4) {
        this.config = { ...config2, table: table4 };
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/policies.js
var PgPolicy;
var init_policies = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/policies.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    PgPolicy = class {
      static {
        __name(this, "PgPolicy");
      }
      constructor(name, config2) {
        this.name = name;
        if (config2) {
          this.as = config2.as;
          this.for = config2.for;
          this.to = config2.to;
          this.using = config2.using;
          this.withCheck = config2.withCheck;
        }
      }
      static [entityKind] = "PgPolicy";
      as;
      for;
      to;
      using;
      withCheck;
      /** @internal */
      _linkedTable;
      link(table4) {
        this._linkedTable = table4;
        return this;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/roles.js
var PgRole;
var init_roles = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/roles.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    PgRole = class {
      static {
        __name(this, "PgRole");
      }
      constructor(name, config2) {
        this.name = name;
        if (config2) {
          this.createDb = config2.createDb;
          this.createRole = config2.createRole;
          this.inherit = config2.inherit;
        }
      }
      static [entityKind] = "PgRole";
      /** @internal */
      _existing;
      /** @internal */
      createDb;
      /** @internal */
      createRole;
      /** @internal */
      inherit;
      existing() {
        this._existing = true;
        return this;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/sequence.js
function pgSequenceWithSchema(name, options2, schema2) {
  return new PgSequence(name, options2, schema2);
}
var PgSequence;
var init_sequence = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/sequence.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    PgSequence = class {
      static {
        __name(this, "PgSequence");
      }
      constructor(seqName, seqOptions, schema2) {
        this.seqName = seqName;
        this.seqOptions = seqOptions;
        this.schema = schema2;
      }
      static [entityKind] = "PgSequence";
    };
    __name(pgSequenceWithSchema, "pgSequenceWithSchema");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/view-common.js
var PgViewConfig;
var init_view_common2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/view-common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    PgViewConfig = Symbol.for("drizzle:PgViewConfig");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/view.js
function pgViewWithSchema(name, selection, schema2) {
  if (selection) {
    return new ManualViewBuilder(name, selection, schema2);
  }
  return new ViewBuilder(name, schema2);
}
function pgMaterializedViewWithSchema(name, selection, schema2) {
  if (selection) {
    return new ManualMaterializedViewBuilder(name, selection, schema2);
  }
  return new MaterializedViewBuilder(name, schema2);
}
var DefaultViewBuilderCore, ViewBuilder, ManualViewBuilder, MaterializedViewBuilderCore, MaterializedViewBuilder, ManualMaterializedViewBuilder, PgView, PgMaterializedViewConfig, PgMaterializedView;
var init_view = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/view.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_selection_proxy();
    init_utils2();
    init_query_builder2();
    init_table2();
    init_view_base();
    init_view_common2();
    DefaultViewBuilderCore = class {
      static {
        __name(this, "DefaultViewBuilderCore");
      }
      constructor(name, schema2) {
        this.name = name;
        this.schema = schema2;
      }
      static [entityKind] = "PgDefaultViewBuilderCore";
      config = {};
      with(config2) {
        this.config.with = config2;
        return this;
      }
    };
    ViewBuilder = class extends DefaultViewBuilderCore {
      static {
        __name(this, "ViewBuilder");
      }
      static [entityKind] = "PgViewBuilder";
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(
          new PgView({
            pgConfig: this.config,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: aliasedSelection,
              query: qb.getSQL().inlineParams()
            }
          }),
          selectionProxy
        );
      }
    };
    ManualViewBuilder = class extends DefaultViewBuilderCore {
      static {
        __name(this, "ManualViewBuilder");
      }
      static [entityKind] = "PgManualViewBuilder";
      columns;
      constructor(name, columns, schema2) {
        super(name, schema2);
        this.columns = getTableColumns(pgTable(name, columns));
      }
      existing() {
        return new Proxy(
          new PgView({
            pgConfig: void 0,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: void 0
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
      as(query) {
        return new Proxy(
          new PgView({
            pgConfig: this.config,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: query.inlineParams()
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
    };
    MaterializedViewBuilderCore = class {
      static {
        __name(this, "MaterializedViewBuilderCore");
      }
      constructor(name, schema2) {
        this.name = name;
        this.schema = schema2;
      }
      static [entityKind] = "PgMaterializedViewBuilderCore";
      config = {};
      using(using2) {
        this.config.using = using2;
        return this;
      }
      with(config2) {
        this.config.with = config2;
        return this;
      }
      tablespace(tablespace) {
        this.config.tablespace = tablespace;
        return this;
      }
      withNoData() {
        this.config.withNoData = true;
        return this;
      }
    };
    MaterializedViewBuilder = class extends MaterializedViewBuilderCore {
      static {
        __name(this, "MaterializedViewBuilder");
      }
      static [entityKind] = "PgMaterializedViewBuilder";
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(
          new PgMaterializedView({
            pgConfig: {
              with: this.config.with,
              using: this.config.using,
              tablespace: this.config.tablespace,
              withNoData: this.config.withNoData
            },
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: aliasedSelection,
              query: qb.getSQL().inlineParams()
            }
          }),
          selectionProxy
        );
      }
    };
    ManualMaterializedViewBuilder = class extends MaterializedViewBuilderCore {
      static {
        __name(this, "ManualMaterializedViewBuilder");
      }
      static [entityKind] = "PgManualMaterializedViewBuilder";
      columns;
      constructor(name, columns, schema2) {
        super(name, schema2);
        this.columns = getTableColumns(pgTable(name, columns));
      }
      existing() {
        return new Proxy(
          new PgMaterializedView({
            pgConfig: {
              tablespace: this.config.tablespace,
              using: this.config.using,
              with: this.config.with,
              withNoData: this.config.withNoData
            },
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: void 0
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
      as(query) {
        return new Proxy(
          new PgMaterializedView({
            pgConfig: {
              tablespace: this.config.tablespace,
              using: this.config.using,
              with: this.config.with,
              withNoData: this.config.withNoData
            },
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: query.inlineParams()
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
    };
    PgView = class extends PgViewBase {
      static {
        __name(this, "PgView");
      }
      static [entityKind] = "PgView";
      [PgViewConfig];
      constructor({ pgConfig, config: config2 }) {
        super(config2);
        if (pgConfig) {
          this[PgViewConfig] = {
            with: pgConfig.with
          };
        }
      }
    };
    PgMaterializedViewConfig = Symbol.for("drizzle:PgMaterializedViewConfig");
    PgMaterializedView = class extends PgViewBase {
      static {
        __name(this, "PgMaterializedView");
      }
      static [entityKind] = "PgMaterializedView";
      [PgMaterializedViewConfig];
      constructor({ pgConfig, config: config2 }) {
        super(config2);
        this[PgMaterializedViewConfig] = {
          with: pgConfig?.with,
          using: pgConfig?.using,
          tablespace: pgConfig?.tablespace,
          withNoData: pgConfig?.withNoData
        };
      }
    };
    __name(pgViewWithSchema, "pgViewWithSchema");
    __name(pgMaterializedViewWithSchema, "pgMaterializedViewWithSchema");
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/schema.js
var PgSchema;
var init_schema = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/schema.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    init_enum();
    init_sequence();
    init_table2();
    init_view();
    PgSchema = class {
      static {
        __name(this, "PgSchema");
      }
      constructor(schemaName) {
        this.schemaName = schemaName;
      }
      static [entityKind] = "PgSchema";
      table = /* @__PURE__ */ __name((name, columns, extraConfig) => {
        return pgTableWithSchema(name, columns, extraConfig, this.schemaName);
      }, "table");
      view = /* @__PURE__ */ __name((name, columns) => {
        return pgViewWithSchema(name, columns, this.schemaName);
      }, "view");
      materializedView = /* @__PURE__ */ __name((name, columns) => {
        return pgMaterializedViewWithSchema(name, columns, this.schemaName);
      }, "materializedView");
      enum = /* @__PURE__ */ __name((name, values2) => {
        return pgEnumWithSchema(name, values2, this.schemaName);
      }, "enum");
      sequence = /* @__PURE__ */ __name((name, options2) => {
        return pgSequenceWithSchema(name, options2, this.schemaName);
      }, "sequence");
      getSQL() {
        return new SQL([sql.identifier(this.schemaName)]);
      }
      shouldOmitSQLParens() {
        return true;
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/session.js
var PgPreparedQuery, PgSession, PgTransaction;
var init_session = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/session.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_errors2();
    init_sql2();
    init_tracing();
    init_db();
    PgPreparedQuery = class {
      static {
        __name(this, "PgPreparedQuery");
      }
      constructor(query) {
        this.query = query;
      }
      authToken;
      getQuery() {
        return this.query;
      }
      mapResult(response, _isFromBatch) {
        return response;
      }
      /** @internal */
      setToken(token) {
        this.authToken = token;
        return this;
      }
      static [entityKind] = "PgPreparedQuery";
      /** @internal */
      joinsNotNullableMap;
    };
    PgSession = class {
      static {
        __name(this, "PgSession");
      }
      constructor(dialect) {
        this.dialect = dialect;
      }
      static [entityKind] = "PgSession";
      /** @internal */
      execute(query, token) {
        return tracer.startActiveSpan("drizzle.operation", () => {
          const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
            return this.prepareQuery(
              this.dialect.sqlToQuery(query),
              void 0,
              void 0,
              false
            );
          });
          return prepared.setToken(token).execute(void 0, token);
        });
      }
      all(query) {
        return this.prepareQuery(
          this.dialect.sqlToQuery(query),
          void 0,
          void 0,
          false
        ).all();
      }
      /** @internal */
      async count(sql2, token) {
        const res = await this.execute(sql2, token);
        return Number(
          res[0]["count"]
        );
      }
    };
    PgTransaction = class extends PgDatabase {
      static {
        __name(this, "PgTransaction");
      }
      constructor(dialect, session, schema2, nestedIndex = 0) {
        super(dialect, session, schema2);
        this.schema = schema2;
        this.nestedIndex = nestedIndex;
      }
      static [entityKind] = "PgTransaction";
      rollback() {
        throw new TransactionRollbackError();
      }
      /** @internal */
      getTransactionConfigSQL(config2) {
        const chunks = [];
        if (config2.isolationLevel) {
          chunks.push(`isolation level ${config2.isolationLevel}`);
        }
        if (config2.accessMode) {
          chunks.push(config2.accessMode);
        }
        if (typeof config2.deferrable === "boolean") {
          chunks.push(config2.deferrable ? "deferrable" : "not deferrable");
        }
        return sql.raw(chunks.join(" "));
      }
      setTransaction(config2) {
        return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config2)}`);
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/subquery.js
var init_subquery2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/subquery.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/utils.js
var init_utils4 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/utils/index.js
var init_utils5 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/utils/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/index.js
var init_pg_core = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/pg-core/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias2();
    init_checks();
    init_columns();
    init_db();
    init_dialect();
    init_foreign_keys();
    init_indexes();
    init_policies();
    init_primary_keys();
    init_query_builders();
    init_roles();
    init_schema();
    init_sequence();
    init_session();
    init_subquery2();
    init_table2();
    init_unique_constraint();
    init_utils4();
    init_utils5();
    init_view_common2();
    init_view();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/postgres-js/session.js
var PostgresJsPreparedQuery, PostgresJsSession, PostgresJsTransaction;
var init_session2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/postgres-js/session.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_logger();
    init_pg_core();
    init_session();
    init_sql();
    init_tracing();
    init_utils2();
    PostgresJsPreparedQuery = class extends PgPreparedQuery {
      static {
        __name(this, "PostgresJsPreparedQuery");
      }
      constructor(client2, queryString, params, logger, fields, _isResponseInArrayMode, customResultMapper) {
        super({ sql: queryString, params });
        this.client = client2;
        this.queryString = queryString;
        this.params = params;
        this.logger = logger;
        this.fields = fields;
        this._isResponseInArrayMode = _isResponseInArrayMode;
        this.customResultMapper = customResultMapper;
      }
      static [entityKind] = "PostgresJsPreparedQuery";
      async execute(placeholderValues = {}) {
        return tracer.startActiveSpan("drizzle.execute", async (span) => {
          const params = fillPlaceholders(this.params, placeholderValues);
          span?.setAttributes({
            "drizzle.query.text": this.queryString,
            "drizzle.query.params": JSON.stringify(params)
          });
          this.logger.logQuery(this.queryString, params);
          const { fields, queryString: query, client: client2, joinsNotNullableMap, customResultMapper } = this;
          if (!fields && !customResultMapper) {
            return tracer.startActiveSpan("drizzle.driver.execute", () => {
              return client2.unsafe(query, params);
            });
          }
          const rows = await tracer.startActiveSpan("drizzle.driver.execute", () => {
            span?.setAttributes({
              "drizzle.query.text": query,
              "drizzle.query.params": JSON.stringify(params)
            });
            return client2.unsafe(query, params).values();
          });
          return tracer.startActiveSpan("drizzle.mapResponse", () => {
            return customResultMapper ? customResultMapper(rows) : rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
          });
        });
      }
      all(placeholderValues = {}) {
        return tracer.startActiveSpan("drizzle.execute", async (span) => {
          const params = fillPlaceholders(this.params, placeholderValues);
          span?.setAttributes({
            "drizzle.query.text": this.queryString,
            "drizzle.query.params": JSON.stringify(params)
          });
          this.logger.logQuery(this.queryString, params);
          return tracer.startActiveSpan("drizzle.driver.execute", () => {
            span?.setAttributes({
              "drizzle.query.text": this.queryString,
              "drizzle.query.params": JSON.stringify(params)
            });
            return this.client.unsafe(this.queryString, params);
          });
        });
      }
      /** @internal */
      isResponseInArrayMode() {
        return this._isResponseInArrayMode;
      }
    };
    PostgresJsSession = class _PostgresJsSession extends PgSession {
      static {
        __name(this, "PostgresJsSession");
      }
      constructor(client2, dialect, schema2, options2 = {}) {
        super(dialect);
        this.client = client2;
        this.schema = schema2;
        this.options = options2;
        this.logger = options2.logger ?? new NoopLogger();
      }
      static [entityKind] = "PostgresJsSession";
      logger;
      prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper) {
        return new PostgresJsPreparedQuery(
          this.client,
          query.sql,
          query.params,
          this.logger,
          fields,
          isResponseInArrayMode,
          customResultMapper
        );
      }
      query(query, params) {
        this.logger.logQuery(query, params);
        return this.client.unsafe(query, params).values();
      }
      queryObjects(query, params) {
        return this.client.unsafe(query, params);
      }
      transaction(transaction, config2) {
        return this.client.begin(async (client2) => {
          const session = new _PostgresJsSession(
            client2,
            this.dialect,
            this.schema,
            this.options
          );
          const tx = new PostgresJsTransaction(this.dialect, session, this.schema);
          if (config2) {
            await tx.setTransaction(config2);
          }
          return transaction(tx);
        });
      }
    };
    PostgresJsTransaction = class _PostgresJsTransaction extends PgTransaction {
      static {
        __name(this, "PostgresJsTransaction");
      }
      constructor(dialect, session, schema2, nestedIndex = 0) {
        super(dialect, session, schema2, nestedIndex);
        this.session = session;
      }
      static [entityKind] = "PostgresJsTransaction";
      transaction(transaction) {
        return this.session.client.savepoint((client2) => {
          const session = new PostgresJsSession(
            client2,
            this.dialect,
            this.schema,
            this.session.options
          );
          const tx = new _PostgresJsTransaction(this.dialect, session, this.schema);
          return transaction(tx);
        });
      }
    };
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/postgres-js/driver.js
function construct(client2, config2 = {}) {
  const transparentParser = /* @__PURE__ */ __name((val) => val, "transparentParser");
  for (const type of ["1184", "1082", "1083", "1114"]) {
    client2.options.parsers[type] = transparentParser;
    client2.options.serializers[type] = transparentParser;
  }
  client2.options.serializers["114"] = transparentParser;
  client2.options.serializers["3802"] = transparentParser;
  const dialect = new PgDialect({ casing: config2.casing });
  let logger;
  if (config2.logger === true) {
    logger = new DefaultLogger();
  } else if (config2.logger !== false) {
    logger = config2.logger;
  }
  let schema2;
  if (config2.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config2.schema,
      createTableRelationsHelpers
    );
    schema2 = {
      fullSchema: config2.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new PostgresJsSession(client2, dialect, schema2, { logger });
  const db2 = new PostgresJsDatabase(dialect, session, schema2);
  db2.$client = client2;
  return db2;
}
function drizzle(...params) {
  if (typeof params[0] === "string") {
    const instance = src_default(params[0]);
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection: connection2, client: client2, ...drizzleConfig } = params[0];
    if (client2)
      return construct(client2, drizzleConfig);
    if (typeof connection2 === "object" && connection2.url !== void 0) {
      const { url, ...config2 } = connection2;
      const instance2 = src_default(url, config2);
      return construct(instance2, drizzleConfig);
    }
    const instance = src_default(connection2);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
var PostgresJsDatabase;
var init_driver = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/postgres-js/driver.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_src();
    init_entity();
    init_logger();
    init_db();
    init_dialect();
    init_relations();
    init_utils2();
    init_session2();
    PostgresJsDatabase = class extends PgDatabase {
      static {
        __name(this, "PostgresJsDatabase");
      }
      static [entityKind] = "PostgresJsDatabase";
    };
    __name(construct, "construct");
    __name(drizzle, "drizzle");
    ((drizzle2) => {
      function mock(config2) {
        return construct({
          options: {
            parsers: {},
            serializers: {}
          }
        }, config2);
      }
      __name(mock, "mock");
      drizzle2.mock = mock;
    })(drizzle || (drizzle = {}));
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/postgres-js/index.js
var init_postgres_js = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/postgres-js/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_driver();
    init_session2();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/expressions.js
var init_expressions2 = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/expressions.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_expressions();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/operations.js
var init_operations = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/operations.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/index.js
var init_drizzle_orm = __esm({
  "node_modules/.pnpm/drizzle-orm@0.40.1_@cloudfl_0ba89a1e6ae28d113d1d0e0660fca46f/node_modules/drizzle-orm/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias();
    init_column_builder();
    init_column();
    init_entity();
    init_errors2();
    init_expressions2();
    init_logger();
    init_operations();
    init_query_promise();
    init_relations();
    init_sql2();
    init_subquery();
    init_table();
    init_utils2();
    init_view_common();
  }
});

// .svelte-kit/output/server/chunks/schema.js
var client, db, users, tasks2, events, shoppingList, userGroups, userGroupMembers, userGroupRequests;
var init_schema2 = __esm({
  ".svelte-kit/output/server/chunks/schema.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_postgres_js();
    init_src();
    init_pg_core();
    init_drizzle_orm();
    client = src_default("postgres://postgres:7d8APF0cxR0zypsFJRtUZuFCQPVKyN4TN4wKUzqeGE5DX62etup91FgCZHn6oAVC@37.27.22.176:5430/zstart");
    db = drizzle(client);
    users = pgTable("users", {
      id: text("id").primaryKey(),
      name: text("name"),
      email: text("email"),
      password: text("password")
    });
    tasks2 = pgTable("tasks", {
      id: text("id").primaryKey(),
      name: text("name"),
      status: boolean("status"),
      createdById: text("createdById"),
      assignedToId: text("assignedToId")
    });
    events = pgTable("events", {
      id: text("id").primaryKey(),
      name: text("name"),
      datetime: integer("datetime"),
      timezone: text("timezone"),
      createdById: text("createdById"),
      assignedToId: text("assignedToId")
    });
    shoppingList = pgTable("shoppingList", {
      id: text("id").primaryKey(),
      name: text("name"),
      status: boolean("status"),
      createdById: text("createdById"),
      assignedToId: text("assignedToId")
    });
    userGroups = pgTable("userGroups", {
      id: text("id").primaryKey(),
      name: text("name"),
      createdById: text("createdById")
    });
    userGroupMembers = pgTable("userGroupMembers", {
      id: text("id").primaryKey(),
      userId: text("userId"),
      userGroupId: text("userGroupId")
    });
    userGroupRequests = pgTable("userGroupRequests", {
      id: text("id").primaryKey(),
      email: text("email"),
      userGroupId: text("userGroupId"),
      status: boolean("status"),
      sentByEmail: text("sentByEmail"),
      groupName: text("groupName")
    });
    relations(users, ({ many: many2 }) => ({
      createdTasks: many2(tasks2, { relationName: "createdById" }),
      assignedTasks: many2(tasks2, { relationName: "assignedToId" })
    }));
    relations(tasks2, ({ one: one2, many: many2 }) => ({
      createdBy: one2(users, {
        fields: [tasks2.createdById],
        references: [users.id],
        relationName: "createdById"
      }),
      assignedTo: one2(users, {
        fields: [tasks2.assignedToId],
        references: [users.id],
        relationName: "assignedToId"
      })
    }));
    relations(events, ({ one: one2 }) => ({
      createdBy: one2(users, {
        fields: [events.createdById],
        references: [users.id]
      }),
      assignedTo: one2(users, {
        fields: [events.assignedToId],
        references: [users.id]
      })
    }));
    relations(shoppingList, ({ one: one2 }) => ({
      createdBy: one2(users, {
        fields: [shoppingList.createdById],
        references: [users.id]
      }),
      assignedTo: one2(users, {
        fields: [shoppingList.assignedToId],
        references: [users.id]
      })
    }));
    relations(userGroups, ({ one: one2 }) => ({
      createdBy: one2(users, {
        fields: [userGroups.createdById],
        references: [users.id]
      })
    }));
    relations(userGroupMembers, ({ one: one2 }) => ({
      user: one2(users, {
        fields: [userGroupMembers.userId],
        references: [users.id]
      }),
      userGroup: one2(userGroups, {
        fields: [userGroupMembers.userGroupId],
        references: [userGroups.id]
      })
    }));
    relations(userGroupRequests, ({ one: one2 }) => ({
      createdBy: one2(users, {
        fields: [userGroupRequests.sentByEmail],
        references: [users.id]
      }),
      userGroup: one2(userGroups, {
        fields: [userGroupRequests.userGroupId],
        references: [userGroups.id]
      })
    }));
  }
});

// .svelte-kit/output/server/chunks/hooks.server.js
var hooks_server_exports = {};
__export(hooks_server_exports, {
  getSession: () => getSession,
  handle: () => handle
});
async function handle({
  event,
  resolve: resolve2
}) {
  const { headers: headers2 } = event.request;
  const cookies = (0, import_cookie.parse)(headers2.get("cookie") ?? "");
  if (cookies.session) {
    const token = cookies.session;
    try {
      const jwtUser = verify2(token, "437baa87d7b1834b2b201dc242d60dace1fe4fa46a4d9483771f6a1492f200b412fbb27297e31ab07be1ea5be8fcfada87a8237408ebc7af13e257402c0afe36");
      if (typeof jwtUser === "string") {
        throw new Error("Something went wrong");
      }
      const account = await db.select().from(users).where(eq(users.email, jwtUser.user)).execute();
      if (!account[0]) {
        throw new Error("User not found");
      }
      const group3 = await db.select().from(userGroupMembers).where(eq(userGroupMembers.userId, account[0].id)).execute();
      console.log("run group query");
      let groupId = group3[0]?.userGroupId;
      if (!groupId) {
        groupId = "0";
      }
      const sessionUser = {
        id: account[0].id,
        email: account[0].email,
        groupId
      };
      event.locals.user = sessionUser;
    } catch (error3) {
      console.error(error3);
    }
  } else {
    event.locals.user = null;
  }
  return await resolve2(event);
}
async function getSession({ locals }) {
  return {
    user: locals.user
  };
}
var import_cookie, import_jsonwebtoken, verify2;
var init_hooks_server = __esm({
  ".svelte-kit/output/server/chunks/hooks.server.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    import_cookie = __toESM(require_dist(), 1);
    import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
    init_schema2();
    init_drizzle_orm();
    ({ verify: verify2 } = import_jsonwebtoken.default);
    __name(handle, "handle");
    __name(getSession, "getSession");
  }
});

// .svelte-kit/output/server/chunks/index.js
function redirect(status, location2) {
  if (isNaN(status) || status < 300 || status > 308) {
    throw new Error("Invalid status code");
  }
  throw new Redirect(
    // @ts-ignore
    status,
    location2.toString()
  );
}
function json2(data, init2) {
  const body2 = JSON.stringify(data);
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    headers2.set("content-length", encoder.encode(body2).byteLength.toString());
  }
  if (!headers2.has("content-type")) {
    headers2.set("content-type", "application/json");
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
function text2(body2, init2) {
  const headers2 = new Headers(init2?.headers);
  if (!headers2.has("content-length")) {
    const encoded = encoder.encode(body2);
    headers2.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init2,
      headers: headers2
    });
  }
  return new Response(body2, {
    ...init2,
    headers: headers2
  });
}
var HttpError, Redirect, SvelteKitError, ActionFailure, encoder;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    HttpError = class {
      static {
        __name(this, "HttpError");
      }
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body2) {
        this.status = status;
        if (typeof body2 === "string") {
          this.body = { message: body2 };
        } else if (body2) {
          this.body = body2;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      static {
        __name(this, "Redirect");
      }
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location2) {
        this.status = status;
        this.location = location2;
      }
    };
    SvelteKitError = class extends Error {
      static {
        __name(this, "SvelteKitError");
      }
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text22, message) {
        super(message);
        this.status = status;
        this.text = text22;
      }
    };
    ActionFailure = class {
      static {
        __name(this, "ActionFailure");
      }
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
    __name(redirect, "redirect");
    __name(json2, "json");
    encoder = new TextEncoder();
    __name(text2, "text");
  }
});

// .svelte-kit/output/server/chunks/exports.js
function resolve(base2, path2) {
  if (path2[0] === "/" && path2[1] === "/") return path2;
  let url = new URL(base2, internal);
  url = new URL(path2, url);
  return url.protocol === internal.protocol ? url.pathname + url.search + url.hash : url.href;
}
function normalize_path(path2, trailing_slash) {
  if (path2 === "/" || trailing_slash === "ignore") return path2;
  if (trailing_slash === "never") {
    return path2.endsWith("/") ? path2.slice(0, -1) : path2;
  } else if (trailing_slash === "always" && !path2.endsWith("/")) {
    return path2 + "/";
  }
  return path2;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = decodeURIComponent(params[key2]);
  }
  return params;
}
function make_trackable(url, callback, search_params_callback, allow_hash = false) {
  const tracked = new URL(url);
  Object.defineProperty(tracked, "searchParams", {
    value: new Proxy(tracked.searchParams, {
      get(obj, key2) {
        if (key2 === "get" || key2 === "getAll" || key2 === "has") {
          return (param) => {
            search_params_callback(param);
            return obj[key2](param);
          };
        }
        callback();
        const value = Reflect.get(obj, key2);
        return typeof value === "function" ? value.bind(obj) : value;
      }
    }),
    enumerable: true,
    configurable: true
  });
  const tracked_url_properties = ["href", "pathname", "search", "toString", "toJSON"];
  if (allow_hash) tracked_url_properties.push("hash");
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect2) => {
      return inspect2(url, opts);
    };
    tracked.searchParams[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect2) => {
      return inspect2(url.searchParams, opts);
    };
  }
  if (!allow_hash) {
    disable_hash(tracked);
  }
  return tracked;
}
function disable_hash(url) {
  allow_nodejs_console_log(url);
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `page.url.hash` inside a component instead"
      );
    }
  });
}
function disable_search(url) {
  allow_nodejs_console_log(url);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
function allow_nodejs_console_log(url) {
  {
    url[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect2) => {
      return inspect2(new URL(url), opts);
    };
  }
}
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  __name(set2, "set");
  function update(fn) {
    set2(fn(
      /** @type {T} */
      value
    ));
  }
  __name(update, "update");
  function subscribe(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update) || noop;
    }
    run2(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  __name(subscribe, "subscribe");
  return { set: set2, update, subscribe };
}
function validator(expected) {
  function validate(module, file) {
    if (!module) return;
    for (const key2 in module) {
      if (key2[0] === "_" || expected.has(key2)) continue;
      const values2 = [...expected.values()];
      const hint = hint_for_supported_files(key2, file?.slice(file.lastIndexOf("."))) ?? `valid exports are ${values2.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key2}'${file ? ` in ${file}` : ""} (${hint})`);
    }
  }
  __name(validate, "validate");
  return validate;
}
function hint_for_supported_files(key2, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key2)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key2)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key2)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key2)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key2)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key2}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
var internal, subscriber_queue, valid_layout_exports, valid_page_exports, valid_layout_server_exports, valid_page_server_exports, valid_server_exports, validate_layout_exports, validate_page_exports, validate_layout_server_exports, validate_page_server_exports, validate_server_exports;
var init_exports = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_equality();
    init_clsx();
    internal = new URL("sveltekit-internal://");
    __name(resolve, "resolve");
    __name(normalize_path, "normalize_path");
    __name(decode_pathname, "decode_pathname");
    __name(decode_params, "decode_params");
    __name(make_trackable, "make_trackable");
    __name(disable_hash, "disable_hash");
    __name(disable_search, "disable_search");
    __name(allow_nodejs_console_log, "allow_nodejs_console_log");
    subscriber_queue = [];
    __name(readable, "readable");
    __name(writable, "writable");
    __name(validator, "validator");
    __name(hint_for_supported_files, "hint_for_supported_files");
    valid_layout_exports = /* @__PURE__ */ new Set([
      "load",
      "prerender",
      "csr",
      "ssr",
      "trailingSlash",
      "config"
    ]);
    valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
    valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
    valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
    valid_server_exports = /* @__PURE__ */ new Set([
      "GET",
      "POST",
      "PATCH",
      "PUT",
      "DELETE",
      "OPTIONS",
      "HEAD",
      "fallback",
      "prerender",
      "trailingSlash",
      "config",
      "entries"
    ]);
    validate_layout_exports = validator(valid_layout_exports);
    validate_page_exports = validator(valid_page_exports);
    validate_layout_server_exports = validator(valid_layout_server_exports);
    validate_page_server_exports = validator(valid_page_server_exports);
    validate_server_exports = validator(valid_server_exports);
  }
});

// ../node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "../node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    __name(isNonEmptyString, "isNonEmptyString");
    function parseString2(setCookieValue, options2) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      try {
        value = options2.decodeValues ? decodeURIComponent(value) : value;
      } catch (e3) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e3
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key2 = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key2 === "expires") {
          cookie.expires = new Date(value2);
        } else if (key2 === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key2 === "secure") {
          cookie.secure = true;
        } else if (key2 === "httponly") {
          cookie.httpOnly = true;
        } else if (key2 === "samesite") {
          cookie.sameSite = value2;
        } else if (key2 === "partitioned") {
          cookie.partitioned = true;
        } else {
          cookie[key2] = value2;
        }
      });
      return cookie;
    }
    __name(parseString2, "parseString");
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    __name(parseNameValuePair, "parseNameValuePair");
    function parse5(input, options2) {
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!input) {
        if (!options2.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key2) {
            return key2.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options2.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options2.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString2(str, options2);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString2(str, options2);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    __name(parse5, "parse");
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      __name(skipWhitespace, "skipWhitespace");
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      __name(notSpecialChar, "notSpecialChar");
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    __name(splitCookiesString2, "splitCookiesString");
    module.exports = parse5;
    module.exports.parse = parse5;
    module.exports.parseString = parseString2;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/async_hooks/async-hook.mjs
var kInit, kBefore, kAfter, kDestroy, kPromiseResolve, _AsyncHook, createHook, executionAsyncId, executionAsyncResource, triggerAsyncId, asyncWrapProviders;
var init_async_hook = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/internal/async_hooks/async-hook.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    kInit = /* @__PURE__ */ Symbol("init");
    kBefore = /* @__PURE__ */ Symbol("before");
    kAfter = /* @__PURE__ */ Symbol("after");
    kDestroy = /* @__PURE__ */ Symbol("destroy");
    kPromiseResolve = /* @__PURE__ */ Symbol("promiseResolve");
    _AsyncHook = class {
      static {
        __name(this, "_AsyncHook");
      }
      __unenv__ = true;
      _enabled = false;
      _callbacks = {};
      constructor(callbacks = {}) {
        this._callbacks = callbacks;
      }
      enable() {
        this._enabled = true;
        return this;
      }
      disable() {
        this._enabled = false;
        return this;
      }
      get [kInit]() {
        return this._callbacks.init;
      }
      get [kBefore]() {
        return this._callbacks.before;
      }
      get [kAfter]() {
        return this._callbacks.after;
      }
      get [kDestroy]() {
        return this._callbacks.destroy;
      }
      get [kPromiseResolve]() {
        return this._callbacks.promiseResolve;
      }
    };
    createHook = /* @__PURE__ */ __name(function createHook2(callbacks) {
      const asyncHook = new _AsyncHook(callbacks);
      return asyncHook;
    }, "createHook");
    executionAsyncId = /* @__PURE__ */ __name(function executionAsyncId2() {
      return 0;
    }, "executionAsyncId");
    executionAsyncResource = /* @__PURE__ */ __name(function() {
      return /* @__PURE__ */ Object.create(null);
    }, "executionAsyncResource");
    triggerAsyncId = /* @__PURE__ */ __name(function() {
      return 0;
    }, "triggerAsyncId");
    asyncWrapProviders = Object.assign(/* @__PURE__ */ Object.create(null), {
      NONE: 0,
      DIRHANDLE: 1,
      DNSCHANNEL: 2,
      ELDHISTOGRAM: 3,
      FILEHANDLE: 4,
      FILEHANDLECLOSEREQ: 5,
      BLOBREADER: 6,
      FSEVENTWRAP: 7,
      FSREQCALLBACK: 8,
      FSREQPROMISE: 9,
      GETADDRINFOREQWRAP: 10,
      GETNAMEINFOREQWRAP: 11,
      HEAPSNAPSHOT: 12,
      HTTP2SESSION: 13,
      HTTP2STREAM: 14,
      HTTP2PING: 15,
      HTTP2SETTINGS: 16,
      HTTPINCOMINGMESSAGE: 17,
      HTTPCLIENTREQUEST: 18,
      JSSTREAM: 19,
      JSUDPWRAP: 20,
      MESSAGEPORT: 21,
      PIPECONNECTWRAP: 22,
      PIPESERVERWRAP: 23,
      PIPEWRAP: 24,
      PROCESSWRAP: 25,
      PROMISE: 26,
      QUERYWRAP: 27,
      QUIC_ENDPOINT: 28,
      QUIC_LOGSTREAM: 29,
      QUIC_PACKET: 30,
      QUIC_SESSION: 31,
      QUIC_STREAM: 32,
      QUIC_UDP: 33,
      SHUTDOWNWRAP: 34,
      SIGNALWRAP: 35,
      STATWATCHER: 36,
      STREAMPIPE: 37,
      TCPCONNECTWRAP: 38,
      TCPSERVERWRAP: 39,
      TCPWRAP: 40,
      TTYWRAP: 41,
      UDPSENDWRAP: 42,
      UDPWRAP: 43,
      SIGINTWATCHDOG: 44,
      WORKER: 45,
      WORKERHEAPSNAPSHOT: 46,
      WRITEWRAP: 47,
      ZLIB: 48,
      CHECKPRIMEREQUEST: 49,
      PBKDF2REQUEST: 50,
      KEYPAIRGENREQUEST: 51,
      KEYGENREQUEST: 52,
      KEYEXPORTREQUEST: 53,
      CIPHERREQUEST: 54,
      DERIVEBITSREQUEST: 55,
      HASHREQUEST: 56,
      RANDOMBYTESREQUEST: 57,
      RANDOMPRIMEREQUEST: 58,
      SCRYPTREQUEST: 59,
      SIGNREQUEST: 60,
      TLSWRAP: 61,
      VERIFYREQUEST: 62
    });
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/async_hooks.mjs
var init_async_hooks = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.17/node_modules/unenv/dist/runtime/node/async_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_async_hook();
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/async_hooks.mjs
var async_hooks_exports = {};
__export(async_hooks_exports, {
  AsyncLocalStorage: () => AsyncLocalStorage,
  AsyncResource: () => AsyncResource,
  asyncWrapProviders: () => asyncWrapProviders,
  createHook: () => createHook,
  default: () => async_hooks_default,
  executionAsyncId: () => executionAsyncId,
  executionAsyncResource: () => executionAsyncResource,
  triggerAsyncId: () => triggerAsyncId
});
var workerdAsyncHooks, AsyncLocalStorage, AsyncResource, async_hooks_default;
var init_async_hooks2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2._5f2d861fa89db1b5e8f5abcc852f7b5a/node_modules/@cloudflare/unenv-preset/dist/runtime/node/async_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_async_hooks();
    init_async_hooks();
    workerdAsyncHooks = process.getBuiltinModule("node:async_hooks");
    ({ AsyncLocalStorage, AsyncResource } = workerdAsyncHooks);
    async_hooks_default = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      asyncWrapProviders,
      createHook,
      executionAsyncId,
      executionAsyncResource,
      triggerAsyncId,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      AsyncLocalStorage,
      AsyncResource
    };
  }
});

// node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-5X3DESC6.js
function parseTTL(ttl) {
  if (typeof ttl === "number") {
    return Number.isNaN(ttl) ? 0 : !Number.isFinite(ttl) || ttl < 0 ? -1 : ttl;
  }
  if (ttl === "none") {
    return 0;
  }
  if (ttl === "forever") {
    return -1;
  }
  const multi = multiplier[ttl[ttl.length - 1]];
  return Number(ttl.slice(0, -1)) * multi;
}
function compareTTL(a, b2) {
  const ap = parseTTL(a);
  const bp = parseTTL(b2);
  if (ap === -1 && bp !== -1) {
    return 1;
  }
  if (ap !== -1 && bp === -1) {
    return -1;
  }
  return ap - bp;
}
var DEFAULT_TTL, multiplier, objectPrototypeHasOwnProperty, hasOwn;
var init_chunk_5X3DESC6 = __esm({
  "node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-5X3DESC6.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    DEFAULT_TTL = "none";
    multiplier = {
      s: 1e3,
      m: 60 * 1e3,
      h: 60 * 60 * 1e3,
      d: 24 * 60 * 60 * 1e3,
      y: 365 * 24 * 60 * 60 * 1e3
    };
    __name(parseTTL, "parseTTL");
    __name(compareTTL, "compareTTL");
    objectPrototypeHasOwnProperty = Object.prototype.hasOwnProperty;
    hasOwn = Object.hasOwn || ((object2, key2) => objectPrototypeHasOwnProperty.call(object2, key2));
  }
});

// node_modules/.pnpm/compare-utf8@0.1.1/node_modules/compare-utf8/src/index.js
function compareUTF8(a, b2) {
  const aLength = a.length;
  const bLength = b2.length;
  const length = Math.min(aLength, bLength);
  for (let i = 0; i < length; ) {
    const aCodePoint = (
      /** @type {number} */
      a.codePointAt(i)
    );
    const bCodePoint = (
      /** @type {number} */
      b2.codePointAt(i)
    );
    if (aCodePoint !== bCodePoint) {
      if (aCodePoint < 128 && bCodePoint < 128) {
        return aCodePoint - bCodePoint;
      }
      const aLength2 = utf8Bytes(aCodePoint, aBytes);
      const bLength2 = utf8Bytes(bCodePoint, bBytes);
      return compareArrays(aBytes, aLength2, bBytes, bLength2);
    }
    i += utf16LengthForCodePoint(aCodePoint);
  }
  return aLength - bLength;
}
function compareArrays(a, aLength, b2, bLength) {
  const length = Math.min(aLength, bLength);
  for (let i = 0; i < length; i++) {
    const aValue = a[i];
    const bValue = b2[i];
    if (aValue !== bValue) {
      return aValue - bValue;
    }
  }
  return aLength - bLength;
}
function utf16LengthForCodePoint(aCodePoint) {
  return aCodePoint > 65535 ? 2 : 1;
}
function utf8Bytes(codePoint, bytes) {
  if (codePoint < 128) {
    bytes[0] = codePoint;
    return 1;
  }
  let count3;
  let offset;
  if (codePoint <= 2047) {
    count3 = 1;
    offset = 192;
  } else if (codePoint <= 65535) {
    count3 = 2;
    offset = 224;
  } else if (codePoint <= 1114111) {
    count3 = 3;
    offset = 240;
  } else {
    throw new Error("Invalid code point");
  }
  bytes[0] = (codePoint >> 6 * count3) + offset;
  let i = 1;
  for (; count3 > 0; count3--) {
    const temp = codePoint >> 6 * (count3 - 1);
    bytes[i++] = 128 | temp & 63;
  }
  return i;
}
function greaterThan(a, b2) {
  return compareUTF8(a, b2) > 0;
}
function lessThan(a, b2) {
  return compareUTF8(a, b2) < 0;
}
function lessThanEq(a, b2) {
  return compareUTF8(a, b2) <= 0;
}
var arr, aBytes, bBytes;
var init_src2 = __esm({
  "node_modules/.pnpm/compare-utf8@0.1.1/node_modules/compare-utf8/src/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(compareUTF8, "compareUTF8");
    __name(compareArrays, "compareArrays");
    __name(utf16LengthForCodePoint, "utf16LengthForCodePoint");
    arr = /* @__PURE__ */ __name(() => Array.from({ length: 4 }, () => 0), "arr");
    aBytes = arr();
    bBytes = arr();
    __name(utf8Bytes, "utf8Bytes");
    __name(greaterThan, "greaterThan");
    __name(lessThan, "lessThan");
    __name(lessThanEq, "lessThanEq");
  }
});

// node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-MJCITZ5S.js
function assert3(b2, msg = "Assertion failed") {
  if (!b2) {
    throw new Error(typeof msg === "string" ? msg : msg());
  }
}
function assertString(v) {
  assertType(v, "string");
}
function assertNumber(v) {
  assertType(v, "number");
}
function assertBoolean(v) {
  assertType(v, "boolean");
}
function assertType(v, t3) {
  if (typeof v !== t3) {
    throwInvalidType(v, t3);
  }
}
function assertObject(v) {
  if (v === null) {
    throwInvalidType(v, "object");
  }
  assertType(v, "object");
}
function assertArray(v) {
  if (!Array.isArray(v)) {
    throwInvalidType(v, "array");
  }
}
function invalidType(v, t3) {
  let s3 = "Invalid type: ";
  if (v === null || v === void 0) {
    s3 += v;
  } else {
    s3 += `${typeof v} \`${v}\``;
  }
  return s3 + `, expected ${t3}`;
}
function throwInvalidType(v, t3) {
  throw new Error(invalidType(v, t3));
}
function assertNotNull(v) {
  if (v === null) {
    throw new Error("Expected non-null value");
  }
}
function unreachable(_) {
  throw new Error("Unreachable");
}
function must(v, msg) {
  if (v == null) {
    throw new Error(msg ?? `Unexpected ${v} value`);
  }
  return v;
}
function compareValues(a, b2) {
  a = normalizeUndefined(a);
  b2 = normalizeUndefined(b2);
  if (a === b2) {
    return 0;
  }
  if (a === null) {
    return -1;
  }
  if (b2 === null) {
    return 1;
  }
  if (typeof a === "boolean") {
    assertBoolean(b2);
    return a ? 1 : -1;
  }
  if (typeof a === "number") {
    assertNumber(b2);
    return a - b2;
  }
  if (typeof a === "string") {
    assertString(b2);
    return compareUTF8(a, b2);
  }
  throw new Error(`Unsupported type: ${a}`);
}
function normalizeUndefined(v) {
  return v ?? null;
}
function makeComparator(order, reverse) {
  return (a, b2) => {
    for (const ord of order) {
      const field = ord[0];
      const comp = compareValues(a[field], b2[field]);
      if (comp !== 0) {
        const result = ord[1] === "asc" ? comp : -comp;
        return reverse ? -result : result;
      }
    }
    return 0;
  };
}
function valuesEqual(a, b2) {
  if (a == null || b2 == null) {
    return false;
  }
  return a === b2;
}
function drainStreams(node) {
  for (const stream of Object.values(node.relationships)) {
    for (const node2 of stream()) {
      drainStreams(node2);
    }
  }
}
function applyChange(parentEntry, change, schema2, relationship, format2) {
  if (schema2.isHidden) {
    switch (change.type) {
      case "add":
      case "remove":
        for (const [relationship2, children] of Object.entries(
          change.node.relationships
        )) {
          const childSchema = must(schema2.relationships[relationship2]);
          for (const node of children()) {
            applyChange(
              parentEntry,
              { type: change.type, node },
              childSchema,
              relationship2,
              format2
            );
          }
        }
        return;
      case "edit":
        return;
      case "child": {
        const childSchema = must(
          schema2.relationships[change.child.relationshipName]
        );
        applyChange(
          parentEntry,
          change.child.change,
          childSchema,
          relationship,
          format2
        );
        return;
      }
      default:
        unreachable(change);
    }
  }
  const { singular, relationships: childFormats } = format2;
  switch (change.type) {
    case "add": {
      let newEntry;
      let rc = 1;
      if (singular) {
        const oldEntry = parentEntry[relationship];
        if (oldEntry !== void 0) {
          assert3(
            schema2.compareRows(oldEntry, change.node.row) === 0,
            "single output already exists"
          );
          rc = oldEntry[refCountSymbol] + 1;
        }
        newEntry = makeNewEntryWithRefCount(change.node.row, rc);
        parentEntry[relationship] = newEntry;
      } else {
        newEntry = makeNewEntryAndInsert(
          change.node.row,
          getChildEntryList(parentEntry, relationship),
          schema2.compareRows
        );
      }
      for (const [relationship2, children] of Object.entries(
        change.node.relationships
      )) {
        const childSchema = must(schema2.relationships[relationship2]);
        const childFormat = childFormats[relationship2];
        if (childFormat === void 0) {
          continue;
        }
        const newView = childFormat.singular ? void 0 : [];
        newEntry[relationship2] = newView;
        for (const node of children()) {
          applyChange(
            newEntry,
            { type: "add", node },
            childSchema,
            relationship2,
            childFormat
          );
        }
      }
      break;
    }
    case "remove": {
      if (singular) {
        const oldEntry = parentEntry[relationship];
        assert3(oldEntry !== void 0, "node does not exist");
        const rc = oldEntry[refCountSymbol];
        if (rc === 1) {
          parentEntry[relationship] = void 0;
        }
        oldEntry[refCountSymbol]--;
      } else {
        removeAndUpdateRefCount(
          getChildEntryList(parentEntry, relationship),
          change.node.row,
          schema2.compareRows
        );
      }
      drainStreams(change.node);
      break;
    }
    case "child": {
      let existing;
      if (singular) {
        existing = getSingularEntry(parentEntry, relationship);
      } else {
        const view = getChildEntryList(parentEntry, relationship);
        const { pos, found } = binarySearch(
          view,
          change.node.row,
          schema2.compareRows
        );
        assert3(found, "node does not exist");
        existing = view[pos];
      }
      const childSchema = must(
        schema2.relationships[change.child.relationshipName]
      );
      const childFormat = format2.relationships[change.child.relationshipName];
      if (childFormat !== void 0) {
        applyChange(
          existing,
          change.child.change,
          childSchema,
          change.child.relationshipName,
          childFormat
        );
      }
      break;
    }
    case "edit": {
      if (singular) {
        const existing = parentEntry[relationship];
        assertRCEntry(existing);
        const rc = existing[refCountSymbol];
        const newEntry = {
          ...existing,
          ...change.node.row,
          [refCountSymbol]: rc
        };
        existing[refCountSymbol] = 0;
        parentEntry[relationship] = newEntry;
      } else {
        const view = getChildEntryList(parentEntry, relationship);
        if (schema2.compareRows(change.oldNode.row, change.node.row) === 0) {
          const { pos, found } = binarySearch(
            view,
            change.oldNode.row,
            schema2.compareRows
          );
          assert3(found, "node does not exist");
          const oldEntry = view[pos];
          const rc = oldEntry[refCountSymbol];
          oldEntry[refCountSymbol] = 0;
          const newEntry = makeEntryPreserveRelationships(
            change.node.row,
            oldEntry,
            format2.relationships,
            rc
          );
          view[pos] = newEntry;
        } else {
          const oldEntry = removeAndUpdateRefCount(
            view,
            change.oldNode.row,
            schema2.compareRows
          );
          insertAndSetRefCount(
            view,
            change.node.row,
            oldEntry,
            format2.relationships,
            schema2.compareRows
          );
        }
      }
      break;
    }
    default:
      unreachable(change);
  }
}
function makeNewEntryAndInsert(newRow, view, compareRows) {
  const { pos, found } = binarySearch(view, newRow, compareRows);
  let deleteCount = 0;
  let rc = 1;
  if (found) {
    deleteCount = 1;
    rc = view[pos][refCountSymbol];
    view[pos][refCountSymbol] = rc - 1;
    rc++;
  }
  const newEntry = makeNewEntryWithRefCount(newRow, rc);
  view.splice(pos, deleteCount, newEntry);
  return newEntry;
}
function insertAndSetRefCount(view, newRow, oldEntry, relationships2, compareRows) {
  const { pos, found } = binarySearch(view, newRow, compareRows);
  let deleteCount = 0;
  let rc = 1;
  if (found) {
    deleteCount = 1;
    const oldEntry2 = view[pos];
    rc = oldEntry2[refCountSymbol] + 1;
    oldEntry2[refCountSymbol] = 0;
  }
  const newEntry = makeEntryPreserveRelationships(
    newRow,
    oldEntry,
    relationships2,
    rc
  );
  view.splice(pos, deleteCount, newEntry);
}
function removeAndUpdateRefCount(view, row, compareRows) {
  const { pos, found } = binarySearch(view, row, compareRows);
  assert3(found, "node does not exist");
  const oldEntry = view[pos];
  const rc = oldEntry[refCountSymbol];
  if (rc === 1) {
    view.splice(pos, 1);
  }
  oldEntry[refCountSymbol]--;
  return oldEntry;
}
function binarySearch(view, target, comparator2) {
  let low = 0;
  let high = view.length - 1;
  while (low <= high) {
    const mid = low + high >>> 1;
    const comparison = comparator2(view[mid], target);
    if (comparison < 0) {
      low = mid + 1;
    } else if (comparison > 0) {
      high = mid - 1;
    } else {
      return { pos: mid, found: true };
    }
  }
  return { pos: low, found: false };
}
function makeEntryPreserveRelationships(newRow, oldEntry, relationships2, rc) {
  const entry = makeNewEntryWithRefCount(newRow, rc);
  for (const relationship in relationships2) {
    assert3(!(relationship in newRow), "Relationship already exists");
    entry[relationship] = oldEntry[relationship];
  }
  return entry;
}
function getChildEntryList(parentEntry, relationship) {
  const view = parentEntry[relationship];
  assertArray(view);
  return view;
}
function assertRCEntry(v) {
  assertNumber(v[refCountSymbol]);
}
function getSingularEntry(parentEntry, relationship) {
  const e3 = parentEntry[relationship];
  assertNumber(e3[refCountSymbol]);
  return e3;
}
function makeNewEntryWithRefCount(row, rc) {
  return { ...row, [refCountSymbol]: rc };
}
var refCountSymbol;
var init_chunk_MJCITZ5S = __esm({
  "node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-MJCITZ5S.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_src2();
    __name(assert3, "assert");
    __name(assertString, "assertString");
    __name(assertNumber, "assertNumber");
    __name(assertBoolean, "assertBoolean");
    __name(assertType, "assertType");
    __name(assertObject, "assertObject");
    __name(assertArray, "assertArray");
    __name(invalidType, "invalidType");
    __name(throwInvalidType, "throwInvalidType");
    __name(assertNotNull, "assertNotNull");
    __name(unreachable, "unreachable");
    __name(must, "must");
    __name(compareValues, "compareValues");
    __name(normalizeUndefined, "normalizeUndefined");
    __name(makeComparator, "makeComparator");
    __name(valuesEqual, "valuesEqual");
    __name(drainStreams, "drainStreams");
    refCountSymbol = Symbol("rc");
    __name(applyChange, "applyChange");
    __name(makeNewEntryAndInsert, "makeNewEntryAndInsert");
    __name(insertAndSetRefCount, "insertAndSetRefCount");
    __name(removeAndUpdateRefCount, "removeAndUpdateRefCount");
    __name(binarySearch, "binarySearch");
    __name(makeEntryPreserveRelationships, "makeEntryPreserveRelationships");
    __name(getChildEntryList, "getChildEntryList");
    __name(assertRCEntry, "assertRCEntry");
    __name(getSingularEntry, "getSingularEntry");
    __name(makeNewEntryWithRefCount, "makeNewEntryWithRefCount");
  }
});

// node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-424PT5DM.js
var __defProp2, __getOwnPropDesc2, __getOwnPropNames2, __hasOwnProp2, __export2, __copyProps2, __reExport;
var init_chunk_424PT5DM = __esm({
  "node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-424PT5DM.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __defProp2 = Object.defineProperty;
    __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    __getOwnPropNames2 = Object.getOwnPropertyNames;
    __hasOwnProp2 = Object.prototype.hasOwnProperty;
    __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    }, "__export");
    __copyProps2 = /* @__PURE__ */ __name((to, from, except2, desc2) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except2)
            __defProp2(to, key2, { get: /* @__PURE__ */ __name(() => from[key2], "get"), enumerable: !(desc2 = __getOwnPropDesc2(from, key2)) || desc2.enumerable });
      }
      return to;
    }, "__copyProps");
    __reExport = /* @__PURE__ */ __name((target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default")), "__reExport");
  }
});

// node_modules/.pnpm/@rocicorp+resolver@1.0.2/node_modules/@rocicorp/resolver/out/resolver.js
function resolver() {
  let resolve2;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve2 = res;
    reject = rej;
  });
  return { promise, resolve: resolve2, reject };
}
var init_resolver = __esm({
  "node_modules/.pnpm/@rocicorp+resolver@1.0.2/node_modules/@rocicorp/resolver/out/resolver.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(resolver, "resolver");
  }
});

// node_modules/.pnpm/@badrap+valita@0.3.11/node_modules/@badrap/valita/dist/mjs/index.mjs
var mjs_exports = {};
__export(mjs_exports, {
  ValitaError: () => ValitaError,
  array: () => array2,
  bigint: () => bigint3,
  boolean: () => boolean2,
  err: () => err,
  lazy: () => lazy,
  literal: () => literal,
  never: () => never,
  null: () => null_,
  number: () => number,
  object: () => object,
  ok: () => ok,
  record: () => record,
  string: () => string,
  tuple: () => tuple,
  undefined: () => undefined_,
  union: () => union2,
  unknown: () => unknown
});
function joinIssues(left, right) {
  return left ? { ok: false, code: "join", left, right } : right;
}
function prependPath(key2, tree) {
  return { ok: false, code: "prepend", key: key2, tree };
}
function cloneIssueWithPath(tree, path2) {
  const code = tree.code;
  switch (code) {
    case "invalid_type":
      return { code, path: path2, expected: tree.expected };
    case "invalid_literal":
      return { code, path: path2, expected: tree.expected };
    case "missing_value":
      return { code, path: path2 };
    case "invalid_length":
      return {
        code,
        path: path2,
        minLength: tree.minLength,
        maxLength: tree.maxLength
      };
    case "unrecognized_keys":
      return { code, path: path2, keys: tree.keys };
    case "invalid_union":
      return { code, path: path2, tree: tree.tree };
    default:
      return { code, path: path2, error: tree.error };
  }
}
function collectIssues(tree, path2 = [], issues = []) {
  for (; ; ) {
    if (tree.code === "join") {
      collectIssues(tree.left, path2.slice(), issues);
      tree = tree.right;
    } else if (tree.code === "prepend") {
      path2.push(tree.key);
      tree = tree.tree;
    } else {
      if (tree.code === "custom_error" && typeof tree.error === "object" && tree.error.path !== void 0) {
        path2.push(...tree.error.path);
      }
      issues.push(cloneIssueWithPath(tree, path2));
      return issues;
    }
  }
}
function separatedList(list, sep) {
  if (list.length === 0) {
    return "nothing";
  } else if (list.length === 1) {
    return list[0];
  } else {
    return `${list.slice(0, -1).join(", ")} ${sep} ${list[list.length - 1]}`;
  }
}
function formatLiteral(value) {
  return typeof value === "bigint" ? `${value}n` : JSON.stringify(value);
}
function countIssues(tree) {
  let count3 = 0;
  for (; ; ) {
    if (tree.code === "join") {
      count3 += countIssues(tree.left);
      tree = tree.right;
    } else if (tree.code === "prepend") {
      tree = tree.tree;
    } else {
      return count3 + 1;
    }
  }
}
function formatIssueTree(tree) {
  let path2 = "";
  let count3 = 0;
  for (; ; ) {
    if (tree.code === "join") {
      count3 += countIssues(tree.right);
      tree = tree.left;
    } else if (tree.code === "prepend") {
      path2 += "." + tree.key;
      tree = tree.tree;
    } else {
      break;
    }
  }
  let message = "validation failed";
  if (tree.code === "invalid_type") {
    message = `expected ${separatedList(tree.expected, "or")}`;
  } else if (tree.code === "invalid_literal") {
    message = `expected ${separatedList(tree.expected.map(formatLiteral), "or")}`;
  } else if (tree.code === "missing_value") {
    message = `missing value`;
  } else if (tree.code === "unrecognized_keys") {
    const keys = tree.keys;
    message = `unrecognized ${keys.length === 1 ? "key" : "keys"} ${separatedList(keys.map(formatLiteral), "and")}`;
  } else if (tree.code === "invalid_length") {
    const min = tree.minLength;
    const max = tree.maxLength;
    message = `expected an array with `;
    if (min > 0) {
      if (max === min) {
        message += `${min}`;
      } else if (max !== void 0) {
        message += `between ${min} and ${max}`;
      } else {
        message += `at least ${min}`;
      }
    } else {
      message += `at most ${max}`;
    }
    message += ` item(s)`;
  } else if (tree.code === "custom_error") {
    const error3 = tree.error;
    if (typeof error3 === "string") {
      message = error3;
    } else if (error3 !== void 0) {
      if (error3.message !== void 0) {
        message = error3.message;
      }
      if (error3.path !== void 0) {
        path2 += "." + error3.path.join(".");
      }
    }
  }
  let msg = `${tree.code} at .${path2.slice(1)} (${message})`;
  if (count3 === 1) {
    msg += ` (+ 1 other issue)`;
  } else if (count3 > 1) {
    msg += ` (+ ${count3} other issues)`;
  }
  return msg;
}
function ok(value) {
  return { ok: true, value };
}
function err(error3) {
  return new ErrImpl({ ok: false, code: "custom_error", error: error3 });
}
function isObject2(v) {
  return typeof v === "object" && v !== null && !Array.isArray(v);
}
function setBit(bits, index10) {
  if (typeof bits !== "number") {
    const idx = index10 >> 5;
    for (let i = bits.length; i <= idx; i++) {
      bits.push(0);
    }
    bits[idx] |= 1 << index10 % 32;
    return bits;
  } else if (index10 < 32) {
    return bits | 1 << index10;
  } else {
    return setBit([bits, 0], index10);
  }
}
function getBit(bits, index10) {
  if (typeof bits === "number") {
    return index10 < 32 ? bits >>> index10 & 1 : 0;
  } else {
    return bits[index10 >> 5] >>> index10 % 32 & 1;
  }
}
function createObjectMatcher(shape, rest, checks) {
  const requiredKeys = [];
  const optionalKeys = [];
  for (const key2 in shape) {
    let hasOptional = false;
    shape[key2].toTerminals((t3) => {
      hasOptional || (hasOptional = t3.name === "optional");
    });
    if (hasOptional) {
      optionalKeys.push(key2);
    } else {
      requiredKeys.push(key2);
    }
  }
  const keys = [...requiredKeys, ...optionalKeys];
  const totalCount = keys.length;
  if (totalCount === 0 && (rest === null || rest === void 0 ? void 0 : rest.name) === "unknown") {
    return function(obj, _) {
      if (checks !== void 0) {
        for (let i = 0; i < checks.length; i++) {
          if (!checks[i].func(obj)) {
            return checks[i].issue;
          }
        }
      }
      return void 0;
    };
  }
  const types4 = keys.map((key2) => shape[key2]);
  const requiredCount = requiredKeys.length;
  const invertedIndexes = /* @__PURE__ */ Object.create(null);
  keys.forEach((key2, index10) => {
    invertedIndexes[key2] = ~index10;
  });
  const missingValues = requiredKeys.map((key2) => prependPath(key2, {
    ok: false,
    code: "missing_value"
  }));
  function set2(obj, key2, value) {
    if (key2 === "__proto__") {
      Object.defineProperty(obj, key2, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    } else {
      obj[key2] = value;
    }
  }
  __name(set2, "set");
  return function(obj, flags) {
    let copied = false;
    let output = obj;
    let issues;
    let unrecognized = void 0;
    let seenBits = 0;
    let seenCount = 0;
    if (flags & FLAG_FORBID_EXTRA_KEYS || flags & FLAG_STRIP_EXTRA_KEYS || rest !== void 0) {
      for (const key2 in obj) {
        const value = obj[key2];
        const index10 = ~invertedIndexes[key2];
        let r3;
        if (index10 >= 0) {
          seenCount++;
          seenBits = setBit(seenBits, index10);
          r3 = types4[index10].func(value, flags);
        } else if (rest !== void 0) {
          r3 = rest.func(value, flags);
        } else {
          if (flags & FLAG_FORBID_EXTRA_KEYS) {
            if (unrecognized === void 0) {
              unrecognized = [key2];
            } else {
              unrecognized.push(key2);
            }
          } else if (flags & FLAG_STRIP_EXTRA_KEYS && issues === void 0 && !copied) {
            output = {};
            copied = true;
            for (let m = 0; m < totalCount; m++) {
              if (getBit(seenBits, m)) {
                const k = keys[m];
                set2(output, k, obj[k]);
              }
            }
          }
          continue;
        }
        if (r3 === void 0) {
          if (copied && issues === void 0) {
            set2(output, key2, value);
          }
        } else if (!r3.ok) {
          issues = joinIssues(issues, prependPath(key2, r3));
        } else if (issues === void 0) {
          if (!copied) {
            output = {};
            copied = true;
            if (rest === void 0) {
              for (let m = 0; m < totalCount; m++) {
                if (m !== index10 && getBit(seenBits, m)) {
                  const k = keys[m];
                  set2(output, k, obj[k]);
                }
              }
            } else {
              for (const k in obj) {
                set2(output, k, obj[k]);
              }
            }
          }
          set2(output, key2, r3.value);
        }
      }
    }
    if (seenCount < totalCount) {
      for (let i = 0; i < totalCount; i++) {
        if (getBit(seenBits, i)) {
          continue;
        }
        const key2 = keys[i];
        const value = obj[key2];
        let keyFlags = flags & ~FLAG_MISSING_VALUE;
        if (value === void 0 && !(key2 in obj)) {
          if (i < requiredCount) {
            issues = joinIssues(issues, missingValues[i]);
            continue;
          }
          keyFlags |= FLAG_MISSING_VALUE;
        }
        const r3 = types4[i].func(value, keyFlags);
        if (r3 === void 0) {
          if (copied && issues === void 0 && !(keyFlags & FLAG_MISSING_VALUE)) {
            set2(output, key2, value);
          }
        } else if (!r3.ok) {
          issues = joinIssues(issues, prependPath(key2, r3));
        } else if (issues === void 0) {
          if (!copied) {
            output = {};
            copied = true;
            if (rest === void 0) {
              for (let m = 0; m < totalCount; m++) {
                if (m < i || getBit(seenBits, m)) {
                  const k = keys[m];
                  set2(output, k, obj[k]);
                }
              }
            } else {
              for (const k in obj) {
                set2(output, k, obj[k]);
              }
              for (let m = 0; m < i; m++) {
                if (!getBit(seenBits, m)) {
                  const k = keys[m];
                  set2(output, k, obj[k]);
                }
              }
            }
          }
          set2(output, key2, r3.value);
        }
      }
    }
    if (unrecognized !== void 0) {
      issues = joinIssues(issues, {
        ok: false,
        code: "unrecognized_keys",
        keys: unrecognized
      });
    }
    if (issues === void 0 && checks !== void 0) {
      for (let i = 0; i < checks.length; i++) {
        if (!checks[i].func(output)) {
          return checks[i].issue;
        }
      }
    }
    if (issues === void 0 && copied) {
      return { ok: true, value: output };
    } else {
      return issues;
    }
  };
}
function toInputType(v) {
  const type = typeof v;
  if (type !== "object") {
    return type;
  } else if (v === null) {
    return "null";
  } else if (Array.isArray(v)) {
    return "array";
  } else {
    return type;
  }
}
function dedup(arr2) {
  return Array.from(new Set(arr2));
}
function findCommonKeys(rs) {
  const map = /* @__PURE__ */ new Map();
  rs.forEach((r3) => {
    for (const key2 in r3) {
      map.set(key2, (map.get(key2) || 0) + 1);
    }
  });
  const result = [];
  map.forEach((count3, key2) => {
    if (count3 === rs.length) {
      result.push(key2);
    }
  });
  return result;
}
function groupTerminals(terminals) {
  const order = /* @__PURE__ */ new Map();
  const literals = /* @__PURE__ */ new Map();
  const types4 = /* @__PURE__ */ new Map();
  const unknowns = [];
  const optionals = [];
  const expectedTypes = [];
  terminals.forEach(({ root: root2, terminal }) => {
    var _a;
    order.set(root2, (_a = order.get(root2)) !== null && _a !== void 0 ? _a : order.size);
    if (terminal.name === "never") {
    } else if (terminal.name === "optional") {
      optionals.push(root2);
    } else if (terminal.name === "unknown") {
      unknowns.push(root2);
    } else if (terminal.name === "literal") {
      const roots = literals.get(terminal.value) || [];
      roots.push(root2);
      literals.set(terminal.value, roots);
      expectedTypes.push(toInputType(terminal.value));
    } else {
      const roots = types4.get(terminal.name) || [];
      roots.push(root2);
      types4.set(terminal.name, roots);
      expectedTypes.push(terminal.name);
    }
  });
  literals.forEach((roots, value) => {
    const options2 = types4.get(toInputType(value));
    if (options2) {
      options2.push(...roots);
      literals.delete(value);
    }
  });
  const byOrder = /* @__PURE__ */ __name((a, b2) => {
    var _a, _b;
    return ((_a = order.get(a)) !== null && _a !== void 0 ? _a : 0) - ((_b = order.get(b2)) !== null && _b !== void 0 ? _b : 0);
  }, "byOrder");
  types4.forEach((roots, type) => types4.set(type, dedup(roots.concat(unknowns).sort(byOrder))));
  literals.forEach((roots, value) => literals.set(value, dedup(roots.concat(unknowns)).sort(byOrder)));
  return {
    types: types4,
    literals,
    unknowns: dedup(unknowns).sort(byOrder),
    optionals: dedup(optionals).sort(byOrder),
    expectedTypes: dedup(expectedTypes)
  };
}
function createObjectKeyMatcher(objects, key2) {
  const list = [];
  for (const { root: root2, terminal } of objects) {
    terminal.shape[key2].toTerminals((t3) => list.push({ root: root2, terminal: t3 }));
  }
  const { types: types4, literals, optionals, unknowns, expectedTypes } = groupTerminals(list);
  if (unknowns.length > 0 || optionals.length > 1) {
    return void 0;
  }
  for (const roots of literals.values()) {
    if (roots.length > 1) {
      return void 0;
    }
  }
  for (const roots of types4.values()) {
    if (roots.length > 1) {
      return void 0;
    }
  }
  const missingValue = prependPath(key2, { ok: false, code: "missing_value" });
  const issue = prependPath(key2, types4.size === 0 ? {
    ok: false,
    code: "invalid_literal",
    expected: Array.from(literals.keys())
  } : {
    ok: false,
    code: "invalid_type",
    expected: expectedTypes
  });
  const litMap = literals.size > 0 ? /* @__PURE__ */ new Map() : void 0;
  for (const [literal2, options2] of literals) {
    litMap.set(literal2, options2[0]);
  }
  const byType = types4.size > 0 ? {} : void 0;
  for (const [type, options2] of types4) {
    byType[type] = options2[0];
  }
  return function(_obj, flags) {
    var _a;
    const obj = _obj;
    const value = obj[key2];
    if (value === void 0 && !(key2 in obj)) {
      return optionals.length > 0 ? optionals[0].func(obj, flags) : missingValue;
    }
    const option = (_a = byType === null || byType === void 0 ? void 0 : byType[toInputType(value)]) !== null && _a !== void 0 ? _a : litMap === null || litMap === void 0 ? void 0 : litMap.get(value);
    return option ? option.func(obj, flags) : issue;
  };
}
function createUnionObjectMatcher(terminals) {
  if (terminals.some(({ terminal: t3 }) => t3.name === "unknown")) {
    return void 0;
  }
  const objects = terminals.filter((item) => {
    return item.terminal.name === "object";
  });
  if (objects.length < 2) {
    return void 0;
  }
  const shapes = objects.map(({ terminal }) => terminal.shape);
  for (const key2 of findCommonKeys(shapes)) {
    const matcher = createObjectKeyMatcher(objects, key2);
    if (matcher) {
      return matcher;
    }
  }
  return void 0;
}
function createUnionBaseMatcher(terminals) {
  const { expectedTypes, literals, types: types4, unknowns, optionals } = groupTerminals(terminals);
  const issue = types4.size === 0 && unknowns.length === 0 ? {
    ok: false,
    code: "invalid_literal",
    expected: Array.from(literals.keys())
  } : {
    ok: false,
    code: "invalid_type",
    expected: expectedTypes
  };
  const litMap = literals.size > 0 ? literals : void 0;
  const byType = types4.size > 0 ? {} : void 0;
  for (const [type, options2] of types4) {
    byType[type] = options2;
  }
  return function(value, flags) {
    var _a, _b;
    let options2;
    if (flags & FLAG_MISSING_VALUE) {
      options2 = optionals;
    } else {
      options2 = (_b = (_a = byType === null || byType === void 0 ? void 0 : byType[toInputType(value)]) !== null && _a !== void 0 ? _a : litMap === null || litMap === void 0 ? void 0 : litMap.get(value)) !== null && _b !== void 0 ? _b : unknowns;
    }
    if (!options2) {
      return issue;
    }
    let count3 = 0;
    let issueTree = issue;
    for (let i = 0; i < options2.length; i++) {
      const r3 = options2[i].func(value, flags);
      if (r3 === void 0 || r3.ok) {
        return r3;
      }
      issueTree = count3 > 0 ? joinIssues(issueTree, r3) : r3;
      count3++;
    }
    if (count3 > 1) {
      return { ok: false, code: "invalid_union", tree: issueTree };
    }
    return issueTree;
  };
}
function never() {
  return neverSingleton;
}
function unknown() {
  return unknownSingleton;
}
function undefined_() {
  return undefinedSingleton;
}
function null_() {
  return nullSingleton;
}
function number() {
  return numberSingleton;
}
function bigint3() {
  return bigintSingleton;
}
function string() {
  return stringSingleton;
}
function boolean2() {
  return booleanSingleton;
}
function literal(value) {
  return new LiteralType(value);
}
function object(obj) {
  return new ObjectType(obj, void 0);
}
function record(valueType) {
  return new ObjectType({}, valueType !== null && valueType !== void 0 ? valueType : unknown());
}
function array2(item) {
  return new ArrayOrTupleType([], item !== null && item !== void 0 ? item : unknown(), []);
}
function tuple(items) {
  return new ArrayOrTupleType(items, void 0, []);
}
function union2(...options2) {
  return new UnionType(options2);
}
function lazy(definer) {
  return new LazyType(definer);
}
var ValitaError, ErrImpl, FLAG_FORBID_EXTRA_KEYS, FLAG_STRIP_EXTRA_KEYS, FLAG_MISSING_VALUE, AbstractType, Type, Nullable, Optional, ObjectType, ArrayOrTupleType, UnionType, STRICT, STRIP, PASSTHROUGH, TransformType, LazyType, NeverType, neverSingleton, UnknownType, unknownSingleton, UndefinedType, undefinedSingleton, NullType, nullSingleton, NumberType, numberSingleton, BigIntType, bigintSingleton, StringType, stringSingleton, BooleanType, booleanSingleton, LiteralType;
var init_mjs = __esm({
  "node_modules/.pnpm/@badrap+valita@0.3.11/node_modules/@badrap/valita/dist/mjs/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(joinIssues, "joinIssues");
    __name(prependPath, "prependPath");
    __name(cloneIssueWithPath, "cloneIssueWithPath");
    __name(collectIssues, "collectIssues");
    __name(separatedList, "separatedList");
    __name(formatLiteral, "formatLiteral");
    __name(countIssues, "countIssues");
    __name(formatIssueTree, "formatIssueTree");
    ValitaError = class extends Error {
      static {
        __name(this, "ValitaError");
      }
      constructor(issueTree) {
        super(formatIssueTree(issueTree));
        this.issueTree = issueTree;
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = new.target.name;
        this._issues = void 0;
      }
      get issues() {
        if (this._issues === void 0) {
          this._issues = collectIssues(this.issueTree);
        }
        return this._issues;
      }
    };
    ErrImpl = class {
      static {
        __name(this, "ErrImpl");
      }
      constructor(issueTree) {
        this.issueTree = issueTree;
        this.ok = false;
        this._issues = void 0;
        this._message = void 0;
      }
      get issues() {
        if (this._issues === void 0) {
          this._issues = collectIssues(this.issueTree);
        }
        return this._issues;
      }
      get message() {
        if (this._message === void 0) {
          this._message = formatIssueTree(this.issueTree);
        }
        return this._message;
      }
      throw() {
        throw new ValitaError(this.issueTree);
      }
    };
    __name(ok, "ok");
    __name(err, "err");
    __name(isObject2, "isObject");
    FLAG_FORBID_EXTRA_KEYS = 1;
    FLAG_STRIP_EXTRA_KEYS = 2;
    FLAG_MISSING_VALUE = 4;
    AbstractType = class {
      static {
        __name(this, "AbstractType");
      }
      optional(defaultFn) {
        const optional = new Optional(this);
        if (!defaultFn) {
          return optional;
        }
        return new TransformType(optional, (v) => {
          return v === void 0 ? { ok: true, value: defaultFn() } : void 0;
        });
      }
      default(defaultValue) {
        const defaultResult = ok(defaultValue);
        return new TransformType(this.optional(), (v) => {
          return v === void 0 ? defaultResult : void 0;
        });
      }
      assert(func, error3) {
        const err2 = { ok: false, code: "custom_error", error: error3 };
        return new TransformType(this, (v, options2) => func(v, options2) ? void 0 : err2);
      }
      map(func) {
        return new TransformType(this, (v, options2) => ({
          ok: true,
          value: func(v, options2)
        }));
      }
      chain(func) {
        return new TransformType(this, (v, options2) => {
          const r3 = func(v, options2);
          return r3.ok ? r3 : r3.issueTree;
        });
      }
    };
    Type = class extends AbstractType {
      static {
        __name(this, "Type");
      }
      /**
       * Return new validator that accepts both the original type and `null`.
       */
      nullable() {
        return new Nullable(this);
      }
      toTerminals(func) {
        func(this);
      }
      /**
       * Parse a value without throwing.
       */
      try(v, options2) {
        let flags = FLAG_FORBID_EXTRA_KEYS;
        if ((options2 === null || options2 === void 0 ? void 0 : options2.mode) === "passthrough") {
          flags = 0;
        } else if ((options2 === null || options2 === void 0 ? void 0 : options2.mode) === "strip") {
          flags = FLAG_STRIP_EXTRA_KEYS;
        }
        const r3 = this.func(v, flags);
        if (r3 === void 0) {
          return { ok: true, value: v };
        } else if (r3.ok) {
          return { ok: true, value: r3.value };
        } else {
          return new ErrImpl(r3);
        }
      }
      /**
       * Parse a value. Throw a ValitaError on failure.
       */
      parse(v, options2) {
        let flags = FLAG_FORBID_EXTRA_KEYS;
        if ((options2 === null || options2 === void 0 ? void 0 : options2.mode) === "passthrough") {
          flags = 0;
        } else if ((options2 === null || options2 === void 0 ? void 0 : options2.mode) === "strip") {
          flags = FLAG_STRIP_EXTRA_KEYS;
        }
        const r3 = this.func(v, flags);
        if (r3 === void 0) {
          return v;
        } else if (r3.ok) {
          return r3.value;
        } else {
          throw new ValitaError(r3);
        }
      }
    };
    Nullable = class extends Type {
      static {
        __name(this, "Nullable");
      }
      constructor(type) {
        super();
        this.type = type;
        this.name = "nullable";
      }
      func(v, flags) {
        return v === null ? void 0 : this.type.func(v, flags);
      }
      toTerminals(func) {
        func(nullSingleton);
        this.type.toTerminals(func);
      }
      nullable() {
        return this;
      }
    };
    Optional = class extends AbstractType {
      static {
        __name(this, "Optional");
      }
      constructor(type) {
        super();
        this.type = type;
        this.name = "optional";
      }
      func(v, flags) {
        return v === void 0 || flags & FLAG_MISSING_VALUE ? void 0 : this.type.func(v, flags);
      }
      toTerminals(func) {
        func(this);
        func(undefinedSingleton);
        this.type.toTerminals(func);
      }
      optional(defaultFn) {
        if (!defaultFn) {
          return this;
        }
        return new TransformType(this, (v) => {
          return v === void 0 ? { ok: true, value: defaultFn() } : void 0;
        });
      }
    };
    __name(setBit, "setBit");
    __name(getBit, "getBit");
    ObjectType = class _ObjectType extends Type {
      static {
        __name(this, "ObjectType");
      }
      constructor(shape, restType, checks) {
        super();
        this.shape = shape;
        this.restType = restType;
        this.checks = checks;
        this.name = "object";
        this._invalidType = {
          ok: false,
          code: "invalid_type",
          expected: ["object"]
        };
      }
      check(func, error3) {
        var _a;
        const issue = { ok: false, code: "custom_error", error: error3 };
        return new _ObjectType(this.shape, this.restType, [
          ...(_a = this.checks) !== null && _a !== void 0 ? _a : [],
          {
            func,
            issue
          }
        ]);
      }
      func(v, flags) {
        if (!isObject2(v)) {
          return this._invalidType;
        }
        let func = this._func;
        if (func === void 0) {
          func = createObjectMatcher(this.shape, this.restType, this.checks);
          this._func = func;
        }
        return func(v, flags);
      }
      rest(restType) {
        return new _ObjectType(this.shape, restType);
      }
      extend(shape) {
        return new _ObjectType(Object.assign(Object.assign({}, this.shape), shape), this.restType);
      }
      pick(...keys) {
        const shape = {};
        keys.forEach((key2) => {
          shape[key2] = this.shape[key2];
        });
        return new _ObjectType(shape, void 0);
      }
      omit(...keys) {
        const shape = Object.assign({}, this.shape);
        keys.forEach((key2) => {
          delete shape[key2];
        });
        return new _ObjectType(shape, this.restType);
      }
      partial() {
        var _a;
        const shape = {};
        Object.keys(this.shape).forEach((key2) => {
          shape[key2] = this.shape[key2].optional();
        });
        const rest = (_a = this.restType) === null || _a === void 0 ? void 0 : _a.optional();
        return new _ObjectType(shape, rest);
      }
    };
    __name(createObjectMatcher, "createObjectMatcher");
    ArrayOrTupleType = class _ArrayOrTupleType extends Type {
      static {
        __name(this, "ArrayOrTupleType");
      }
      constructor(prefix, rest, suffix) {
        super();
        this.prefix = prefix;
        this.rest = rest;
        this.suffix = suffix;
        this.name = "array";
        this.restType = rest !== null && rest !== void 0 ? rest : never();
        this.minLength = this.prefix.length + this.suffix.length;
        this.maxLength = rest ? void 0 : this.minLength;
        this.invalidType = {
          ok: false,
          code: "invalid_type",
          expected: ["array"]
        };
        this.invalidLength = {
          ok: false,
          code: "invalid_length",
          minLength: this.minLength,
          maxLength: this.maxLength
        };
      }
      func(arr2, flags) {
        var _a;
        if (!Array.isArray(arr2)) {
          return this.invalidType;
        }
        const length = arr2.length;
        const minLength = this.minLength;
        const maxLength = (_a = this.maxLength) !== null && _a !== void 0 ? _a : Infinity;
        if (length < minLength || length > maxLength) {
          return this.invalidLength;
        }
        const headEnd = this.prefix.length;
        const tailStart = arr2.length - this.suffix.length;
        let issueTree = void 0;
        let output = arr2;
        for (let i = 0; i < arr2.length; i++) {
          const type = i < headEnd ? this.prefix[i] : i >= tailStart ? this.suffix[i - tailStart] : this.restType;
          const r3 = type.func(arr2[i], flags);
          if (r3 !== void 0) {
            if (r3.ok) {
              if (output === arr2) {
                output = arr2.slice();
              }
              output[i] = r3.value;
            } else {
              issueTree = joinIssues(issueTree, prependPath(i, r3));
            }
          }
        }
        if (issueTree) {
          return issueTree;
        } else if (arr2 === output) {
          return void 0;
        } else {
          return { ok: true, value: output };
        }
      }
      concat(type) {
        if (this.rest) {
          if (type.rest) {
            throw new TypeError("can not concatenate two variadic types");
          }
          return new _ArrayOrTupleType(this.prefix, this.rest, [
            ...this.suffix,
            ...type.prefix,
            ...type.suffix
          ]);
        } else if (type.rest) {
          return new _ArrayOrTupleType([...this.prefix, ...this.suffix, ...type.prefix], type.rest, type.suffix);
        } else {
          return new _ArrayOrTupleType([...this.prefix, ...this.suffix, ...type.prefix, ...type.suffix], type.rest, type.suffix);
        }
      }
    };
    __name(toInputType, "toInputType");
    __name(dedup, "dedup");
    __name(findCommonKeys, "findCommonKeys");
    __name(groupTerminals, "groupTerminals");
    __name(createObjectKeyMatcher, "createObjectKeyMatcher");
    __name(createUnionObjectMatcher, "createUnionObjectMatcher");
    __name(createUnionBaseMatcher, "createUnionBaseMatcher");
    UnionType = class extends Type {
      static {
        __name(this, "UnionType");
      }
      constructor(options2) {
        super();
        this.options = options2;
        this.name = "union";
      }
      toTerminals(func) {
        this.options.forEach((o2) => o2.toTerminals(func));
      }
      func(v, flags) {
        let func = this._func;
        if (func === void 0) {
          const flattened2 = [];
          this.options.forEach((option) => option.toTerminals((terminal) => {
            flattened2.push({ root: option, terminal });
          }));
          const base2 = createUnionBaseMatcher(flattened2);
          const object2 = createUnionObjectMatcher(flattened2);
          if (!object2) {
            func = base2;
          } else {
            func = /* @__PURE__ */ __name(function(v2, f) {
              if (isObject2(v2)) {
                return object2(v2, f);
              }
              return base2(v2, f);
            }, "func");
          }
          this._func = func;
        }
        return func(v, flags);
      }
    };
    STRICT = Object.freeze({ mode: "strict" });
    STRIP = Object.freeze({ mode: "strip" });
    PASSTHROUGH = Object.freeze({ mode: "passthrough" });
    TransformType = class _TransformType extends Type {
      static {
        __name(this, "TransformType");
      }
      constructor(transformed, transform) {
        super();
        this.transformed = transformed;
        this.transform = transform;
        this.name = "transform";
        this.undef = ok(void 0);
        this.transformChain = void 0;
        this.transformRoot = void 0;
      }
      func(v, flags) {
        let chain = this.transformChain;
        if (!chain) {
          chain = [];
          let next = this;
          while (next instanceof _TransformType) {
            chain.push(next.transform);
            next = next.transformed;
          }
          chain.reverse();
          this.transformChain = chain;
          this.transformRoot = next;
        }
        let result = this.transformRoot.func(v, flags);
        if (result !== void 0 && !result.ok) {
          return result;
        }
        let current;
        if (result !== void 0) {
          current = result.value;
        } else if (flags & FLAG_MISSING_VALUE) {
          current = void 0;
          result = this.undef;
        } else {
          current = v;
        }
        const options2 = flags & FLAG_FORBID_EXTRA_KEYS ? STRICT : flags & FLAG_STRIP_EXTRA_KEYS ? STRIP : PASSTHROUGH;
        for (let i = 0; i < chain.length; i++) {
          const r3 = chain[i](current, options2);
          if (r3 !== void 0) {
            if (!r3.ok) {
              return r3;
            }
            current = r3.value;
            result = r3;
          }
        }
        return result;
      }
      toTerminals(func) {
        this.transformed.toTerminals(func);
      }
    };
    LazyType = class extends Type {
      static {
        __name(this, "LazyType");
      }
      constructor(definer) {
        super();
        this.definer = definer;
        this.name = "lazy";
        this.recursing = false;
      }
      func(v, flags) {
        if (!this.type) {
          this.type = this.definer();
        }
        return this.type.func(v, flags);
      }
      toTerminals(func) {
        if (this.recursing) {
          return;
        }
        try {
          this.recursing = true;
          if (!this.type) {
            this.type = this.definer();
          }
          this.type.toTerminals(func);
        } finally {
          this.recursing = false;
        }
      }
    };
    NeverType = class extends Type {
      static {
        __name(this, "NeverType");
      }
      constructor() {
        super(...arguments);
        this.name = "never";
        this.issue = {
          ok: false,
          code: "invalid_type",
          expected: []
        };
      }
      func(_, __) {
        return this.issue;
      }
    };
    neverSingleton = new NeverType();
    __name(never, "never");
    UnknownType = class extends Type {
      static {
        __name(this, "UnknownType");
      }
      constructor() {
        super(...arguments);
        this.name = "unknown";
      }
      func(_, __) {
        return void 0;
      }
    };
    unknownSingleton = new UnknownType();
    __name(unknown, "unknown");
    UndefinedType = class extends Type {
      static {
        __name(this, "UndefinedType");
      }
      constructor() {
        super(...arguments);
        this.name = "undefined";
        this.issue = {
          ok: false,
          code: "invalid_type",
          expected: ["undefined"]
        };
      }
      func(v, _) {
        return v === void 0 ? void 0 : this.issue;
      }
    };
    undefinedSingleton = new UndefinedType();
    __name(undefined_, "undefined_");
    NullType = class extends Type {
      static {
        __name(this, "NullType");
      }
      constructor() {
        super(...arguments);
        this.name = "null";
        this.issue = {
          ok: false,
          code: "invalid_type",
          expected: ["null"]
        };
      }
      func(v, _) {
        return v === null ? void 0 : this.issue;
      }
    };
    nullSingleton = new NullType();
    __name(null_, "null_");
    NumberType = class extends Type {
      static {
        __name(this, "NumberType");
      }
      constructor() {
        super(...arguments);
        this.name = "number";
        this.issue = {
          ok: false,
          code: "invalid_type",
          expected: ["number"]
        };
      }
      func(v, _) {
        return typeof v === "number" ? void 0 : this.issue;
      }
    };
    numberSingleton = new NumberType();
    __name(number, "number");
    BigIntType = class extends Type {
      static {
        __name(this, "BigIntType");
      }
      constructor() {
        super(...arguments);
        this.name = "bigint";
        this.issue = {
          ok: false,
          code: "invalid_type",
          expected: ["bigint"]
        };
      }
      func(v, _) {
        return typeof v === "bigint" ? void 0 : this.issue;
      }
    };
    bigintSingleton = new BigIntType();
    __name(bigint3, "bigint");
    StringType = class extends Type {
      static {
        __name(this, "StringType");
      }
      constructor() {
        super(...arguments);
        this.name = "string";
        this.issue = {
          ok: false,
          code: "invalid_type",
          expected: ["string"]
        };
      }
      func(v, _) {
        return typeof v === "string" ? void 0 : this.issue;
      }
    };
    stringSingleton = new StringType();
    __name(string, "string");
    BooleanType = class extends Type {
      static {
        __name(this, "BooleanType");
      }
      constructor() {
        super(...arguments);
        this.name = "boolean";
        this.issue = {
          ok: false,
          code: "invalid_type",
          expected: ["boolean"]
        };
      }
      func(v, _) {
        return typeof v === "boolean" ? void 0 : this.issue;
      }
    };
    booleanSingleton = new BooleanType();
    __name(boolean2, "boolean");
    LiteralType = class extends Type {
      static {
        __name(this, "LiteralType");
      }
      constructor(value) {
        super();
        this.value = value;
        this.name = "literal";
        this.issue = {
          ok: false,
          code: "invalid_literal",
          expected: [value]
        };
      }
      func(v, _) {
        return v === this.value ? void 0 : this.issue;
      }
    };
    __name(literal, "literal");
    __name(object, "object");
    __name(record, "record");
    __name(array2, "array");
    __name(tuple, "tuple");
    __name(union2, "union");
    __name(lazy, "lazy");
  }
});

// node_modules/.pnpm/@rocicorp+logger@5.4.0/node_modules/@rocicorp/logger/out/logger.js
function stringified(context3) {
  const args = [];
  for (const [k, v] of Object.entries(context3 ?? {})) {
    const arg = v === void 0 ? k : `${k}=${v}`;
    args.push(arg);
  }
  return args;
}
function normalizeArgument(v) {
  switch (typeof v) {
    case "string":
    case "number":
    case "boolean":
    case "undefined":
    case "symbol":
    case "bigint":
      return v;
    case "object":
      if (v === null) {
        return null;
      }
      break;
  }
  return JSON.stringify(v, errorReplacer);
}
function errorReplacer(_key, v) {
  if (v instanceof Error) {
    return {
      name: v.name,
      message: v.message,
      stack: v.stack,
      ..."cause" in v ? { cause: v.cause } : null
    };
  }
  return v;
}
var TeeLogSink, OptionalLoggerImpl, consoleLogSink, LogContext;
var init_logger2 = __esm({
  "node_modules/.pnpm/@rocicorp+logger@5.4.0/node_modules/@rocicorp/logger/out/logger.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    TeeLogSink = class {
      static {
        __name(this, "TeeLogSink");
      }
      #sinks;
      constructor(sinks) {
        this.#sinks = sinks;
      }
      log(level, context3, ...args) {
        for (const logger of this.#sinks) {
          logger.log(level, context3, ...args);
        }
      }
      async flush() {
        await Promise.all(this.#sinks.map((logger) => logger.flush?.()));
      }
    };
    OptionalLoggerImpl = class {
      static {
        __name(this, "OptionalLoggerImpl");
      }
      debug = void 0;
      info = void 0;
      warn = void 0;
      error = void 0;
      flush;
      constructor(logSink, level = "info", context3) {
        const impl = /* @__PURE__ */ __name((level2) => (...args) => logSink.log(level2, context3, ...args), "impl");
        switch (level) {
          // @ts-ignore
          case "debug":
            this.debug = impl("debug");
          // @ts-ignore
          case "info":
            this.info = impl("info");
          // @ts-ignore
          case "warn":
            this.warn = impl("warn");
          // @ts-ignore
          case "error":
            this.error = impl("error");
        }
        this.flush = () => logSink.flush?.() ?? Promise.resolve();
      }
    };
    consoleLogSink = {
      log(level, context3, ...args) {
        console[level](...stringified(context3), ...args.map(normalizeArgument));
      }
    };
    LogContext = class _LogContext extends OptionalLoggerImpl {
      static {
        __name(this, "LogContext");
      }
      #logSink;
      #level;
      #context;
      constructor(level = "info", context3, logSink = consoleLogSink) {
        super(logSink, level, context3);
        this.#level = level;
        this.#logSink = logSink;
        this.#context = context3;
      }
      /**
       * Creates a new Logger that with the given key and value
       * added to the logged Context.
       */
      withContext(key2, value) {
        const ctx = { ...this.#context, [key2]: value };
        return new _LogContext(this.#level, ctx, this.#logSink);
      }
    };
    __name(stringified, "stringified");
    __name(normalizeArgument, "normalizeArgument");
    __name(errorReplacer, "errorReplacer");
  }
});

// node_modules/.pnpm/@rocicorp+lock@1.0.4/node_modules/@rocicorp/lock/out/lock.js
async function run(p, f) {
  const release2 = await p;
  try {
    return await f();
  } finally {
    release2();
  }
}
var Lock, RWLock;
var init_lock = __esm({
  "node_modules/.pnpm/@rocicorp+lock@1.0.4/node_modules/@rocicorp/lock/out/lock.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_resolver();
    Lock = class {
      static {
        __name(this, "Lock");
      }
      _lockP = null;
      async lock() {
        const previous = this._lockP;
        const { promise, resolve: resolve2 } = resolver();
        this._lockP = promise;
        await previous;
        return resolve2;
      }
      withLock(f) {
        return run(this.lock(), f);
      }
    };
    RWLock = class {
      static {
        __name(this, "RWLock");
      }
      _lock = new Lock();
      _writeP = null;
      _readP = [];
      read() {
        return this._lock.withLock(async () => {
          await this._writeP;
          const { promise, resolve: resolve2 } = resolver();
          this._readP.push(promise);
          return resolve2;
        });
      }
      withRead(f) {
        return run(this.read(), f);
      }
      async write() {
        return await this._lock.withLock(async () => {
          await this._writeP;
          await Promise.all(this._readP);
          const { promise, resolve: resolve2 } = resolver();
          this._writeP = promise;
          this._readP = [];
          return resolve2;
        });
      }
      withWrite(f) {
        return run(this.write(), f);
      }
    };
    __name(run, "run");
  }
});

// node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/xxHash32.js
function xxHash32(input, seed = 0) {
  const buffer2 = typeof input === "string" ? (encoder3 ??= new TextEncoder()).encode(input) : input;
  const b2 = buffer2;
  let acc = seed + PRIME32_5 & 4294967295;
  let offset = 0;
  if (b2.length >= 16) {
    const accN = [
      seed + PRIME32_1 + PRIME32_2 & 4294967295,
      seed + PRIME32_2 & 4294967295,
      seed + 0 & 4294967295,
      seed - PRIME32_1 & 4294967295
    ];
    const b3 = buffer2;
    const limit2 = b3.length - 16;
    let lane = 0;
    for (offset = 0; (offset & 4294967280) <= limit2; offset += 4) {
      const i = offset;
      const laneN0 = b3[i + 0] + (b3[i + 1] << 8);
      const laneN1 = b3[i + 2] + (b3[i + 3] << 8);
      const laneNP = laneN0 * PRIME32_2 + (laneN1 * PRIME32_2 << 16);
      let acc2 = accN[lane] + laneNP & 4294967295;
      acc2 = acc2 << 13 | acc2 >>> 19;
      const acc0 = acc2 & 65535;
      const acc1 = acc2 >>> 16;
      accN[lane] = acc0 * PRIME32_1 + (acc1 * PRIME32_1 << 16) & 4294967295;
      lane = lane + 1 & 3;
    }
    acc = (accN[0] << 1 | accN[0] >>> 31) + (accN[1] << 7 | accN[1] >>> 25) + (accN[2] << 12 | accN[2] >>> 20) + (accN[3] << 18 | accN[3] >>> 14) & 4294967295;
  }
  acc = acc + buffer2.length & 4294967295;
  const limit = buffer2.length - 4;
  for (; offset <= limit; offset += 4) {
    const i = offset;
    const laneN0 = b2[i + 0] + (b2[i + 1] << 8);
    const laneN1 = b2[i + 2] + (b2[i + 3] << 8);
    const laneP = laneN0 * PRIME32_3 + (laneN1 * PRIME32_3 << 16);
    acc = acc + laneP & 4294967295;
    acc = acc << 17 | acc >>> 15;
    acc = (acc & 65535) * PRIME32_4 + ((acc >>> 16) * PRIME32_4 << 16) & 4294967295;
  }
  for (; offset < b2.length; ++offset) {
    const lane = b2[offset];
    acc = acc + lane * PRIME32_5;
    acc = acc << 11 | acc >>> 21;
    acc = (acc & 65535) * PRIME32_1 + ((acc >>> 16) * PRIME32_1 << 16) & 4294967295;
  }
  acc = acc ^ acc >>> 15;
  acc = ((acc & 65535) * PRIME32_2 & 4294967295) + ((acc >>> 16) * PRIME32_2 << 16);
  acc = acc ^ acc >>> 13;
  acc = ((acc & 65535) * PRIME32_3 & 4294967295) + ((acc >>> 16) * PRIME32_3 << 16);
  acc = acc ^ acc >>> 16;
  return acc < 0 ? acc + 4294967296 : acc;
}
var PRIME32_1, PRIME32_2, PRIME32_3, PRIME32_4, PRIME32_5, encoder3;
var init_xxHash32 = __esm({
  "node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/xxHash32.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    PRIME32_1 = 2654435761;
    PRIME32_2 = 2246822519;
    PRIME32_3 = 3266489917;
    PRIME32_4 = 668265263;
    PRIME32_5 = 374761393;
    __name(xxHash32, "xxHash32");
  }
});

// node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/index.js
var init_esm = __esm({
  "node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/dist/esm/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_xxHash32();
  }
});

// node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/index.mjs
var init_js_xxhash = __esm({
  "node_modules/.pnpm/js-xxhash@4.0.0/node_modules/js-xxhash/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_esm();
  }
});

// node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-6KJRALZP.js
async function callDefaultFetch(url, auth, requestID, requestBody) {
  const init2 = {
    headers: {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "Content-type": "application/json",
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "Authorization": auth,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "X-Replicache-RequestID": requestID
    },
    body: JSON.stringify(requestBody),
    method: "POST"
  };
  const request = new Request(url, init2);
  const response = await fetch(request);
  const httpStatusCode = response.status;
  if (httpStatusCode !== 200) {
    return [
      void 0,
      {
        httpStatusCode,
        errorMessage: await response.text()
      }
    ];
  }
  return [
    response,
    {
      httpStatusCode,
      errorMessage: ""
    }
  ];
}
function deepEqual(a, b2) {
  if (a === b2) {
    return true;
  }
  if (typeof a !== typeof b2) {
    return false;
  }
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
      return false;
  }
  a = a;
  if (Array.isArray(a)) {
    if (!Array.isArray(b2)) {
      return false;
    }
    if (a.length !== b2.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b2[i])) {
        return false;
      }
    }
    return true;
  }
  if (a === null || b2 === null) {
    return false;
  }
  if (Array.isArray(b2)) {
    return false;
  }
  a = a;
  b2 = b2;
  let aSize = 0;
  for (const key2 in a) {
    if (hasOwn(a, key2)) {
      if (!deepEqual(a[key2], b2[key2])) {
        return false;
      }
      aSize++;
    }
  }
  let bSize = 0;
  for (const key2 in b2) {
    if (hasOwn(b2, key2)) {
      bSize++;
    }
  }
  return aSize === bSize;
}
function assertJSONValue(v2) {
  if (isProd) {
    return;
  }
  switch (typeof v2) {
    case "boolean":
    case "number":
    case "string":
      return;
    case "object":
      if (v2 === null) {
        return;
      }
      if (Array.isArray(v2)) {
        return assertJSONArray(v2);
      }
      return assertObjectIsJSONObject(v2);
  }
  throwInvalidType(v2, "JSON value");
}
function assertJSONObject(v2) {
  assertObject(v2);
  assertObjectIsJSONObject(v2);
}
function assertObjectIsJSONObject(v2) {
  for (const k in v2) {
    if (hasOwn(v2, k)) {
      const value = v2[k];
      if (value !== void 0) {
        assertJSONValue(value);
      }
    }
  }
}
function assertJSONArray(v2) {
  for (const item of v2) {
    assertJSONValue(item);
  }
}
function isJSONValue(v2, path2) {
  switch (typeof v2) {
    case "boolean":
    case "number":
    case "string":
      return true;
    case "object":
      if (v2 === null) {
        return true;
      }
      if (Array.isArray(v2)) {
        return isJSONArray(v2, path2);
      }
      return objectIsJSONObject(v2, path2);
  }
  return false;
}
function isJSONObject(v2, path2) {
  if (typeof v2 !== "object" || v2 === null) {
    return false;
  }
  return objectIsJSONObject(v2, path2);
}
function objectIsJSONObject(v2, path2) {
  for (const k in v2) {
    if (hasOwn(v2, k)) {
      path2.push(k);
      const value = v2[k];
      if (value !== void 0 && !isJSONValue(value, path2)) {
        return false;
      }
      path2.pop();
    }
  }
  return true;
}
function isJSONArray(v2, path2) {
  for (let i = 0; i < v2.length; i++) {
    path2.push(i);
    if (!isJSONValue(v2[i], path2)) {
      return false;
    }
    path2.pop();
  }
  return true;
}
function stringCompare(a, b2) {
  if (a === b2) {
    return 0;
  }
  if (a < b2) {
    return -1;
  }
  return 1;
}
function compareCookies(a, b2) {
  if (a === b2) {
    return 0;
  }
  if (a === null) {
    return -1;
  }
  if (b2 === null) {
    return 1;
  }
  const cva = getCompareValue(a);
  const cvb = getCompareValue(b2);
  if (typeof cva === "string" || typeof cvb === "string") {
    return stringCompare(String(cva), String(cvb));
  }
  return cva - cvb;
}
function getCompareValue(cookie) {
  if (typeof cookie === "string" || typeof cookie === "number") {
    return cookie;
  }
  return cookie.order;
}
function assertCookie(v2) {
  if (v2 === null || typeof v2 === "string" || typeof v2 === "number") {
    return;
  }
  assertJSONObject(v2);
  if (typeof v2.order === "string" || typeof v2.order === "number") {
    return;
  }
  throw new Error("Invalid cookie");
}
function isError2(obj, type) {
  return typeof obj === "object" && obj !== null && obj.error === type;
}
function isErrorResponse(obj) {
  return typeof obj.error === "string";
}
function isClientStateNotFoundResponse(v2) {
  return isError2(v2, "ClientStateNotFound");
}
function isVersionNotSupportedResponse(v2) {
  if (!isError2(v2, "VersionNotSupported")) {
    return false;
  }
  const { versionType } = v2;
  switch (versionType) {
    case void 0:
    case "pull":
    case "push":
    case "schema":
      return true;
  }
  return false;
}
function assertVersionNotSupportedResponse(v2) {
  assert3(isVersionNotSupportedResponse(v2));
}
function assertHTTPRequestInfo(v2) {
  assertObject(v2);
  assertNumber(v2.httpStatusCode);
  assertString(v2.errorMessage);
}
function assertPatchOperations(p) {
  assertArray(p);
  for (const item of p) {
    assertPatchOperation(item);
  }
}
function assertPatchOperation(p) {
  assertObject(p);
  switch (p.op) {
    case "put":
      assertString(p.key);
      assertJSONValue(p.value);
      break;
    case "update":
      assertString(p.key);
      if (p.merge !== void 0) {
        assertJSONObject(p.merge);
      }
      if (p.constrain !== void 0) {
        assertArray(p.constrain);
        for (const key2 of p.constrain) {
          assertString(key2);
        }
      }
      break;
    case "del":
      assertString(p.key);
      break;
    case "clear":
      break;
    default:
      throw new Error(
        `unknown patch op \`${p.op}\`, expected one of \`put\`, \`del\`, \`clear\``
      );
  }
}
function getDefaultPuller(rep) {
  async function puller(requestBody, requestID) {
    const [response, httpRequestInfo] = await callDefaultFetch(
      rep.pullURL,
      rep.auth,
      requestID,
      requestBody
    );
    if (!response) {
      return { httpRequestInfo };
    }
    return {
      response: await response.json(),
      httpRequestInfo
    };
  }
  __name(puller, "puller");
  defaultPullers.add(puller);
  return puller;
}
function isDefaultPuller(puller) {
  return defaultPullers.has(puller);
}
function assertPullResponseV1(v2) {
  assertObject(v2);
  if (isClientStateNotFoundResponse(v2) || isVersionNotSupportedResponse(v2)) {
    return;
  }
  const v22 = v2;
  if (v22.cookie !== void 0) {
    assertCookie(v22.cookie);
  }
  assertLastMutationIDChanges(v22.lastMutationIDChanges);
  assertPatchOperations(v22.patch);
}
function assertLastMutationIDChanges(lastMutationIDChanges) {
  assertObject(lastMutationIDChanges);
  for (const [key2, value] of Object.entries(lastMutationIDChanges)) {
    assertString(key2);
    assertNumber(value);
  }
}
function assertPullerResultV1(v2) {
  assertObject(v2);
  assertHTTPRequestInfo(v2.httpRequestInfo);
  if (v2.response !== void 0) {
    assertPullResponseV1(v2.response);
  }
}
function getBrowserGlobal(name) {
  return globalThis[name];
}
function getBrowserGlobalMethod(name) {
  return globalThis[name]?.bind(globalThis);
}
function mustGetBrowserGlobal(name) {
  const r3 = getBrowserGlobal(name);
  if (r3 === void 0) {
    throw new Error(
      `Unsupported JavaScript environment: Could not find ${name}.`
    );
  }
  return r3;
}
function deepFreeze(v2) {
  if (isProd) {
    return v2;
  }
  deepFreezeInternal(v2, []);
  return v2;
}
function deepFreezeInternal(v2, seen) {
  switch (typeof v2) {
    case "undefined":
      throw new TypeError("Unexpected value undefined");
    case "boolean":
    case "number":
    case "string":
      return;
    case "object": {
      if (v2 === null) {
        return;
      }
      if (deepFrozenObjects.has(v2)) {
        return;
      }
      deepFrozenObjects.add(v2);
      if (seen.includes(v2)) {
        throwInvalidType(v2, "Cyclic JSON object");
      }
      seen.push(v2);
      Object.freeze(v2);
      if (Array.isArray(v2)) {
        deepFreezeArray(v2, seen);
      } else {
        deepFreezeObject(v2, seen);
      }
      seen.pop();
      return;
    }
    default:
      throwInvalidType(v2, "JSON value");
  }
}
function deepFreezeArray(v2, seen) {
  for (const item of v2) {
    deepFreezeInternal(item, seen);
  }
}
function deepFreezeObject(v2, seen) {
  for (const k in v2) {
    if (hasOwn(v2, k)) {
      const value = v2[k];
      if (value !== void 0) {
        deepFreezeInternal(value, seen);
      }
    }
  }
}
function assertDeepFrozen(v2) {
  if (isProd) {
    return;
  }
  if (!isDeepFrozen(v2, [])) {
    throw new Error("Expected frozen object");
  }
}
function isDeepFrozen(v2, seen) {
  switch (typeof v2) {
    case "boolean":
    case "number":
    case "string":
      return true;
    case "object":
      if (v2 === null) {
        return true;
      }
      if (deepFrozenObjects.has(v2)) {
        return true;
      }
      if (!Object.isFrozen(v2)) {
        return false;
      }
      if (seen.includes(v2)) {
        throwInvalidType(v2, "Cyclic JSON object");
      }
      seen.push(v2);
      if (Array.isArray(v2)) {
        for (const item of v2) {
          if (!isDeepFrozen(item, seen)) {
            seen.pop();
            return false;
          }
        }
      } else {
        for (const k in v2) {
          if (hasOwn(v2, k)) {
            const value = v2[k];
            if (value !== void 0 && !isDeepFrozen(value, seen)) {
              seen.pop();
              return false;
            }
          }
        }
      }
      deepFrozenObjects.add(v2);
      seen.pop();
      return true;
    default:
      throwInvalidType(v2, "JSON value");
  }
}
function deepFreezeAllowUndefined(v2) {
  if (v2 === void 0) {
    return void 0;
  }
  return deepFreeze(v2);
}
function writeImpl(db2) {
  const tx = db2.transaction(OBJECT_STORE, "readwrite", RELAXED);
  return new WriteImpl(tx);
}
function readImpl(db2) {
  const tx = db2.transaction(OBJECT_STORE, "readonly");
  return new ReadImpl(tx);
}
function objectStore(tx) {
  return tx.objectStore(OBJECT_STORE);
}
function openDatabase(name) {
  const idb = mustGetBrowserGlobal("indexedDB");
  return new Promise((resolve2, reject) => {
    const req = idb.open(name);
    req.onupgradeneeded = () => {
      req.result.createObjectStore(OBJECT_STORE);
    };
    req.onsuccess = () => {
      const db2 = req.result;
      db2.onversionchange = () => db2.close();
      resolve2(db2);
    };
    req.onerror = () => reject(req.error);
  });
}
function sleep(ms, signal) {
  const newAbortError = /* @__PURE__ */ __name(() => new AbortError("Aborted"), "newAbortError");
  if (signal?.aborted) {
    return Promise.reject(newAbortError());
  }
  if (ms === 0) {
    return promiseVoid2;
  }
  return new Promise((resolve2, reject) => {
    let handleAbort;
    if (signal) {
      handleAbort = /* @__PURE__ */ __name(() => {
        clearTimeout(id);
        reject(newAbortError());
      }, "handleAbort");
      signal.addEventListener("abort", handleAbort, { once: true });
    }
    const id = setTimeout(() => {
      resolve2();
      signal?.removeEventListener("abort", handleAbort);
    }, ms);
  });
}
function sleepWithAbort(ms, signal) {
  if (ms === 0) {
    return [promiseVoid2, promiseNever2];
  }
  const { promise: abortedPromise, resolve: abortedResolve } = resolver();
  const sleepPromise = new Promise((resolve2) => {
    const handleAbort = /* @__PURE__ */ __name(() => {
      clearTimeout(id);
      abortedResolve();
    }, "handleAbort");
    const id = setTimeout(() => {
      resolve2();
      signal.removeEventListener("abort", handleAbort);
    }, ms);
    signal.addEventListener("abort", handleAbort, { once: true });
  });
  return [sleepPromise, abortedPromise];
}
function initBgIntervalProcess(processName, process22, delayMs, lc, signal) {
  void runBgIntervalProcess(processName, process22, delayMs, lc, signal);
}
async function runBgIntervalProcess(processName, process22, delayMs, lc, signal) {
  if (signal.aborted) {
    return;
  }
  lc = lc.withContext("bgIntervalProcess", processName);
  lc.debug?.("Starting");
  while (!signal.aborted) {
    try {
      await sleep(delayMs(), signal);
    } catch (e3) {
      if (!(e3 instanceof AbortError)) {
        throw e3;
      }
    }
    if (!signal.aborted) {
      lc.debug?.("Running");
      try {
        await process22();
      } catch (e3) {
        if (signal.aborted) {
          lc.debug?.("Error running most likely due to close.", e3);
        } else {
          lc.error?.("Error running.", e3);
        }
      }
    }
  }
  lc.debug?.("Stopping");
}
function randomUint64() {
  const high = Math.floor(Math.random() * 4294967295);
  const low = Math.floor(Math.random() * 4294967295);
  return BigInt(high) << 32n | BigInt(low);
}
function toDisplay(value) {
  switch (typeof value) {
    case "string":
    case "number":
    case "boolean":
      return JSON.stringify(value);
    case "undefined":
      return "undefined";
    case "bigint":
      return value.toString() + "n";
    default:
      if (value === null) {
        return "null";
      }
      if (Array.isArray(value)) {
        return "array";
      }
      return typeof value;
  }
}
function toDisplayAtPath(v2, path2) {
  if (!path2?.length) {
    return toDisplay(v2);
  }
  let cur = v2;
  for (const p of path2) {
    cur = cur[p];
  }
  return toDisplay(cur);
}
function displayList(word, expected, toDisplay2 = (x) => String(x)) {
  if (expected.length === 1) {
    return toDisplay2(expected[0]);
  }
  const suffix = `${toDisplay2(
    expected[expected.length - 2]
  )} ${word} ${toDisplay2(expected[expected.length - 1])}`;
  if (expected.length === 2) {
    return suffix;
  }
  return `${expected.slice(0, -2).map(toDisplay2).join(", ")}, ${suffix}`;
}
function getMessage(err2, v2, schema2, mode) {
  const firstIssue = err2.issues[0];
  const { path: path2 } = firstIssue;
  const atPath = path2?.length ? ` at ${path2.join(".")}` : "";
  switch (firstIssue.code) {
    case "invalid_type":
      return `Expected ${displayList(
        "or",
        firstIssue.expected
      )}${atPath}. Got ${toDisplayAtPath(v2, path2)}`;
    case "missing_value": {
      const atPath2 = path2 && path2.length > 1 ? ` at ${path2.slice(0, -1).join(".")}` : "";
      if (firstIssue.path?.length) {
        return `Missing property ${firstIssue.path.at(-1)}${atPath2}`;
      }
      return `TODO Unknown missing property${atPath2}`;
    }
    case "invalid_literal":
      return `Expected literal value ${displayList(
        "or",
        firstIssue.expected,
        toDisplay
      )}${atPath} Got ${toDisplayAtPath(v2, path2)}`;
    case "invalid_length": {
      return `Expected array with length ${firstIssue.minLength === firstIssue.maxLength ? firstIssue.minLength : `between ${firstIssue.minLength} and ${firstIssue.maxLength}`}${atPath}. Got array with length ${v2.length}`;
    }
    case "unrecognized_keys":
      if (firstIssue.keys.length === 1) {
        return `Unexpected property ${firstIssue.keys[0]}${atPath}`;
      }
      return `Unexpected properties ${displayList(
        "and",
        firstIssue.keys
      )}${atPath}`;
    case "invalid_union":
      return schema2.name === "union" ? getDeepestUnionParseError(v2, schema2, mode ?? "strict") : `Invalid union value${atPath}`;
    case "custom_error": {
      const { error: error3 } = firstIssue;
      const message = !error3 ? "unknown" : typeof error3 === "string" ? error3 : error3.message ?? "unknown";
      return `${message}${atPath}. Got ${toDisplayAtPath(v2, path2)}`;
    }
  }
}
function getDeepestUnionParseError(value, schema2, mode) {
  const failures = [];
  for (const type of schema2.options) {
    const r3 = type.try(value, { mode });
    if (!r3.ok) {
      failures.push({ type, err: r3 });
    }
  }
  if (failures.length) {
    failures.sort(pathCmp);
    if (failures.length === 1 || pathCmp(failures[0], failures[1]) < 0) {
      return getMessage(failures[0].err, value, failures[0].type, mode);
    }
  }
  try {
    const str = JSON.stringify(value);
    return `Invalid union value: ${str}`;
  } catch (e3) {
    return `Invalid union value`;
  }
}
function pathCmp(a, b2) {
  const aPath = a.err.issues[0].path;
  const bPath = b2.err.issues[0].path;
  if (aPath.length !== bPath.length) {
    return bPath.length - aPath.length;
  }
  for (let i = 0; i < aPath.length; i++) {
    if (bPath[i] > aPath[i]) {
      return -1;
    }
    if (bPath[i] < aPath[i]) {
      return 1;
    }
  }
  return 0;
}
function parse4(value, schema2, mode) {
  const res = test(value, schema2, mode);
  if (!res.ok) {
    throw new TypeError(res.error);
  }
  return res.value;
}
function is2(value, schema2, mode) {
  return test(value, schema2, mode).ok;
}
function assert22(value, schema2, mode) {
  parse4(value, schema2, mode);
}
function test(value, schema2, mode) {
  const res = schema2.try(value, mode ? { mode } : void 0);
  if (!res.ok) {
    return {
      ok: false,
      error: getMessage(res, value, schema2, mode)
    };
  }
  return res;
}
function testOptional(value, schema2, mode) {
  let flags = 1;
  if (mode === "passthrough") {
    flags = 0;
  } else if (mode === "strip") {
    flags = 2;
  }
  const res = schema2.func(value, flags);
  if (res === void 0) {
    return { ok: true, value };
  } else if (res.ok) {
    return res;
  }
  const err2 = new ValitaError(res);
  return { ok: false, error: getMessage(err2, value, schema2, mode) };
}
function readonly(t22) {
  return t22;
}
function readonlyObject(t22) {
  return object(t22);
}
function readonlyArray(t22) {
  return array2(t22);
}
function readonlyRecord(t22) {
  return record(t22);
}
function instanceOfAbstractType(obj) {
  return obj instanceof AbstractType2;
}
function deepPartial(s3) {
  const shape = {};
  for (const [key2, type] of Object.entries(s3.shape)) {
    if (type.name === "object") {
      shape[key2] = deepPartial(type).optional();
    } else {
      shape[key2] = type.optional();
    }
  }
  return object(shape);
}
function toStringAndSlice(n2, len) {
  return n2.toString(32).slice(-len).padStart(len, "0");
}
function makeNewRandomHashFunctionInternal() {
  let base2 = "";
  let i = 0;
  return () => {
    if (!base2) {
      base2 = toStringAndSlice(randomUint64(), 12);
    }
    const tail = toStringAndSlice(i++, 10);
    return base2 + tail;
  };
}
function isHash(value) {
  return typeof value === "string" && hashRe.test(value);
}
function assertHash(value) {
  assert22(value, hashSchema);
}
function asRefs(sortedRefs) {
  return sortedRefs;
}
function toRefs(refs) {
  if (Array.isArray(refs)) {
    refs.sort();
    for (let i = 1; i < refs.length; i++) {
      assert3(refs[i - 1] !== refs[i], "Refs must not have duplicates");
    }
    return asRefs(refs);
  }
  const refsArray = [...refs];
  refsArray.sort();
  return asRefs(refsArray);
}
function assertRefs(v2) {
  if (!Array.isArray(v2)) {
    throw new Error("Refs must be an array");
  }
  if (v2.length > 0) {
    assertString(v2[0]);
    for (let i = 1; i < v2.length; i++) {
      assertString(v2[i]);
    }
  }
}
function createChunk(data, refs, chunkHasher) {
  const hash22 = chunkHasher();
  return new Chunk(hash22, data, refs);
}
function computeRefCountUpdates(headChanges, putChunks, delegate) {
  return new RefCountUpdates(headChanges, putChunks, delegate).compute();
}
function chunkDataKey(hash22) {
  return `c/${hash22}/d`;
}
function chunkMetaKey(hash22) {
  return `c/${hash22}/m`;
}
function chunkRefCountKey(hash22) {
  return `c/${hash22}/r`;
}
function headKey(name) {
  return `h/${name}`;
}
async function mustGetChunk(store, hash22) {
  const chunk = await store.getChunk(hash22);
  if (chunk) {
    return chunk;
  }
  throw new ChunkNotFoundError(hash22);
}
async function mustGetHeadHash(name, store) {
  const hash22 = await store.getHead(name);
  assert3(hash22, `Missing head ${name}`);
  return hash22;
}
async function setDeletedClients(dagWrite, clientIDs, clientGroupIDs) {
  const data = {
    clientIDs: normalize(clientIDs),
    clientGroupIDs: normalize(clientGroupIDs)
  };
  const chunkData = deepFreeze(data);
  const chunk = dagWrite.createChunk(chunkData, []);
  await dagWrite.putChunk(chunk);
  await dagWrite.setHead(DELETED_CLIENTS_HEAD_NAME, chunk.hash);
  return data;
}
async function getDeletedClients(dagRead) {
  const hash22 = await dagRead.getHead(DELETED_CLIENTS_HEAD_NAME);
  if (hash22 === void 0) {
    return { clientIDs: [], clientGroupIDs: [] };
  }
  const chunk = await dagRead.mustGetChunk(hash22);
  const res = test(chunk.data, legacyDeletedClientsSchema);
  if (res.ok) {
    return { clientIDs: res.value, clientGroupIDs: [] };
  }
  return parse4(chunk.data, deletedClientsSchema);
}
async function addDeletedClients(dagWrite, clientIDs, clientGroupIDs) {
  const { clientIDs: oldClientIDs, clientGroupIDs: oldClientGroupIDs } = await getDeletedClients(dagWrite);
  return setDeletedClients(
    dagWrite,
    [...oldClientIDs, ...clientIDs],
    [...oldClientGroupIDs, ...clientGroupIDs]
  );
}
async function removeDeletedClients(dagWrite, clientIDs, clientGroupIDs) {
  const { clientIDs: oldClientIDs, clientGroupIDs: oldClientGroupIDs } = await getDeletedClients(dagWrite);
  const newDeletedClients = oldClientIDs.filter(
    (clientID) => !clientIDs.includes(clientID)
  );
  const newDeletedClientGroups = oldClientGroupIDs.filter(
    (clientGroupID) => !clientGroupIDs.includes(clientGroupID)
  );
  return setDeletedClients(dagWrite, newDeletedClients, newDeletedClientGroups);
}
function normalize(arr2) {
  return [...new Set(arr2)].sort();
}
function createLogContext(logLevel = "info", logSinks = [consoleLogSink], context3) {
  const logSink = logSinks.length === 1 ? logSinks[0] : new TeeLogSink(logSinks);
  return new LogContext(logLevel, context3, logSink);
}
function dropMemStore(name) {
  stores.delete(name);
  return promiseVoid;
}
function isFirefoxPrivateBrowsingError(e3) {
  return isFirefox() && e3 instanceof DOMException && e3.name === "InvalidStateError" && e3.message === "A mutation operation was attempted on a database that did not allow mutations.";
}
function isFirefox() {
  return localNavigator?.userAgent.includes("Firefox") ?? false;
}
function newIDBStoreWithMemFallback(lc, name) {
  if (isFirefox()) {
    return new IDBStoreWithMemFallback(lc, name);
  }
  return new IDBStore(name);
}
function dropIDBStoreWithMemFallback(name) {
  if (!isFirefox()) {
    return dropIDBStore(name);
  }
  try {
    return dropIDBStore(name);
  } catch (e3) {
    if (isFirefoxPrivateBrowsingError(e3)) {
      return dropMemStore(name);
    }
  }
  return promiseVoid;
}
function dropIDBStore(name) {
  return new Promise((resolve2, reject) => {
    const req = indexedDB.deleteDatabase(name);
    req.onsuccess = () => resolve2();
    req.onerror = () => reject(req.error);
  });
}
function getDocumentVisibilityWatcher(doc, hiddenIntervalMS, signal) {
  return doc ? new DocumentVisibilityWatcherImpl(doc, hiddenIntervalMS, signal) : new DocumentVisibilityWatcherNoDoc();
}
function closeError() {
  return new Error("Closed");
}
function computeDelayAndUpdateDurations(delay, delegate, sendRecords) {
  const { length } = sendRecords;
  if (length === 0) {
    return delay;
  }
  const { ok: ok2 } = sendRecords[sendRecords.length - 1];
  const { maxConnections, minDelayMs } = delegate;
  if (!ok2) {
    return delay === 0 ? minDelayMs : delay * 2;
  }
  if (length > 1) {
    const previous = sendRecords[sendRecords.length - 2];
    while (sendRecords.length > CONNECTION_MEMORY_COUNT) {
      sendRecords.shift();
    }
    if (ok2 && !previous.ok) {
      return minDelayMs;
    }
  }
  const med = median(
    sendRecords.filter(({ ok: ok3 }) => ok3).map(({ duration }) => duration)
  );
  return med / maxConnections | 0;
}
function median(values2) {
  values2.sort();
  const { length } = values2;
  const half = length >> 1;
  if (length % 2 === 1) {
    return values2[half];
  }
  return (values2[half - 1] + values2[half]) / 2;
}
function didLastSendRequestFail(sendRecords) {
  return sendRecords.length > 0 && !sendRecords[sendRecords.length - 1].ok;
}
function recovered(sendRecords) {
  return sendRecords.length > 1 && !sendRecords[sendRecords.length - 2].ok && sendRecords[sendRecords.length - 1].ok;
}
function* joinIterables(...iters) {
  for (const iter of iters) {
    yield* iter;
  }
}
function* filterIter(iter, p) {
  let index10 = 0;
  for (const t22 of iter) {
    if (p(t22, index10++)) {
      yield t22;
    }
  }
}
function* mapIter(iter, f) {
  let index10 = 0;
  for (const t22 of iter) {
    yield f(t22, index10++);
  }
}
function wrapIterable(iter) {
  return new IterWrapper(iter);
}
function* mergeIterables(iterables, comparator2, distinct = false) {
  const iterators = iterables.map((i) => i[Symbol.iterator]());
  try {
    const current = iterators.map((i) => i.next());
    let lastYielded;
    while (current.some((c2) => !c2.done)) {
      const min = current.reduce(
        (acc, c2, i) => {
          if (c2.done) {
            return acc;
          }
          if (acc === void 0 || comparator2(c2.value, acc[0]) < 0) {
            return [c2.value, i];
          }
          return acc;
        },
        void 0
      );
      assert3(min !== void 0, "min is undefined");
      current[min[1]] = iterators[min[1]].next();
      if (lastYielded !== void 0 && distinct && comparator2(lastYielded, min[0]) === 0) {
        continue;
      }
      lastYielded = min[0];
      yield min[0];
    }
  } finally {
    for (const it of iterators) {
      it.return?.();
    }
  }
}
function getSizeOfValue(value) {
  switch (typeof value) {
    case "string":
      return SIZE_TAG + SIZE_INT32 + value.length;
    case "number":
      if (isSmi(value)) {
        if (value <= -(2 ** 30) || value >= 2 ** 30 - 1) {
          return SIZE_TAG + SIZE_SMI;
        }
        return SIZE_TAG + SIZE_INT32;
      }
      return SIZE_TAG + SIZE_DOUBLE;
    case "boolean":
      return SIZE_TAG;
    case "object":
      if (value === null) {
        return SIZE_TAG;
      }
      if (Array.isArray(value)) {
        let sum = 2 * SIZE_TAG + SIZE_INT32;
        for (const element of value) {
          sum += getSizeOfValue(element);
        }
        return sum;
      }
      {
        const val = value;
        let sum = 2 * SIZE_TAG + SIZE_INT32;
        for (const k in val) {
          if (hasOwn(val, k)) {
            const propertyValue = val[k];
            if (propertyValue !== void 0) {
              sum += getSizeOfValue(k) + getSizeOfValue(propertyValue);
            }
          }
        }
        return sum;
      }
  }
  throw new Error(`Invalid value. type: ${typeof value}, value: ${value}`);
}
function isSmi(value) {
  return value === (value | 0);
}
function getSizeOfEntry(key2, value) {
  return entryFixed + getSizeOfValue(key2) + getSizeOfValue(value);
}
function commitIsLocalDD31(commit) {
  return isLocalMetaDD31(commit.meta);
}
function commitIsLocal(commit) {
  return commitIsLocalDD31(commit);
}
function commitIsSnapshot(commit) {
  return isSnapshotMetaDD31(commit.meta);
}
async function getMutationID(clientID, dagRead, meta) {
  switch (meta.type) {
    case SnapshotDD31:
      return meta.lastMutationIDs[clientID] ?? 0;
    case LocalDD31: {
      if (meta.clientID === clientID) {
        return meta.mutationID;
      }
      const { basisHash } = meta;
      const basisCommit = await commitFromHash(basisHash, dagRead);
      return getMutationID(clientID, dagRead, basisCommit.meta);
    }
    default:
      unreachable(meta);
  }
}
async function localMutations(fromCommitHash, dagRead) {
  const commits = await commitChain(fromCommitHash, dagRead);
  return commits.filter((c2) => commitIsLocal(c2));
}
async function localMutationsDD31(fromCommitHash, dagRead) {
  const commits = await commitChain(fromCommitHash, dagRead);
  return commits.filter((c2) => commitIsLocalDD31(c2));
}
async function localMutationsGreaterThan(commit, mutationIDLimits, dagRead) {
  const commits = [];
  const remainingMutationIDLimits = new Map(Object.entries(mutationIDLimits));
  while (!commitIsSnapshot(commit) && remainingMutationIDLimits.size > 0) {
    if (commitIsLocalDD31(commit)) {
      const { meta } = commit;
      const mutationIDLowerLimit = remainingMutationIDLimits.get(meta.clientID);
      if (mutationIDLowerLimit !== void 0) {
        if (meta.mutationID <= mutationIDLowerLimit) {
          remainingMutationIDLimits.delete(meta.clientID);
        } else {
          commits.push(commit);
        }
      }
    }
    const { basisHash } = commit.meta;
    if (basisHash === null) {
      throw new Error(`Commit ${commit.chunk.hash} has no basis`);
    }
    commit = await commitFromHash(basisHash, dagRead);
  }
  return commits;
}
async function baseSnapshotFromHead(name, dagRead) {
  const hash22 = await dagRead.getHead(name);
  assert3(hash22, `Missing head ${name}`);
  return baseSnapshotFromHash(hash22, dagRead);
}
async function baseSnapshotHashFromHash(hash22, dagRead) {
  return (await baseSnapshotFromHash(hash22, dagRead)).chunk.hash;
}
async function baseSnapshotFromHash(hash22, dagRead) {
  const commit = await commitFromHash(hash22, dagRead);
  return baseSnapshotFromCommit(commit, dagRead);
}
async function baseSnapshotFromCommit(commit, dagRead) {
  while (!commitIsSnapshot(commit)) {
    const { meta } = commit;
    if (isLocalMetaDD31(meta)) {
      commit = await commitFromHash(meta.baseSnapshotHash, dagRead);
    } else {
      const { basisHash } = meta;
      if (basisHash === null) {
        throw new Error(`Commit ${commit.chunk.hash} has no basis`);
      }
      commit = await commitFromHash(basisHash, dagRead);
    }
  }
  return commit;
}
function snapshotMetaParts(c2, clientID) {
  const m = c2.meta;
  const lmid = m.lastMutationIDs[clientID] ?? 0;
  return [lmid, m.cookieJSON];
}
function compareCookiesForSnapshots(a, b2) {
  return compareCookies(a.meta.cookieJSON, b2.meta.cookieJSON);
}
async function commitChain(fromCommitHash, dagRead) {
  let commit = await commitFromHash(fromCommitHash, dagRead);
  const commits = [];
  while (!commitIsSnapshot(commit)) {
    const { meta } = commit;
    const { basisHash } = meta;
    if (basisHash === null) {
      throw new Error(`Commit ${commit.chunk.hash} has no basis`);
    }
    commits.push(commit);
    commit = await commitFromHash(basisHash, dagRead);
  }
  commits.push(commit);
  return commits;
}
async function commitFromHash(hash22, dagRead) {
  const chunk = await dagRead.mustGetChunk(hash22);
  return fromChunk(chunk);
}
async function commitFromHead(name, dagRead) {
  const hash22 = await mustGetHeadHash(name, dagRead);
  return commitFromHash(hash22, dagRead);
}
function assertLocalMetaDD31(v2) {
  assertString(v2.clientID);
  assertNumber(v2.mutationID);
  assertString(v2.mutatorName);
  if (!v2.mutatorName) {
    throw new Error("Missing mutator name");
  }
  assertJSONValue(v2.mutatorArgsJSON);
  if (v2.originalHash !== null) {
    assertHash(v2.originalHash);
  }
  assertNumber(v2.timestamp);
}
function isLocalMetaDD31(meta) {
  return meta.type === LocalDD31;
}
function assertSnapshotMetaDD31(v2) {
  if (v2.basisHash !== null) {
    assertHash(v2.basisHash);
  }
  assertJSONValue(v2.cookieJSON);
  assertLastMutationIDs(v2.lastMutationIDs);
}
function assertLastMutationIDs(v2) {
  assertObject(v2);
  for (const e3 of Object.values(v2)) {
    assertNumber(e3);
  }
}
function assertSnapshotCommitDD31(c2) {
  assertSnapshotMetaDD31(c2.meta);
}
function isSnapshotMetaDD31(meta) {
  return meta.type === SnapshotDD31;
}
function assertMeta(v2) {
  assertObject(v2);
  assertDeepFrozen(v2);
  if (v2.basisHash !== null) {
    assertString(v2.basisHash);
  }
  assertNumber(v2.type);
  switch (v2.type) {
    case LocalDD31:
      assertLocalMetaDD31(v2);
      break;
    case SnapshotDD31:
      assertSnapshotMetaDD31(v2);
      break;
    default:
      throw new Error(`Invalid enum value ${v2.type}`);
  }
}
function chunkIndexDefinitionEqualIgnoreName(a, b2) {
  return a.jsonPointer === b2.jsonPointer && (a.allowEmpty ?? false) === (b2.allowEmpty ?? false) && a.keyPrefix === b2.keyPrefix;
}
function assertChunkIndexDefinition(v2) {
  assertObject(v2);
  assertDeepFrozen(v2);
  assertString(v2.name);
  assertString(v2.keyPrefix);
  assertString(v2.jsonPointer);
  if (v2.allowEmpty !== void 0) {
    assertBoolean(v2.allowEmpty);
  }
}
function toChunkIndexDefinition(name, indexDefinition) {
  return {
    name,
    keyPrefix: indexDefinition.prefix ?? "",
    jsonPointer: indexDefinition.jsonPointer,
    allowEmpty: indexDefinition.allowEmpty ?? false
  };
}
function assertIndexRecord(v2) {
  assertObject(v2);
  assertDeepFrozen(v2);
  assertChunkIndexDefinition(v2.definition);
  assertString(v2.valueHash);
}
function assertIndexRecords(v2) {
  assertArray(v2);
  assertDeepFrozen(v2);
  for (const ir of v2) {
    assertIndexRecord(ir);
  }
}
function newLocalDD31(createChunk2, basisHash, baseSnapshotHash, mutationID, mutatorName, mutatorArgsJSON, originalHash, valueHash, indexes, timestamp2, clientID) {
  const meta = {
    type: LocalDD31,
    basisHash,
    baseSnapshotHash,
    mutationID,
    mutatorName,
    mutatorArgsJSON,
    originalHash,
    timestamp: timestamp2,
    clientID
  };
  return commitFromCommitData(
    createChunk2,
    makeCommitData(meta, valueHash, indexes)
  );
}
function newSnapshotDD31(createChunk2, basisHash, lastMutationIDs, cookieJSON, valueHash, indexes) {
  return commitFromCommitData(
    createChunk2,
    newSnapshotCommitDataDD31(
      basisHash,
      lastMutationIDs,
      cookieJSON,
      valueHash,
      indexes
    )
  );
}
function newSnapshotCommitDataDD31(basisHash, lastMutationIDs, cookieJSON, valueHash, indexes) {
  const meta = {
    type: SnapshotDD31,
    basisHash,
    lastMutationIDs,
    cookieJSON
  };
  return makeCommitData(meta, valueHash, indexes);
}
function fromChunk(chunk) {
  validateChunk(chunk);
  return new Commit(chunk);
}
function commitFromCommitData(createChunk2, data) {
  return new Commit(createChunk2(data, getRefs(data)));
}
function getRefs(data) {
  const refs = /* @__PURE__ */ new Set();
  refs.add(data.valueHash);
  const { meta } = data;
  switch (meta.type) {
    case LocalDD31:
      meta.basisHash && refs.add(meta.basisHash);
      break;
    case SnapshotDD31:
      break;
    default:
      unreachable(meta);
  }
  for (const index10 of data.indexes) {
    refs.add(index10.valueHash);
  }
  return toRefs(refs);
}
function makeCommitData(meta, valueHash, indexes) {
  return deepFreeze({
    meta,
    valueHash,
    indexes
  });
}
function assertCommitData(v2) {
  if (isProd) {
    return;
  }
  assertObject(v2);
  assertDeepFrozen(v2);
  assertMeta(v2.meta);
  assertString(v2.valueHash);
  assertIndexRecords(v2.indexes);
}
function validateChunk(chunk) {
  const { data } = chunk;
  assertCommitData(data);
  const seen = /* @__PURE__ */ new Set();
  for (const index10 of data.indexes) {
    const { name } = index10.definition;
    if (seen.has(name)) {
      throw new Error(`Duplicate index ${name}`);
    }
    seen.add(name);
  }
}
function binarySearch2(high, compare) {
  let low = 0;
  while (low < high) {
    const mid = low + (high - low >> 1);
    const i = compare(mid);
    if (i === 0) {
      return mid;
    }
    if (i > 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function makeNodeChunkData(level, entries, formatVersion) {
  return deepFreeze([
    level,
    formatVersion >= V7 ? entries : entries.map((e3) => e3.slice(0, 2))
  ]);
}
async function findLeaf(key2, hash22, source2, expectedRootHash) {
  const node = await source2.getNode(hash22);
  if (expectedRootHash !== source2.rootHash) {
    return findLeaf(key2, source2.rootHash, source2, source2.rootHash);
  }
  if (isDataNodeImpl(node)) {
    return node;
  }
  const { entries } = node;
  let i = binarySearch22(key2, entries);
  if (i === entries.length) {
    i--;
  }
  const entry = entries[i];
  return findLeaf(key2, entry[1], source2, expectedRootHash);
}
function binarySearch22(key2, entries) {
  return binarySearch2(
    entries.length,
    (i) => compareUTF8(key2, entries[i][0])
  );
}
function binarySearchFound(i, entries, key2) {
  return i !== entries.length && entries[i][0] === key2;
}
function parseBTreeNode(v2, formatVersion, getSizeOfEntry2) {
  if (isProd && formatVersion >= V7) {
    return v2;
  }
  assertArray(v2);
  assertDeepFrozen(v2);
  assert3(v2.length >= 2);
  const [level, entries] = v2;
  assertNumber(level);
  assertArray(entries);
  const f = level > 0 ? assertString : assertJSONValue;
  if (formatVersion >= V7) {
    for (const e3 of entries) {
      assertEntry(e3, f);
    }
    return v2;
  }
  const newEntries = entries.map((e3) => convertNonV7Entry(e3, f, getSizeOfEntry2));
  return [level, newEntries];
}
function assertEntry(entry, f) {
  assertArray(entry);
  assert3(entry.length >= 3);
  assertString(entry[0]);
  f(entry[1]);
  assertNumber(entry[2]);
}
function convertNonV7Entry(entry, f, getSizeOfEntry2) {
  assertArray(entry);
  assert3(entry.length >= 2);
  assertString(entry[0]);
  f(entry[1]);
  const entrySize = getSizeOfEntry2(entry[0], entry[1]);
  return [entry[0], entry[1], entrySize];
}
function toChunkData(node, formatVersion) {
  return makeNodeChunkData(node.level, node.entries, formatVersion);
}
function readonlySplice(array8, start, deleteCount, ...items) {
  const arr2 = array8.slice(0, start);
  for (let i = 0; i < items.length; i++) {
    arr2.push(items[i]);
  }
  for (let i = start + deleteCount; i < array8.length; i++) {
    arr2.push(array8[i]);
  }
  return arr2;
}
function newNodeImpl(entries, hash22, level, isMutable) {
  if (level === 0) {
    return new DataNodeImpl(
      entries,
      hash22,
      isMutable
    );
  }
  return new InternalNodeImpl(entries, hash22, level, isMutable);
}
function isDataNodeImpl(node) {
  return node.level === 0;
}
function partition(values2, getSizeOfEntry2, min, max) {
  const partitions = [];
  const sizes = [];
  let sum = 0;
  let accum = [];
  for (const value of values2) {
    const size2 = getSizeOfEntry2(value);
    if (size2 >= max) {
      if (accum.length > 0) {
        partitions.push(accum);
        sizes.push(sum);
      }
      partitions.push([value]);
      sizes.push(size2);
      sum = 0;
      accum = [];
    } else if (sum + size2 >= min) {
      accum.push(value);
      partitions.push(accum);
      sizes.push(sum + size2);
      sum = 0;
      accum = [];
    } else {
      sum += size2;
      accum.push(value);
    }
  }
  if (sum > 0) {
    if (sizes.length > 0 && sum + sizes[sizes.length - 1] <= max) {
      partitions[partitions.length - 1].push(...accum);
    } else {
      partitions.push(accum);
    }
  }
  return partitions;
}
function createNewInternalEntryForNode(node, getSizeOfEntry2) {
  const key2 = node.maxKey();
  const value = node.hash;
  const size2 = getSizeOfEntry2(key2, value);
  return [key2, value, size2];
}
function* computeSplices(previous, current) {
  let previousIndex = 0;
  let currentIndex = 0;
  let splice;
  function ensureAssigned(splice2, index10) {
    if (splice2[SPLICE_FROM] === SPLICE_UNASSIGNED) {
      splice2[SPLICE_FROM] = index10;
    }
  }
  __name(ensureAssigned, "ensureAssigned");
  function newSplice() {
    return [previousIndex, 0, 0, SPLICE_UNASSIGNED];
  }
  __name(newSplice, "newSplice");
  while (previousIndex < previous.length && currentIndex < current.length) {
    if (previous[previousIndex][KEY] === current[currentIndex][KEY]) {
      if (deepEqual(
        // These are really Hash | InternalValue
        previous[previousIndex][VALUE],
        current[currentIndex][VALUE]
      )) {
        if (splice) {
          ensureAssigned(splice, 0);
          yield splice;
          splice = void 0;
        }
      } else {
        if (!splice) {
          splice = newSplice();
        }
        splice[SPLICE_ADDED]++;
        splice[SPLICE_REMOVED]++;
        ensureAssigned(splice, currentIndex);
      }
      previousIndex++;
      currentIndex++;
    } else if (previous[previousIndex][KEY] < current[currentIndex][KEY]) {
      if (!splice) {
        splice = newSplice();
      }
      splice[SPLICE_REMOVED]++;
      previousIndex++;
    } else {
      if (!splice) {
        splice = newSplice();
      }
      splice[SPLICE_ADDED]++;
      ensureAssigned(splice, currentIndex);
      currentIndex++;
    }
  }
  if (currentIndex < current.length) {
    if (!splice) {
      splice = newSplice();
    }
    splice[SPLICE_ADDED] += current.length - currentIndex;
    ensureAssigned(splice, currentIndex);
  }
  if (previousIndex < previous.length) {
    if (!splice) {
      splice = newSplice();
    }
    splice[SPLICE_REMOVED] += previous.length - previousIndex;
  }
  if (splice) {
    ensureAssigned(splice, 0);
    yield splice;
  }
}
async function* diffNodes(last, current, lastTree, currentTree) {
  if (last.level > current.level) {
    const lastChild = await last.getCompositeChildren(
      0,
      last.entries.length,
      lastTree
    );
    yield* diffNodes(lastChild, current, lastTree, currentTree);
    return;
  }
  if (current.level > last.level) {
    const currentChild = await current.getCompositeChildren(
      0,
      current.entries.length,
      currentTree
    );
    yield* diffNodes(last, currentChild, lastTree, currentTree);
    return;
  }
  if (isDataNodeImpl(last) && isDataNodeImpl(current)) {
    yield* diffEntries(
      last.entries,
      current.entries
    );
    return;
  }
  const initialSplices = computeSplices(
    last.entries,
    current.entries
  );
  for (const splice of initialSplices) {
    const [lastChild, currentChild] = await Promise.all([
      last.getCompositeChildren(
        splice[SPLICE_AT],
        splice[SPLICE_REMOVED],
        lastTree
      ),
      current.getCompositeChildren(
        splice[SPLICE_FROM],
        splice[SPLICE_ADDED],
        currentTree
      )
    ]);
    yield* diffNodes(lastChild, currentChild, lastTree, currentTree);
  }
}
function* diffEntries(lastEntries, currentEntries) {
  const lastLength = lastEntries.length;
  const currentLength = currentEntries.length;
  let i = 0;
  let j = 0;
  while (i < lastLength && j < currentLength) {
    const lastKey = lastEntries[i][0];
    const currentKey = currentEntries[j][0];
    if (lastKey === currentKey) {
      if (!deepEqual(lastEntries[i][1], currentEntries[j][1])) {
        yield {
          op: "change",
          key: lastKey,
          oldValue: lastEntries[i][1],
          newValue: currentEntries[j][1]
        };
      }
      i++;
      j++;
    } else if (lastKey < currentKey) {
      yield {
        op: "del",
        key: lastKey,
        oldValue: lastEntries[i][1]
      };
      i++;
    } else {
      yield {
        op: "add",
        key: currentKey,
        newValue: currentEntries[j][1]
      };
      j++;
    }
  }
  for (; i < lastLength; i++) {
    yield {
      op: "del",
      key: lastEntries[i][0],
      oldValue: lastEntries[i][1]
    };
  }
  for (; j < currentLength; j++) {
    yield {
      op: "add",
      key: currentEntries[j][0],
      newValue: currentEntries[j][1]
    };
  }
}
async function* scanForHash(expectedRootHash, getRootHash, hash22, fromKey, readNode) {
  if (hash22 === emptyHash) {
    return;
  }
  const data = await readNode(hash22);
  const entries = data[NODE_ENTRIES];
  let i = 0;
  if (fromKey) {
    i = binarySearch22(fromKey, entries);
  }
  if (data[NODE_LEVEL] > 0) {
    for (; i < entries.length; i++) {
      yield* scanForHash(
        expectedRootHash,
        getRootHash,
        entries[i][1],
        fromKey,
        readNode
      );
      fromKey = "";
    }
  } else {
    for (; i < entries.length; i++) {
      const rootHash = getRootHash();
      if (expectedRootHash !== rootHash) {
        yield* scanForHash(
          rootHash,
          getRootHash,
          rootHash,
          entries[i][0],
          readNode
        );
        return;
      }
      yield entries[i];
    }
  }
}
async function allEntriesAsDiff(map, op) {
  const diff3 = [];
  const make = op === "add" ? (entry) => ({
    op: "add",
    key: entry[0],
    newValue: entry[1]
  }) : (entry) => ({
    op: "del",
    key: entry[0],
    oldValue: entry[1]
  });
  for await (const entry of map.entries()) {
    diff3.push(make(entry));
  }
  return diff3;
}
async function indexValue(lc, index10, op, key2, val, jsonPointer, allowEmpty) {
  try {
    for (const entry of getIndexKeys(key2, val, jsonPointer, allowEmpty)) {
      switch (op) {
        case Add:
          await index10.put(entry, val);
          break;
        case Remove:
          await index10.del(entry);
          break;
      }
    }
  } catch (e3) {
    lc.info?.("Not indexing value", val, ":", e3);
  }
}
function getIndexKeys(primary, value, jsonPointer, allowEmpty) {
  const target = evaluateJSONPointer(value, jsonPointer);
  if (target === void 0) {
    if (allowEmpty) {
      return [];
    }
    throw new Error(`No value at path: ${jsonPointer}`);
  }
  const values2 = Array.isArray(target) ? target : [target];
  const indexKeys = [];
  for (const value2 of values2) {
    if (typeof value2 === "string") {
      indexKeys.push(encodeIndexKey([value2, primary]));
    } else {
      throw new Error("Unsupported target type");
    }
  }
  return indexKeys;
}
function encodeIndexKey(indexKey) {
  const secondary = indexKey[0];
  const primary = indexKey[1];
  if (secondary.includes("\0")) {
    throw new Error("Secondary key cannot contain null byte");
  }
  return KEY_VERSION_0 + secondary + KEY_SEPARATOR + primary;
}
function encodeIndexScanKey(secondary, primary) {
  const k = encodeIndexKey([secondary, primary || ""]);
  if (primary === void 0) {
    return k.slice(0, k.length - 1);
  }
  return k;
}
function decodeIndexKey(encodedIndexKey) {
  if (encodedIndexKey[0] !== KEY_VERSION_0) {
    throw new Error("Invalid version");
  }
  const versionLen = KEY_VERSION_0.length;
  const separatorLen = KEY_SEPARATOR.length;
  const separatorOffset = encodedIndexKey.indexOf(KEY_SEPARATOR, versionLen);
  if (separatorOffset === -1) {
    throw new Error("Invalid formatting");
  }
  const secondary = encodedIndexKey.slice(versionLen, separatorOffset);
  const primary = encodedIndexKey.slice(separatorOffset + separatorLen);
  return [secondary, primary];
}
function evaluateJSONPointer(value, pointer) {
  function parseIndex(s3) {
    if (s3.startsWith("+") || s3.startsWith("0") && s3.length !== 1) {
      return void 0;
    }
    return parseInt(s3, 10);
  }
  __name(parseIndex, "parseIndex");
  if (pointer === "") {
    return value;
  }
  if (!pointer.startsWith("/")) {
    throw new Error(`Invalid JSON pointer: ${pointer}`);
  }
  const tokens = pointer.split("/").slice(1).map((x) => x.replace(/~1/g, "/").replace(/~0/g, "~"));
  let target = value;
  for (const token of tokens) {
    let targetOpt;
    if (Array.isArray(target)) {
      const i = parseIndex(token);
      if (i === void 0) {
        return void 0;
      }
      targetOpt = target[i];
    } else if (target === null) {
      return void 0;
    } else if (typeof target === "object") {
      target = target;
      targetOpt = target[token];
    }
    if (targetOpt === void 0) {
      return void 0;
    }
    target = targetOpt;
  }
  return target;
}
function readFromDefaultHead(dagRead, formatVersion) {
  return readFromHead(DEFAULT_HEAD_NAME, dagRead, formatVersion);
}
async function readFromHead(name, dagRead, formatVersion) {
  const commit = await commitFromHead(name, dagRead);
  return readFromCommit(commit, dagRead, formatVersion);
}
async function readFromHash(hash22, dagRead, formatVersion) {
  const commit = await commitFromHash(hash22, dagRead);
  return readFromCommit(commit, dagRead, formatVersion);
}
function readFromCommit(commit, dagRead, formatVersion) {
  const indexes = readIndexesForRead(commit, dagRead, formatVersion);
  const map = new BTreeRead(dagRead, formatVersion, commit.valueHash);
  return new Read(dagRead, map, indexes);
}
function readIndexesForRead(commit, dagRead, formatVersion) {
  const m = /* @__PURE__ */ new Map();
  for (const index10 of commit.indexes) {
    m.set(
      index10.definition.name,
      new IndexRead(
        index10,
        new BTreeRead(dagRead, formatVersion, index10.valueHash)
      )
    );
  }
  return m;
}
async function asyncIterableToArray(it) {
  const arr2 = [];
  for await (const v2 of it) {
    arr2.push(v2);
  }
  return arr2;
}
function isScanIndexOptions(options2) {
  return options2.indexName !== void 0;
}
function normalizeScanOptionIndexedStartKey(startKey) {
  if (typeof startKey === "string") {
    return [startKey];
  }
  return startKey;
}
function toDbScanOptions(options2) {
  if (!options2) {
    return {};
  }
  let key2;
  let exclusive;
  let primary;
  let secondary;
  if (options2.start) {
    ({ key: key2, exclusive } = options2.start);
    if (options2.indexName) {
      if (typeof key2 === "string") {
        secondary = key2;
      } else {
        secondary = key2[0];
        primary = key2[1];
      }
    } else {
      primary = key2;
    }
  }
  return {
    prefix: options2.prefix,
    startSecondaryKey: secondary,
    startKey: primary,
    startExclusive: exclusive,
    limit: options2.limit,
    indexName: options2.indexName
  };
}
function throwIfClosed(tx) {
  if (tx.closed) {
    throw new TransactionClosedError();
  }
}
function rejectIfClosed(tx) {
  return tx.closed ? Promise.reject(new TransactionClosedError()) : void 0;
}
async function* scanIterator(toValue, iter, options2, closed, onLimitKey) {
  throwIfClosed(closed);
  let { limit = Infinity } = options2;
  const { prefix = "" } = options2;
  let exclusive = options2.start?.exclusive;
  const isIndexScan = isScanIndexOptions(options2);
  for await (const entry of iter) {
    const key2 = entry[0];
    const keyToMatch = isIndexScan ? key2[0] : key2;
    if (!keyToMatch.startsWith(prefix)) {
      return;
    }
    if (exclusive) {
      exclusive = true;
      if (isIndexScan) {
        if (shouldSkipIndexScan(key2, options2.start.key)) {
          continue;
        }
      } else {
        if (shouldSkipNonIndexScan(key2, options2.start.key)) {
          continue;
        }
      }
    }
    yield toValue(entry);
    if (--limit === 0) {
      if (!isIndexScan) {
        onLimitKey(key2);
      }
      return;
    }
  }
}
function shouldSkipIndexScan(key2, startKey) {
  const [secondaryStartKey, primaryStartKey] = normalizeScanOptionIndexedStartKey(startKey);
  const [secondaryKey, primaryKey] = normalizeScanOptionIndexedStartKey(key2);
  if (secondaryKey !== secondaryStartKey) {
    return false;
  }
  if (primaryStartKey === void 0) {
    return true;
  }
  return primaryKey === primaryStartKey;
}
function shouldSkipNonIndexScan(key2, startKey) {
  return key2 === startKey;
}
function fromKeyForIndexScanInternal(options2) {
  const { prefix, start } = options2;
  let prefix2 = "";
  if (prefix !== void 0) {
    prefix2 = encodeIndexScanKey(prefix, void 0);
  }
  if (!start) {
    return prefix2;
  }
  const { key: key2 } = start;
  const [secondary, primary] = normalizeScanOptionIndexedStartKey(key2);
  const startKey = encodeIndexScanKey(secondary, primary);
  if (greaterThan(startKey, prefix2)) {
    return startKey;
  }
  return prefix2;
}
function noop4(_) {
}
function scan(options2, dbRead, onLimitKey) {
  const iter = getScanIterator(dbRead, options2);
  return makeScanResultFromScanIteratorInternal(
    iter,
    options2 ?? {},
    dbRead,
    onLimitKey
  );
}
function getScanIterator(dbRead, options2) {
  if (options2 && isScanIndexOptions(options2)) {
    return getScanIteratorForIndexMap(dbRead, options2);
  }
  return dbRead.map.scan(fromKeyForNonIndexScan(options2));
}
function fromKeyForNonIndexScan(options2) {
  if (!options2) {
    return "";
  }
  const { prefix = "", start } = options2;
  if (start && greaterThan(start.key, prefix)) {
    return start.key;
  }
  return prefix;
}
function makeScanResultFromScanIteratorInternal(iter, options2, dbRead, onLimitKey) {
  return new ScanResultImpl(iter, options2, dbRead, onLimitKey);
}
async function* getScanIteratorForIndexMap(dbRead, options2) {
  const map = dbRead.getMapForIndex(options2.indexName);
  for await (const entry of map.scan(fromKeyForIndexScanInternal(options2))) {
    yield [decodeIndexKey(entry[0]), entry[1]];
  }
}
function diff(oldMap, newMap) {
  return asyncIterableToArray(newMap.diff(oldMap));
}
function gatherNewChunks(hash22, newChunks, createChunk2, modified, formatVersion) {
  const node = modified.get(hash22);
  if (node === void 0) {
    return hash22;
  }
  if (isDataNodeImpl(node)) {
    const chunk2 = createChunk2(toChunkData(node, formatVersion), []);
    newChunks.push(chunk2);
    return chunk2.hash;
  }
  const refs = [];
  const { entries } = node;
  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    const childHash = entry[1];
    const newChildHash = gatherNewChunks(
      childHash,
      newChunks,
      createChunk2,
      modified,
      formatVersion
    );
    if (newChildHash !== childHash) {
      entries[i] = [entry[0], newChildHash, entry[2]];
    }
    refs.push(newChildHash);
  }
  const chunk = createChunk2(toChunkData(node, formatVersion), toRefs(refs));
  newChunks.push(chunk);
  return chunk.hash;
}
function lazy2(factory) {
  let value;
  return () => {
    if (value === void 0) {
      value = factory();
    }
    return value;
  };
}
async function diff2(oldHash, newHash, read, diffConfig, formatVersion) {
  const [oldCommit, newCommit] = await Promise.all([
    commitFromHash(oldHash, read),
    commitFromHash(newHash, read)
  ]);
  return diffCommits(oldCommit, newCommit, read, diffConfig, formatVersion);
}
async function diffCommits(oldCommit, newCommit, read, diffConfig, formatVersion) {
  const diffsMap = new DiffsMap();
  if (!diffConfig.shouldComputeDiffs()) {
    return diffsMap;
  }
  const oldMap = new BTreeRead(read, formatVersion, oldCommit.valueHash);
  const newMap = new BTreeRead(read, formatVersion, newCommit.valueHash);
  const valueDiff = await diff(oldMap, newMap);
  diffsMap.set("", valueDiff);
  await addDiffsForIndexes(
    oldCommit,
    newCommit,
    read,
    diffsMap,
    diffConfig,
    formatVersion
  );
  return diffsMap;
}
async function addDiffsForIndexes(mainCommit, syncCommit, read, diffsMap, diffConfig, formatVersion) {
  const oldIndexes = readIndexesForRead(mainCommit, read, formatVersion);
  const newIndexes = readIndexesForRead(syncCommit, read, formatVersion);
  for (const [oldIndexName, oldIndex] of oldIndexes) {
    if (!diffConfig.shouldComputeDiffsForIndex(oldIndexName)) {
      continue;
    }
    const newIndex = newIndexes.get(oldIndexName);
    if (newIndex !== void 0) {
      assert3(newIndex !== oldIndex);
      const diffs = await diff(oldIndex.map, newIndex.map);
      newIndexes.delete(oldIndexName);
      diffsMap.set(oldIndexName, diffs);
    } else {
      const diffs = await allEntriesAsDiff(oldIndex.map, "del");
      diffsMap.set(oldIndexName, diffs);
    }
  }
  for (const [newIndexName, newIndex] of newIndexes) {
    if (!diffConfig.shouldComputeDiffsForIndex(newIndexName)) {
      continue;
    }
    const diffs = await allEntriesAsDiff(newIndex.map, "add");
    diffsMap.set(newIndexName, diffs);
  }
}
async function newWriteLocal(basisHash, mutatorName, mutatorArgsJSON, originalHash, dagWrite, timestamp2, clientID, formatVersion) {
  const basis = await commitFromHash(basisHash, dagWrite);
  const bTreeWrite = new BTreeWrite(dagWrite, formatVersion, basis.valueHash);
  const mutationID = await basis.getNextMutationID(clientID, dagWrite);
  const indexes = readIndexesForWrite(basis, dagWrite, formatVersion);
  assert3(formatVersion >= DD31);
  return new Write(
    dagWrite,
    bTreeWrite,
    basis,
    {
      type: LocalDD31,
      basisHash,
      baseSnapshotHash: await baseSnapshotHashFromHash(basisHash, dagWrite),
      mutatorName,
      mutatorArgsJSON,
      mutationID,
      originalHash,
      timestamp: timestamp2,
      clientID
    },
    indexes,
    clientID,
    formatVersion
  );
}
async function newWriteSnapshotDD31(basisHash, lastMutationIDs, cookieJSON, dagWrite, clientID, formatVersion) {
  const basis = await commitFromHash(basisHash, dagWrite);
  const bTreeWrite = new BTreeWrite(dagWrite, formatVersion, basis.valueHash);
  return new Write(
    dagWrite,
    bTreeWrite,
    basis,
    { basisHash, type: SnapshotDD31, lastMutationIDs, cookieJSON },
    readIndexesForWrite(basis, dagWrite, formatVersion),
    clientID,
    formatVersion
  );
}
async function updateIndexes(lc, indexes, key2, oldValGetter, newVal) {
  const ps = [];
  for (const idx of indexes.values()) {
    const { keyPrefix } = idx.meta.definition;
    if (!keyPrefix || key2.startsWith(keyPrefix)) {
      const oldVal = await oldValGetter();
      if (oldVal !== void 0) {
        ps.push(
          indexValue(
            lc,
            idx.map,
            Remove,
            key2,
            oldVal,
            idx.meta.definition.jsonPointer,
            idx.meta.definition.allowEmpty ?? false
          )
        );
      }
      if (newVal !== void 0) {
        ps.push(
          indexValue(
            lc,
            idx.map,
            Add,
            key2,
            newVal,
            idx.meta.definition.jsonPointer,
            idx.meta.definition.allowEmpty ?? false
          )
        );
      }
    }
  }
  await Promise.all(ps);
}
function readIndexesForWrite(commit, dagWrite, formatVersion) {
  const m = /* @__PURE__ */ new Map();
  for (const index10 of commit.indexes) {
    m.set(
      index10.definition.name,
      new IndexWrite(
        index10,
        new BTreeWrite(dagWrite, formatVersion, index10.valueHash)
      )
    );
  }
  return m;
}
async function createIndexBTree(lc, dagWrite, valueMap, prefix, jsonPointer, allowEmpty, formatVersion) {
  const indexMap = new BTreeWrite(dagWrite, formatVersion);
  for await (const entry of valueMap.scan(prefix)) {
    const key2 = entry[0];
    if (!key2.startsWith(prefix)) {
      break;
    }
    await indexValue(
      lc,
      indexMap,
      Add,
      key2,
      entry[1],
      jsonPointer,
      allowEmpty
    );
  }
  return indexMap;
}
async function rebaseMutation(mutation, dagWrite, basisHash, mutators, lc, mutationClientID, formatVersion, zeroData2) {
  const localMeta = mutation.meta;
  const name = localMeta.mutatorName;
  if (isLocalMetaDD31(localMeta)) {
    assert3(
      localMeta.clientID === mutationClientID,
      "mutationClientID must match clientID of LocalMeta"
    );
  }
  const maybeMutatorImpl = mutators[name];
  if (!maybeMutatorImpl) {
    lc.error?.(`Cannot rebase unknown mutator ${name}`);
  }
  const mutatorImpl = maybeMutatorImpl || (async () => {
  });
  const args = localMeta.mutatorArgsJSON;
  const basisCommit = await commitFromHash(basisHash, dagWrite);
  const nextMutationID = await basisCommit.getNextMutationID(
    mutationClientID,
    dagWrite
  );
  if (nextMutationID !== localMeta.mutationID) {
    throw new Error(
      `Inconsistent mutation ID: original: ${localMeta.mutationID}, next: ${nextMutationID} - mutationClientID: ${mutationClientID} mutatorName: ${name}`
    );
  }
  if (formatVersion >= DD31) {
    assertLocalMetaDD31(localMeta);
  }
  const dbWrite = await newWriteLocal(
    basisHash,
    name,
    args,
    mutation.chunk.hash,
    dagWrite,
    localMeta.timestamp,
    mutationClientID,
    formatVersion
  );
  const tx = new WriteTransactionImpl(
    mutationClientID,
    await dbWrite.getMutationID(),
    "rebase",
    zeroData2,
    dbWrite,
    lc
  );
  await mutatorImpl(tx, args);
  return dbWrite;
}
async function rebaseMutationAndPutCommit(mutation, dagWrite, basis, mutators, lc, mutationClientID, formatVersion, zeroData2) {
  const tx = await rebaseMutation(
    mutation,
    dagWrite,
    basis,
    mutators,
    lc,
    mutationClientID,
    formatVersion,
    zeroData2
  );
  return tx.putCommit();
}
async function rebaseMutationAndCommit(mutation, dagWrite, basis, headName, mutators, lc, mutationClientID, formatVersion, zeroData2) {
  const dbWrite = await rebaseMutation(
    mutation,
    dagWrite,
    basis,
    mutators,
    lc,
    mutationClientID,
    formatVersion,
    zeroData2
  );
  return dbWrite.commit(headName);
}
function getDefaultPusher(rep) {
  async function pusher(requestBody, requestID) {
    const [response, httpRequestInfo] = await callDefaultFetch(
      rep.pushURL,
      rep.auth,
      requestID,
      requestBody
    );
    if (!response) {
      return { httpRequestInfo };
    }
    const rv = {
      httpRequestInfo
    };
    let result;
    try {
      result = await response.json();
    } catch {
      return rv;
    }
    if (isClientStateNotFoundResponse(result) || isVersionNotSupportedResponse(result)) {
      rv.response = result;
    }
    return rv;
  }
  __name(pusher, "pusher");
  defaultPushers.add(pusher);
  return pusher;
}
function isDefaultPusher(pusher) {
  return defaultPushers.has(pusher);
}
function indexDefinitionEqual(a, b2) {
  return a.jsonPointer === b2.jsonPointer && (a.allowEmpty ?? false) === (b2.allowEmpty ?? false) && (a.prefix ?? "") === (b2.prefix ?? "");
}
function indexDefinitionsEqual(a, b2) {
  if (Object.keys(a).length !== Object.keys(b2).length) {
    return false;
  }
  for (const [aKey, aValue] of Object.entries(a)) {
    const bValue = b2[aKey];
    if (!bValue || !indexDefinitionEqual(aValue, bValue)) {
      return false;
    }
  }
  return true;
}
function assertClientGroup(value) {
  assert22(value, clientGroupSchema);
}
function chunkDataToClientGroupMap(chunkData) {
  assertObject(chunkData);
  const clientGroups = /* @__PURE__ */ new Map();
  for (const [key2, value] of Object.entries(chunkData)) {
    if (value !== void 0) {
      assertClientGroup(value);
      clientGroups.set(key2, value);
    }
  }
  return clientGroups;
}
function clientGroupMapToChunkData(clientGroups, dagWrite) {
  const chunkData = {};
  for (const [clientGroupID, clientGroup] of clientGroups.entries()) {
    dagWrite.assertValidHash(clientGroup.headHash);
    chunkData[clientGroupID] = {
      ...clientGroup,
      mutatorNames: [...clientGroup.mutatorNames.values()]
    };
  }
  return deepFreeze(chunkData);
}
async function getClientGroupsAtHash(hash22, dagRead) {
  const chunk = await dagRead.getChunk(hash22);
  return chunkDataToClientGroupMap(chunk?.data);
}
async function getClientGroups(dagRead) {
  const hash22 = await dagRead.getHead(CLIENT_GROUPS_HEAD_NAME);
  if (!hash22) {
    return /* @__PURE__ */ new Map();
  }
  return getClientGroupsAtHash(hash22, dagRead);
}
async function setClientGroups(clientGroups, dagWrite) {
  const currClientGroups = await getClientGroups(dagWrite);
  for (const [clientGroupID, clientGroup] of clientGroups) {
    const currClientGroup = currClientGroups.get(clientGroupID);
    validateClientGroupUpdate(clientGroup, currClientGroup);
  }
  return setValidatedClientGroups(clientGroups, dagWrite);
}
async function setClientGroup(clientGroupID, clientGroup, dagWrite) {
  const currClientGroups = await getClientGroups(dagWrite);
  const currClientGroup = currClientGroups.get(clientGroupID);
  validateClientGroupUpdate(clientGroup, currClientGroup);
  const newClientGroups = new Map(currClientGroups);
  newClientGroups.set(clientGroupID, clientGroup);
  return setValidatedClientGroups(newClientGroups, dagWrite);
}
function validateClientGroupUpdate(clientGroup, currClientGroup) {
  const mutatorNamesSet = new Set(clientGroup.mutatorNames);
  assert3(
    mutatorNamesSet.size === clientGroup.mutatorNames.length,
    "A client group's mutatorNames must be a set."
  );
  if (currClientGroup !== void 0) {
    assert3(
      indexDefinitionsEqual(currClientGroup.indexes, clientGroup.indexes),
      "A client group's index definitions must never change."
    );
    assert3(
      mutatorNamesEqual(mutatorNamesSet, currClientGroup.mutatorNames),
      "A client group's mutatorNames must never change."
    );
  }
}
async function setValidatedClientGroups(clientGroups, dagWrite) {
  const chunkData = clientGroupMapToChunkData(clientGroups, dagWrite);
  const refs = /* @__PURE__ */ new Set();
  for (const clientGroup of clientGroups.values()) {
    refs.add(clientGroup.headHash);
  }
  const chunk = dagWrite.createChunk(chunkData, toRefs(refs));
  await dagWrite.putChunk(chunk);
  await dagWrite.setHead(CLIENT_GROUPS_HEAD_NAME, chunk.hash);
  return clientGroups;
}
function mutatorNamesEqual(mutatorNamesSet, mutatorNames) {
  if (mutatorNames.length !== mutatorNamesSet.size) {
    return false;
  }
  for (const mutatorName of mutatorNames) {
    if (!mutatorNamesSet.has(mutatorName)) {
      return false;
    }
  }
  return true;
}
async function getClientGroup(id, dagRead) {
  const clientGroups = await getClientGroups(dagRead);
  return clientGroups.get(id);
}
function clientGroupHasPendingMutations(clientGroup) {
  for (const [clientID, mutationID] of Object.entries(
    clientGroup.mutationIDs
  )) {
    const lastServerAckdMutationID = clientGroup.lastServerAckdMutationIDs[clientID];
    if (lastServerAckdMutationID === void 0 && mutationID !== 0 || lastServerAckdMutationID < mutationID) {
      return true;
    }
  }
  return false;
}
async function disableClientGroup(clientGroupID, dagWrite) {
  const clientGroup = await getClientGroup(clientGroupID, dagWrite);
  if (!clientGroup) {
    return;
  }
  const disabledClientGroup = {
    ...clientGroup,
    disabled: true
  };
  await setClientGroup(clientGroupID, disabledClientGroup, dagWrite);
}
function toError(e3) {
  if (e3 instanceof Error) {
    return e3;
  }
  return new Error(String(e3));
}
function withRead(store, fn) {
  return using(store.read(), fn);
}
function withWriteNoImplicitCommit(store, fn) {
  return using(store.write(), fn);
}
function withWrite(store, fn) {
  return using(store.write(), async (write) => {
    const result = await fn(write);
    await write.commit();
    return result;
  });
}
async function using(x, fn) {
  const write = await x;
  try {
    return await fn(write);
  } finally {
    write.release();
  }
}
async function apply(lc, dbWrite, patch) {
  for (const p of patch) {
    switch (p.op) {
      case "put": {
        const frozen = deepFreeze(p.value);
        await dbWrite.put(lc, p.key, frozen);
        break;
      }
      case "update": {
        const existing = await dbWrite.get(p.key);
        const entries = [];
        const addToEntries = /* @__PURE__ */ __name((toAdd) => {
          for (const [key2, value] of Object.entries(toAdd)) {
            if (!p.constrain || p.constrain.length === 0 || p.constrain.indexOf(key2) > -1) {
              entries.push([key2, value]);
            }
          }
        }, "addToEntries");
        if (existing !== void 0) {
          assertObject(existing);
          addToEntries(existing);
        }
        if (p.merge) {
          addToEntries(p.merge);
        }
        const frozen = deepFreeze(Object.fromEntries(entries));
        await dbWrite.put(lc, p.key, frozen);
        break;
      }
      case "del": {
        const existing = await dbWrite.get(p.key);
        if (existing === void 0) {
          continue;
        }
        await dbWrite.del(lc, p.key);
        break;
      }
      case "clear":
        await dbWrite.clear();
        break;
    }
  }
}
async function beginPullV1(profileID, clientID, clientGroupID, schemaVersion, puller, requestID, store, formatVersion, lc, createSyncBranch = true) {
  const baseCookie = await withRead(store, async (dagRead) => {
    const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);
    if (!mainHeadHash) {
      throw new Error("Internal no main head found");
    }
    const baseSnapshot = await baseSnapshotFromHash(mainHeadHash, dagRead);
    const baseSnapshotMeta = baseSnapshot.meta;
    assertSnapshotMetaDD31(baseSnapshotMeta);
    return baseSnapshotMeta.cookieJSON;
  });
  const pullReq = {
    profileID,
    clientGroupID,
    cookie: baseCookie,
    pullVersion: PULL_VERSION_DD31,
    schemaVersion
  };
  const { response, httpRequestInfo } = await callPuller(
    lc,
    puller,
    pullReq,
    requestID
  );
  if (!response) {
    return {
      httpRequestInfo,
      syncHead: emptyHash
    };
  }
  if (!createSyncBranch || isErrorResponse(response)) {
    return {
      httpRequestInfo,
      pullResponse: response,
      syncHead: emptyHash
    };
  }
  const result = await handlePullResponseV1(
    lc,
    store,
    baseCookie,
    response,
    clientID,
    formatVersion
  );
  return {
    httpRequestInfo,
    pullResponse: response,
    syncHead: result.type === Applied ? result.syncHead : emptyHash
  };
}
async function callPuller(lc, puller, pullReq, requestID) {
  lc.debug?.("Starting pull...");
  const pullStart = Date.now();
  let pullerResult;
  try {
    pullerResult = await puller(pullReq, requestID);
    lc.debug?.(
      `...Pull ${pullerResult.response ? "complete" : "failed"} in `,
      Date.now() - pullStart,
      "ms"
    );
  } catch (e3) {
    throw new PullError(toError(e3));
  }
  try {
    assertPullerResultV1(pullerResult);
    return pullerResult;
  } catch (e3) {
    throw new ReportError("Invalid puller result", toError(e3));
  }
}
function badOrderMessage(name, receivedValue, lastSnapshotValue) {
  return `Received ${name} ${receivedValue} is < than last snapshot ${name} ${lastSnapshotValue}; ignoring client view`;
}
function handlePullResponseV1(lc, store, expectedBaseCookie, response, clientID, formatVersion) {
  return withWriteNoImplicitCommit(store, async (dagWrite) => {
    const dagRead = dagWrite;
    const mainHead = await dagRead.getHead(DEFAULT_HEAD_NAME);
    if (mainHead === void 0) {
      throw new Error("Main head disappeared");
    }
    const baseSnapshot = await baseSnapshotFromHash(mainHead, dagRead);
    const baseSnapshotMeta = baseSnapshot.meta;
    assertSnapshotMetaDD31(baseSnapshotMeta);
    const baseCookie = baseSnapshotMeta.cookieJSON;
    if (!deepEqual(expectedBaseCookie, baseCookie)) {
      lc.debug?.(
        "handlePullResponse: cookie mismatch, response is not applicable"
      );
      return {
        type: CookieMismatch
      };
    }
    for (const [clientID2, lmidChange] of Object.entries(
      response.lastMutationIDChanges
    )) {
      const lastMutationID = baseSnapshotMeta.lastMutationIDs[clientID2];
      if (lastMutationID !== void 0 && lmidChange < lastMutationID) {
        throw new Error(
          badOrderMessage(
            `${clientID2} lastMutationID`,
            String(lmidChange),
            String(lastMutationID)
          )
        );
      }
    }
    const frozenResponseCookie = deepFreeze(response.cookie);
    if (compareCookies(frozenResponseCookie, baseCookie) < 0) {
      throw new Error(
        badOrderMessage(
          "cookie",
          JSON.stringify(frozenResponseCookie),
          JSON.stringify(baseCookie)
        )
      );
    }
    if (deepEqual(frozenResponseCookie, baseCookie)) {
      if (response.patch.length > 0) {
        lc.error?.(
          `handlePullResponse: cookie ${JSON.stringify(
            baseCookie
          )} did not change, but patch is not empty`
        );
      }
      if (Object.keys(response.lastMutationIDChanges).length > 0) {
        lc.error?.(
          `handlePullResponse: cookie ${JSON.stringify(
            baseCookie
          )} did not change, but lastMutationIDChanges is not empty`
        );
      }
      return {
        type: NoOp
      };
    }
    const dbWrite = await newWriteSnapshotDD31(
      baseSnapshot.chunk.hash,
      { ...baseSnapshotMeta.lastMutationIDs, ...response.lastMutationIDChanges },
      frozenResponseCookie,
      dagWrite,
      clientID,
      formatVersion
    );
    await apply(lc, dbWrite, response.patch);
    return {
      type: Applied,
      syncHead: await dbWrite.commit(SYNC_HEAD_NAME)
    };
  });
}
function maybeEndPull(store, lc, expectedSyncHead, clientID, diffConfig, formatVersion) {
  return withWriteNoImplicitCommit(store, async (dagWrite) => {
    const dagRead = dagWrite;
    const syncHeadHash = await dagRead.getHead(SYNC_HEAD_NAME);
    if (syncHeadHash === void 0) {
      throw new Error("Missing sync head");
    }
    if (syncHeadHash !== expectedSyncHead) {
      lc.error?.(
        "maybeEndPull, Wrong sync head. Expecting:",
        expectedSyncHead,
        "got:",
        syncHeadHash
      );
      throw new Error("Wrong sync head");
    }
    const syncSnapshot = await baseSnapshotFromHash(syncHeadHash, dagRead);
    const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);
    if (mainHeadHash === void 0) {
      throw new Error("Missing main head");
    }
    const mainSnapshot = await baseSnapshotFromHash(mainHeadHash, dagRead);
    const { meta } = syncSnapshot;
    const syncSnapshotBasis = meta.basisHash;
    if (syncSnapshot === null) {
      throw new Error("Sync snapshot with no basis");
    }
    if (syncSnapshotBasis !== mainSnapshot.chunk.hash) {
      throw new Error("Overlapping syncs");
    }
    const syncHead = await commitFromHash(syncHeadHash, dagRead);
    const pending = [];
    const localMutations2 = await localMutations(mainHeadHash, dagRead);
    for (const commit of localMutations2) {
      let cid = clientID;
      assert3(commitIsLocalDD31(commit));
      cid = commit.meta.clientID;
      if (await commit.getMutationID(cid, dagRead) > await syncHead.getMutationID(cid, dagRead)) {
        pending.push(commit);
      }
    }
    pending.reverse();
    const diffsMap = new DiffsMap();
    if (pending.length > 0) {
      return {
        syncHead: syncHeadHash,
        oldMainHead: mainHeadHash,
        mainHead: mainHeadHash,
        replayMutations: pending,
        // The changed keys are not reported when further replays are
        // needed. The diffs will be reported at the end when there
        // are no more mutations to be replay and then it will be reported
        // relative to DEFAULT_HEAD_NAME.
        diffs: diffsMap
      };
    }
    const mainHead = await commitFromHash(mainHeadHash, dagRead);
    if (diffConfig.shouldComputeDiffs()) {
      const mainHeadMap = new BTreeRead(
        dagRead,
        formatVersion,
        mainHead.valueHash
      );
      const syncHeadMap = new BTreeRead(
        dagRead,
        formatVersion,
        syncHead.valueHash
      );
      const valueDiff = await diff(mainHeadMap, syncHeadMap);
      diffsMap.set("", valueDiff);
      await addDiffsForIndexes(
        mainHead,
        syncHead,
        dagRead,
        diffsMap,
        diffConfig,
        formatVersion
      );
    }
    await Promise.all([
      dagWrite.setHead(DEFAULT_HEAD_NAME, syncHeadHash),
      dagWrite.removeHead(SYNC_HEAD_NAME)
    ]);
    await dagWrite.commit();
    const newMainHeadHash = syncHeadHash;
    if (lc.debug) {
      const [oldLastMutationID, oldCookie] = snapshotMetaParts(
        mainSnapshot,
        clientID
      );
      const [newLastMutationID, newCookie] = snapshotMetaParts(
        syncSnapshot,
        clientID
      );
      lc.debug(
        `Successfully pulled new snapshot with lastMutationID:`,
        newLastMutationID,
        `(prev:`,
        oldLastMutationID,
        `), cookie: `,
        newCookie,
        `(prev:`,
        oldCookie,
        `), sync head hash:`,
        syncHeadHash,
        ", main head hash:",
        mainHeadHash,
        `, valueHash:`,
        syncHead.valueHash,
        `(prev:`,
        mainSnapshot.valueHash
      );
    }
    return {
      syncHead: syncHeadHash,
      oldMainHead: mainHeadHash,
      mainHead: newMainHeadHash,
      replayMutations: [],
      diffs: diffsMap
    };
  });
}
function assertPusherResult(v2) {
  assertObject(v2);
  assertHTTPRequestInfo(v2.httpRequestInfo);
  if (v2.response !== void 0) {
    assertPushResponse(v2.response);
  }
}
function assertPushResponse(v2) {
  if (isClientStateNotFoundResponse(v2)) {
    return;
  }
  assertVersionNotSupportedResponse(v2);
}
function convertDD31(lm) {
  return {
    id: lm.mutationID,
    name: lm.mutatorName,
    args: lm.mutatorArgsJSON,
    timestamp: lm.timestamp,
    clientID: lm.clientID
  };
}
async function push3(requestID, store, lc, profileID, clientGroupID, _clientID, pusher, schemaVersion, pushVersion) {
  const pending = await withRead(store, async (dagRead) => {
    const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);
    if (!mainHeadHash) {
      throw new Error("Internal no main head");
    }
    return localMutations(mainHeadHash, dagRead);
  });
  if (pending.length === 0) {
    return void 0;
  }
  pending.reverse();
  assert3(pushVersion === PUSH_VERSION_DD31);
  const pushMutations = [];
  for (const commit of pending) {
    if (commitIsLocalDD31(commit)) {
      pushMutations.push(convertDD31(commit.meta));
    } else {
      throw new Error("Internal non local pending commit");
    }
  }
  assert3(clientGroupID);
  const pushReq = {
    profileID,
    clientGroupID,
    mutations: pushMutations,
    pushVersion: PUSH_VERSION_DD31,
    schemaVersion
  };
  lc.debug?.("Starting push...");
  const pushStart = Date.now();
  const pusherResult = await callPusher(pusher, pushReq, requestID);
  lc.debug?.("...Push complete in ", Date.now() - pushStart, "ms");
  return pusherResult;
}
async function callPusher(pusher, body2, requestID) {
  let pusherResult;
  try {
    pusherResult = await pusher(body2, requestID);
  } catch (e3) {
    throw new PushError(toError(e3));
  }
  try {
    assertPusherResult(pusherResult);
    return pusherResult;
  } catch (e3) {
    throw new ReportError("Invalid pusher result", toError(e3));
  }
}
function makeChannelNameV0(replicacheName) {
  return `replicache-new-client-group:${replicacheName}`;
}
function makeChannelNameV1(replicacheName) {
  return `replicache-new-client-group-v1:${replicacheName}`;
}
function isNewClientChannelMessageV1(message) {
  return typeof message === "object" && typeof message.clientGroupID === "string" && typeof message.idbName === "string";
}
function initNewClientChannel(replicacheName, idbName, signal, clientGroupID, isNewClientGroup, onUpdateNeeded, perdag) {
  if (signal.aborted) {
    return;
  }
  const channelV1 = new bc(makeChannelNameV1(replicacheName));
  if (isNewClientGroup) {
    channelV1.postMessage({ clientGroupID, idbName });
    const channelV0 = new bc(makeChannelNameV0(replicacheName));
    channelV0.postMessage([clientGroupID]);
    channelV0.close();
  }
  channelV1.onmessage = async (e3) => {
    const { data } = e3;
    if (isNewClientChannelMessageV1(data)) {
      const { clientGroupID: newClientGroupID, idbName: newClientIDBName } = data;
      if (newClientGroupID !== clientGroupID) {
        if (newClientIDBName === idbName) {
          const updateNeeded = await withRead(
            perdag,
            async (perdagRead) => await getClientGroup(newClientGroupID, perdagRead) !== void 0
          );
          if (updateNeeded) {
            onUpdateNeeded();
          }
        } else {
          onUpdateNeeded();
          return;
        }
      }
    }
  };
  signal.addEventListener("abort", () => channelV1.close(), { once: true });
}
function makeChannelName(replicacheName) {
  return `replicache-on-persist:${replicacheName}`;
}
function assertPersistInfo(value) {
  assertObject(value);
  assertString(value.clientGroupID);
  assertString(value.clientID);
}
function initOnPersistChannel(replicacheName, signal, handlePersist) {
  if (signal.aborted) {
    return () => void 0;
  }
  const channel2 = new bc(makeChannelName(replicacheName));
  channel2.onmessage = (e3) => {
    const { data } = e3;
    assertPersistInfo(data);
    handlePersist({
      clientGroupID: data.clientGroupID,
      clientID: data.clientID
    });
  };
  signal.addEventListener("abort", () => channel2.close(), { once: true });
  return (persistInfo) => {
    if (signal.aborted) {
      return;
    }
    channel2.postMessage(persistInfo);
    handlePersist(persistInfo);
  };
}
async function pendingMutationsForAPI(dagRead) {
  const mainHeadHash = await mustGetHeadHash(DEFAULT_HEAD_NAME, dagRead);
  const pending = await localMutationsDD31(mainHeadHash, dagRead);
  return pending.map((p) => ({
    id: p.meta.mutationID,
    name: p.meta.mutatorName,
    args: p.meta.mutatorArgsJSON,
    clientID: p.meta.clientID
  })).reverse();
}
function makeClientID() {
  const length = 18;
  const high = randomUint64();
  const low = randomUint64();
  const combined = high << 64n | low;
  return combined.toString(32).slice(-length).padStart(length, "0");
}
function isClientV6(client2) {
  return client2.refreshHashes !== void 0;
}
function assertClient(value) {
  assert22(value, clientSchema);
}
function assertClientV6(value) {
  assert22(value, clientV6Schema);
}
function chunkDataToClientMap(chunkData) {
  assertObject(chunkData);
  const clients = /* @__PURE__ */ new Map();
  for (const key2 in chunkData) {
    if (hasOwn(chunkData, key2)) {
      const value = chunkData[key2];
      if (value !== void 0) {
        assertClient(value);
        clients.set(key2, value);
      }
    }
  }
  return clients;
}
function clientMapToChunkData(clients, dagWrite) {
  for (const client2 of clients.values()) {
    if (isClientV6(client2)) {
      client2.refreshHashes.forEach(dagWrite.assertValidHash);
      if (client2.persistHash) {
        dagWrite.assertValidHash(client2.persistHash);
      }
    } else {
      dagWrite.assertValidHash(client2.headHash);
      if (client2.tempRefreshHash) {
        dagWrite.assertValidHash(client2.tempRefreshHash);
      }
    }
  }
  return deepFreeze(Object.fromEntries(clients));
}
async function getClients(dagRead) {
  const hash22 = await dagRead.getHead(CLIENTS_HEAD_NAME);
  return getClientsAtHash(hash22, dagRead);
}
async function getClientsAtHash(hash22, dagRead) {
  if (!hash22) {
    return /* @__PURE__ */ new Map();
  }
  const chunk = await dagRead.getChunk(hash22);
  return chunkDataToClientMap(chunk?.data);
}
async function assertHasClientState(id, dagRead) {
  if (!await hasClientState(id, dagRead)) {
    throw new ClientStateNotFoundError(id);
  }
}
async function hasClientState(id, dagRead) {
  return !!await getClient(id, dagRead);
}
async function getClient(id, dagRead) {
  const clients = await getClients(dagRead);
  return clients.get(id);
}
async function mustGetClient(id, dagRead) {
  const client2 = await getClient(id, dagRead);
  if (!client2) {
    throw new ClientStateNotFoundError(id);
  }
  return client2;
}
function initClientV6(newClientID, lc, perdag, mutatorNames, indexes, formatVersion, enableClientGroupForking) {
  return withWrite(perdag, async (dagWrite) => {
    async function setClientsAndClientGroupAndCommit(basisHash, cookieJSON, valueHash2, indexRecords2) {
      const newSnapshotData = newSnapshotCommitDataDD31(
        basisHash,
        {},
        cookieJSON,
        valueHash2,
        indexRecords2
      );
      const chunk = dagWrite.createChunk(
        newSnapshotData,
        getRefs(newSnapshotData)
      );
      const newClientGroupID = makeClientID();
      const newClient = {
        heartbeatTimestampMs: Date.now(),
        refreshHashes: [chunk.hash],
        persistHash: null,
        clientGroupID: newClientGroupID
      };
      const newClients = new Map(clients).set(newClientID, newClient);
      const clientGroup = {
        headHash: chunk.hash,
        mutatorNames,
        indexes,
        mutationIDs: {},
        lastServerAckdMutationIDs: {},
        disabled: false
      };
      await Promise.all([
        dagWrite.putChunk(chunk),
        setClients(newClients, dagWrite),
        setClientGroup(newClientGroupID, clientGroup, dagWrite)
      ]);
      return [newClient, chunk.hash, newClients, true];
    }
    __name(setClientsAndClientGroupAndCommit, "setClientsAndClientGroupAndCommit");
    const clients = await getClients(dagWrite);
    const res = await findMatchingClient(dagWrite, mutatorNames, indexes);
    if (res.type === FIND_MATCHING_CLIENT_TYPE_HEAD) {
      const { clientGroupID, headHash } = res;
      const newClient = {
        clientGroupID,
        refreshHashes: [headHash],
        heartbeatTimestampMs: Date.now(),
        persistHash: null
      };
      const newClients = new Map(clients).set(newClientID, newClient);
      await setClients(newClients, dagWrite);
      return [newClient, headHash, newClients, false];
    }
    if (!enableClientGroupForking || res.type === FIND_MATCHING_CLIENT_TYPE_NEW) {
      const emptyBTreeChunk = dagWrite.createChunk(emptyDataNode, []);
      await dagWrite.putChunk(emptyBTreeChunk);
      const indexRecords2 = [];
      for (const [name, indexDefinition] of Object.entries(indexes)) {
        const chunkIndexDefinition = toChunkIndexDefinition(
          name,
          indexDefinition
        );
        indexRecords2.push({
          definition: chunkIndexDefinition,
          valueHash: emptyBTreeChunk.hash
        });
      }
      return setClientsAndClientGroupAndCommit(
        null,
        null,
        emptyBTreeChunk.hash,
        indexRecords2
      );
    }
    assert3(res.type === FIND_MATCHING_CLIENT_TYPE_FORK);
    const { snapshot } = res;
    const indexRecords = [];
    const { valueHash, indexes: oldIndexes } = snapshot;
    const map = new BTreeRead(dagWrite, formatVersion, valueHash);
    for (const [name, indexDefinition] of Object.entries(indexes)) {
      const { prefix = "", jsonPointer, allowEmpty = false } = indexDefinition;
      const chunkIndexDefinition = {
        name,
        keyPrefix: prefix,
        jsonPointer,
        allowEmpty
      };
      const oldIndex = findMatchingOldIndex(oldIndexes, chunkIndexDefinition);
      if (oldIndex) {
        indexRecords.push({
          definition: chunkIndexDefinition,
          valueHash: oldIndex.valueHash
        });
      } else {
        const indexBTree = await createIndexBTree(
          lc,
          dagWrite,
          map,
          prefix,
          jsonPointer,
          allowEmpty,
          formatVersion
        );
        indexRecords.push({
          definition: chunkIndexDefinition,
          valueHash: await indexBTree.flush()
        });
      }
    }
    return setClientsAndClientGroupAndCommit(
      snapshot.meta.basisHash,
      snapshot.meta.cookieJSON,
      snapshot.valueHash,
      indexRecords
    );
  });
}
function findMatchingOldIndex(oldIndexes, chunkIndexDefinition) {
  return oldIndexes.find(
    (index10) => chunkIndexDefinitionEqualIgnoreName(index10.definition, chunkIndexDefinition)
  );
}
async function findMatchingClient(dagRead, mutatorNames, indexes) {
  let newestCookie;
  let bestSnapshot;
  const mutatorNamesSet = new Set(mutatorNames);
  const clientGroups = await getClientGroups(dagRead);
  for (const [clientGroupID, clientGroup] of clientGroups) {
    if (!clientGroup.disabled && mutatorNamesEqual(mutatorNamesSet, clientGroup.mutatorNames) && indexDefinitionsEqual(indexes, clientGroup.indexes)) {
      return {
        type: FIND_MATCHING_CLIENT_TYPE_HEAD,
        clientGroupID,
        headHash: clientGroup.headHash
      };
    }
    const clientGroupSnapshotCommit = await baseSnapshotFromHash(
      clientGroup.headHash,
      dagRead
    );
    assertSnapshotCommitDD31(clientGroupSnapshotCommit);
    const { cookieJSON } = clientGroupSnapshotCommit.meta;
    if (newestCookie === void 0 || compareCookies(cookieJSON, newestCookie) > 0) {
      newestCookie = cookieJSON;
      bestSnapshot = clientGroupSnapshotCommit;
    }
  }
  if (bestSnapshot) {
    return {
      type: FIND_MATCHING_CLIENT_TYPE_FORK,
      snapshot: bestSnapshot
    };
  }
  return { type: FIND_MATCHING_CLIENT_TYPE_NEW };
}
function getRefsForClients(clients) {
  const refs = /* @__PURE__ */ new Set();
  for (const client2 of clients.values()) {
    if (isClientV6(client2)) {
      for (const hash22 of client2.refreshHashes) {
        refs.add(hash22);
      }
      if (client2.persistHash) {
        refs.add(client2.persistHash);
      }
    } else {
      refs.add(client2.headHash);
      if (client2.tempRefreshHash) {
        refs.add(client2.tempRefreshHash);
      }
    }
  }
  return toRefs(refs);
}
async function getClientGroupForClient(clientID, read) {
  const clientGroupID = await getClientGroupIDForClient(clientID, read);
  if (!clientGroupID) {
    return void 0;
  }
  return getClientGroup(clientGroupID, read);
}
async function getClientGroupIDForClient(clientID, read) {
  const client2 = await getClient(clientID, read);
  return client2?.clientGroupID;
}
async function setClient(clientID, client2, dagWrite) {
  const clients = await getClients(dagWrite);
  const newClients = new Map(clients).set(clientID, client2);
  return setClients(newClients, dagWrite);
}
async function setClients(clients, dagWrite) {
  const chunkData = clientMapToChunkData(clients, dagWrite);
  const chunk = dagWrite.createChunk(chunkData, getRefsForClients(clients));
  await dagWrite.putChunk(chunk);
  await dagWrite.setHead(CLIENTS_HEAD_NAME, chunk.hash);
  return chunk.hash;
}
function initClientGC(clientID, dagStore, clientMaxInactiveTime, gcInterval, onClientsDeleted, lc, signal) {
  initBgIntervalProcess(
    "ClientGC",
    () => {
      latestGCUpdate = gcClients(
        clientID,
        dagStore,
        clientMaxInactiveTime,
        onClientsDeleted
      );
      return latestGCUpdate;
    },
    () => gcInterval,
    lc,
    signal
  );
}
function gcClients(clientID, dagStore, clientMaxInactiveTime, onClientsDeleted) {
  return withWrite(dagStore, async (dagWrite) => {
    const now = Date.now();
    const clients = await getClients(dagWrite);
    const deletedClients = [];
    const newClients = /* @__PURE__ */ new Map();
    for (const [id, client2] of clients) {
      if (id === clientID || now - client2.heartbeatTimestampMs <= clientMaxInactiveTime) {
        newClients.set(id, client2);
      } else {
        deletedClients.push(id);
      }
    }
    if (newClients.size === clients.size) {
      return clients;
    }
    await setClients(newClients, dagWrite);
    const { clientIDs, clientGroupIDs } = await addDeletedClients(
      dagWrite,
      deletedClients,
      // gcClients does not delete client groups
      []
    );
    onClientsDeleted(clientIDs, clientGroupIDs);
    return newClients;
  });
}
function initClientGroupGC(dagStore, enableMutationRecovery, onClientsDeleted, lc, signal) {
  initBgIntervalProcess(
    "ClientGroupGC",
    () => {
      latestGCUpdate2 = gcClientGroups(
        dagStore,
        enableMutationRecovery,
        onClientsDeleted
      );
      return latestGCUpdate2;
    },
    () => GC_INTERVAL_MS,
    lc,
    signal
  );
}
function gcClientGroups(dagStore, enableMutationRecovery, onClientsDeleted) {
  return withWrite(dagStore, async (tx) => {
    const clients = await getClients(tx);
    const clientGroupIDs = /* @__PURE__ */ new Set();
    for (const client2 of clients.values()) {
      clientGroupIDs.add(client2.clientGroupID);
    }
    const clientGroups = /* @__PURE__ */ new Map();
    const removeClientGroups = /* @__PURE__ */ new Set();
    for (const [clientGroupID, clientGroup] of await getClientGroups(tx)) {
      if (clientGroupIDs.has(clientGroupID) || enableMutationRecovery && clientGroupHasPendingMutations(clientGroup)) {
        clientGroups.set(clientGroupID, clientGroup);
      } else {
        removeClientGroups.add(clientGroupID);
      }
    }
    await setClientGroups(clientGroups, tx);
    onClientsDeleted([], [...removeClientGroups].sort());
    return clientGroups;
  });
}
function startHeartbeats(clientID, dagStore, onClientStateNotFound, heartbeatIntervalMs, lc, signal) {
  initBgIntervalProcess(
    "Heartbeat",
    async () => {
      latestHeartbeatUpdate = writeHeartbeat(clientID, dagStore);
      try {
        return await latestHeartbeatUpdate;
      } catch (e3) {
        if (e3 instanceof ClientStateNotFoundError) {
          onClientStateNotFound();
          return;
        }
        throw e3;
      }
    },
    () => heartbeatIntervalMs,
    lc,
    signal
  );
}
function writeHeartbeat(clientID, dagStore) {
  return withWrite(dagStore, async (dagWrite) => {
    const clients = await getClients(dagWrite);
    const client2 = clients.get(clientID);
    if (!client2) {
      throw new ClientStateNotFoundError(clientID);
    }
    const newClient = {
      ...client2,
      heartbeatTimestampMs: Date.now()
    };
    const newClients = new Map(clients).set(clientID, newClient);
    await setClients(newClients, dagWrite);
    return newClients;
  });
}
function getIDBDatabasesDBName() {
  return testNamespace + IDB_DATABASES_DB_NAME;
}
function assertIndexedDBDatabaseRecord(value) {
  assertObject(value);
  for (const [name, db2] of Object.entries(value)) {
    assertString(name);
    assertIndexedDBDatabase(db2);
    assert3(name === db2.name);
  }
}
function assertIndexedDBDatabase(value) {
  assertObject(value);
  assertString(value.name);
  assertString(value.replicacheName);
  assertNumber(value.replicacheFormatVersion);
  assertString(value.schemaVersion);
  if (value.lastOpenedTimestampMS !== void 0) {
    assertNumber(value.lastOpenedTimestampMS);
  }
}
async function getDatabases(read) {
  let dbRecord = await read.get(DBS_KEY);
  if (!dbRecord) {
    dbRecord = deepFreeze({});
  }
  assertIndexedDBDatabaseRecord(dbRecord);
  return dbRecord;
}
async function persistDD31(lc, clientID, memdag, perdag, mutators, closed, formatVersion, getZeroData, onGatherMemOnlyChunksForTest = () => Promise.resolve()) {
  if (closed()) {
    return;
  }
  const [perdagLMID, perdagBaseSnapshot, mainClientGroupID] = await withRead(
    perdag,
    async (perdagRead) => {
      await assertHasClientState(clientID, perdagRead);
      const mainClientGroupID2 = await getClientGroupIDForClient(
        clientID,
        perdagRead
      );
      assert3(
        mainClientGroupID2,
        `No main client group for clientID: ${clientID}`
      );
      const [, perdagMainClientGroupHeadCommit] = await getClientGroupInfo(
        perdagRead,
        mainClientGroupID2
      );
      const perdagLMID2 = await perdagMainClientGroupHeadCommit.getMutationID(
        clientID,
        perdagRead
      );
      const perdagBaseSnapshot2 = await baseSnapshotFromCommit(
        perdagMainClientGroupHeadCommit,
        perdagRead
      );
      assertSnapshotCommitDD31(perdagBaseSnapshot2);
      return [perdagLMID2, perdagBaseSnapshot2, mainClientGroupID2];
    }
  );
  if (closed()) {
    return;
  }
  const [newMemdagMutations, memdagBaseSnapshot, gatheredChunks] = await withRead(memdag, async (memdagRead) => {
    const memdagHeadCommit = await commitFromHead(
      DEFAULT_HEAD_NAME,
      memdagRead
    );
    const newMutations = await localMutationsGreaterThan(
      memdagHeadCommit,
      { [clientID]: perdagLMID || 0 },
      memdagRead
    );
    const memdagBaseSnapshot2 = await baseSnapshotFromCommit(
      memdagHeadCommit,
      memdagRead
    );
    assertSnapshotCommitDD31(memdagBaseSnapshot2);
    let gatheredChunks2;
    if (compareCookiesForSnapshots(memdagBaseSnapshot2, perdagBaseSnapshot) > 0) {
      await onGatherMemOnlyChunksForTest();
      const memdagBaseSnapshotHash = memdagBaseSnapshot2.chunk.hash;
      const visitor = new GatherMemoryOnlyVisitor(memdagRead);
      await visitor.visit(memdagBaseSnapshotHash);
      gatheredChunks2 = visitor.gatheredChunks;
    }
    return [newMutations, memdagBaseSnapshot2, gatheredChunks2];
  });
  if (closed()) {
    return;
  }
  let memdagBaseSnapshotPersisted = false;
  const zeroDataForMemdagBaseSnapshot = getZeroData && await getZeroData("rebase", memdagBaseSnapshot.chunk.hash);
  await withWrite(perdag, async (perdagWrite) => {
    const [mainClientGroup, latestPerdagMainClientGroupHeadCommit] = await getClientGroupInfo(perdagWrite, mainClientGroupID);
    let newMainClientGroupHeadHash = latestPerdagMainClientGroupHeadCommit.chunk.hash;
    let mutationIDs = {
      ...mainClientGroup.mutationIDs
    };
    let { lastServerAckdMutationIDs } = mainClientGroup;
    if (gatheredChunks) {
      const client2 = await mustGetClient(clientID, perdagWrite);
      assertClientV6(client2);
      const latestPerdagBaseSnapshot = await baseSnapshotFromCommit(
        latestPerdagMainClientGroupHeadCommit,
        perdagWrite
      );
      assertSnapshotCommitDD31(latestPerdagBaseSnapshot);
      if (compareCookiesForSnapshots(
        memdagBaseSnapshot,
        latestPerdagBaseSnapshot
      ) > 0) {
        memdagBaseSnapshotPersisted = true;
        await Promise.all(
          Array.from(gatheredChunks.values(), (c2) => perdagWrite.putChunk(c2))
        );
        await setClient(
          clientID,
          {
            ...client2,
            persistHash: memdagBaseSnapshot.chunk.hash
          },
          perdagWrite
        );
        newMainClientGroupHeadHash = memdagBaseSnapshot.chunk.hash;
        const mainClientGroupLocalMutations = await localMutationsDD31(
          mainClientGroup.headHash,
          perdagWrite
        );
        lastServerAckdMutationIDs = memdagBaseSnapshot.meta.lastMutationIDs;
        mutationIDs = { ...lastServerAckdMutationIDs };
        newMainClientGroupHeadHash = await rebase(
          mainClientGroupLocalMutations,
          newMainClientGroupHeadHash,
          perdagWrite,
          mutators,
          mutationIDs,
          lc,
          formatVersion,
          zeroDataForMemdagBaseSnapshot
        );
      }
    }
    let zeroDataForPerdagHeadCommit;
    if (!memdagBaseSnapshotPersisted) {
      zeroDataForPerdagHeadCommit = getZeroData && await getZeroData("rebase", newMainClientGroupHeadHash, {
        openLazySourceRead: perdagWrite
      });
    }
    newMainClientGroupHeadHash = await rebase(
      newMemdagMutations,
      newMainClientGroupHeadHash,
      perdagWrite,
      mutators,
      mutationIDs,
      lc,
      formatVersion,
      zeroDataForPerdagHeadCommit ?? zeroDataForMemdagBaseSnapshot
    );
    const newMainClientGroup = {
      ...mainClientGroup,
      headHash: newMainClientGroupHeadHash,
      mutationIDs,
      lastServerAckdMutationIDs
    };
    await setClientGroup(mainClientGroupID, newMainClientGroup, perdagWrite);
  });
  if (gatheredChunks && memdagBaseSnapshotPersisted) {
    await withWrite(
      memdag,
      (memdagWrite) => memdagWrite.chunksPersisted([...gatheredChunks.keys()])
    );
  }
}
async function getClientGroupInfo(perdagRead, clientGroupID) {
  const clientGroup = await getClientGroup(clientGroupID, perdagRead);
  assert3(clientGroup, `No client group for clientGroupID: ${clientGroupID}`);
  return [clientGroup, await commitFromHash(clientGroup.headHash, perdagRead)];
}
async function rebase(mutations, basis, write, mutators, mutationIDs, lc, formatVersion, zeroData2) {
  for (let i = mutations.length - 1; i >= 0; i--) {
    const mutationCommit = mutations[i];
    const { meta } = mutationCommit;
    const newMainHead = await commitFromHash(basis, write);
    if (await mutationCommit.getMutationID(meta.clientID, write) > await newMainHead.getMutationID(meta.clientID, write)) {
      mutationIDs[meta.clientID] = meta.mutationID;
      basis = (await rebaseMutationAndPutCommit(
        mutationCommit,
        write,
        basis,
        mutators,
        lc,
        meta.clientID,
        formatVersion,
        zeroData2
      )).chunk.hash;
    }
  }
  return basis;
}
async function refresh(lc, memdag, perdag, clientID, mutators, diffConfig, closed, formatVersion, zero) {
  if (closed()) {
    return;
  }
  const memdagBaseSnapshot = await withRead(
    memdag,
    (memdagRead) => baseSnapshotFromHead(DEFAULT_HEAD_NAME, memdagRead)
  );
  assertSnapshotCommitDD31(memdagBaseSnapshot);
  const result = await memdag.withSuspendedSourceCacheEvictsAndDeletes(async () => {
    const perdagWriteResult = await withWrite(
      perdag,
      async (perdagWrite) => {
        const clientGroup = await getClientGroupForClient(
          clientID,
          perdagWrite
        );
        if (!clientGroup) {
          throw new ClientStateNotFoundError(clientID);
        }
        const perdagClientGroupHeadHash2 = clientGroup.headHash;
        const perdagClientGroupHeadCommit = await commitFromHash(
          perdagClientGroupHeadHash2,
          perdagWrite
        );
        const perdagLmid2 = await perdagClientGroupHeadCommit.getMutationID(
          clientID,
          perdagWrite
        );
        const client2 = await mustGetClient(clientID, perdagWrite);
        assertClientV6(client2);
        const perdagClientGroupBaseSnapshot2 = await baseSnapshotFromHash(
          perdagClientGroupHeadHash2,
          perdagWrite
        );
        assertSnapshotCommitDD31(perdagClientGroupBaseSnapshot2);
        if (shouldAbortRefresh(
          memdagBaseSnapshot,
          perdagClientGroupBaseSnapshot2,
          perdagClientGroupHeadHash2
        )) {
          return void 0;
        }
        const visitor = new GatherNotCachedVisitor(
          perdagWrite,
          memdag,
          GATHER_SIZE_LIMIT
        );
        await visitor.visit(perdagClientGroupHeadHash2);
        const { gatheredChunks: gatheredChunks2 } = visitor;
        const refreshHashesSet = new Set(client2.refreshHashes);
        refreshHashesSet.add(perdagClientGroupHeadHash2);
        const newClient = {
          ...client2,
          refreshHashes: [...refreshHashesSet]
        };
        await setClient(clientID, newClient, perdagWrite);
        return [
          perdagClientGroupHeadHash2,
          perdagClientGroupBaseSnapshot2,
          perdagLmid2,
          gatheredChunks2,
          client2.refreshHashes
        ];
      }
    );
    if (closed() || !perdagWriteResult) {
      return {
        type: "aborted"
      };
    }
    await sleep(DELAY_MS);
    if (closed()) {
      return {
        type: "aborted"
      };
    }
    const [
      perdagClientGroupHeadHash,
      perdagClientGroupBaseSnapshot,
      perdagLmid,
      gatheredChunks,
      refreshHashesForRevert
    ] = perdagWriteResult;
    return withWrite(memdag, async (memdagWrite) => {
      const memdagHeadCommit = await commitFromHead(
        DEFAULT_HEAD_NAME,
        memdagWrite
      );
      const memdagBaseSnapshot2 = await baseSnapshotFromCommit(
        memdagHeadCommit,
        memdagWrite
      );
      assertSnapshotCommitDD31(memdagBaseSnapshot2);
      if (shouldAbortRefresh(
        memdagBaseSnapshot2,
        perdagClientGroupBaseSnapshot,
        perdagClientGroupHeadHash
      )) {
        return {
          type: "aborted",
          refreshHashesForRevert
        };
      }
      const newMemdagMutations = await localMutationsGreaterThan(
        memdagHeadCommit,
        { [clientID]: perdagLmid },
        memdagWrite
      );
      const ps = [];
      for (const { chunk, size: size2 } of gatheredChunks.values()) {
        ps.push(memdagWrite.putChunk(chunk, size2));
      }
      await Promise.all(ps);
      let newMemdagHeadHash = perdagClientGroupHeadHash;
      if (newMemdagMutations.length > 0) {
        const zeroData2 = await zero?.getTxData?.(
          "rebase",
          newMemdagHeadHash,
          {
            openLazyRead: memdagWrite
          }
        );
        for (let i = newMemdagMutations.length - 1; i >= 0; i--) {
          newMemdagHeadHash = (await rebaseMutationAndPutCommit(
            newMemdagMutations[i],
            memdagWrite,
            newMemdagHeadHash,
            mutators,
            lc,
            newMemdagMutations[i].meta.clientID,
            formatVersion,
            zeroData2
          )).chunk.hash;
        }
      }
      const newMemdagHeadCommit = await commitFromHash(
        newMemdagHeadHash,
        memdagWrite
      );
      const diffs = await diffCommits(
        memdagHeadCommit,
        newMemdagHeadCommit,
        memdagWrite,
        diffConfig,
        formatVersion
      );
      await memdagWrite.setHead(DEFAULT_HEAD_NAME, newMemdagHeadHash);
      return {
        type: "complete",
        diffs,
        oldHead: memdagHeadCommit.chunk.hash,
        newHead: newMemdagHeadHash,
        newPerdagClientHeadHash: perdagClientGroupHeadHash
      };
    });
  });
  if (closed()) {
    return;
  }
  const setRefreshHashes = /* @__PURE__ */ __name((refreshHashes) => withWrite(perdag, async (perdagWrite) => {
    const client2 = await mustGetClient(clientID, perdagWrite);
    const newClient = {
      ...client2,
      refreshHashes
    };
    await setClient(clientID, newClient, perdagWrite);
  }), "setRefreshHashes");
  if (result.type === "aborted") {
    if (result.refreshHashesForRevert) {
      await setRefreshHashes(result.refreshHashesForRevert);
    }
    return void 0;
  }
  zero?.advance(result.oldHead, result.newHead, result.diffs.get("") ?? []);
  await setRefreshHashes([result.newPerdagClientHeadHash]);
  return {
    oldHead: result.oldHead,
    newHead: result.newHead,
    diffs: result.diffs
  };
}
function shouldAbortRefresh(memdagBaseSnapshot, perdagClientGroupBaseSnapshot, perdagClientGroupHeadHash) {
  const baseSnapshotCookieCompareResult = compareCookiesForSnapshots(
    memdagBaseSnapshot,
    perdagClientGroupBaseSnapshot
  );
  return baseSnapshotCookieCompareResult > 0 || baseSnapshotCookieCompareResult === 0 && perdagClientGroupHeadHash === perdagClientGroupBaseSnapshot.chunk.hash;
}
function requestIdle(timeout) {
  return new Promise((resolve2) => {
    if (typeof requestIdleCallback === "function") {
      requestIdleCallback(() => resolve2(), { timeout });
    } else {
      setTimeout(() => resolve2(), timeout);
    }
  });
}
async function throttle(timeMs, abortSignal) {
  try {
    await sleep(timeMs, abortSignal);
  } catch (e3) {
    assert3(e3 instanceof AbortError);
  }
}
function setIntervalWithSignal(fn, ms, signal) {
  if (!signal.aborted) {
    const interval2 = setInterval(fn, ms);
    signal.addEventListener("abort", () => {
      clearInterval(interval2);
    });
  }
}
function convertDiffValues(diff3, convertKey) {
  return diff3.map((op) => {
    const key2 = convertKey(op.key);
    switch (op.op) {
      case "add":
        return {
          op: "add",
          key: key2,
          newValue: op.newValue
        };
      case "change":
        return {
          op: "change",
          key: key2,
          oldValue: op.oldValue,
          newValue: op.newValue
        };
      case "del":
        return {
          op: "del",
          key: key2,
          oldValue: op.oldValue
        };
    }
  });
}
function diffMatchesSubscription(keys, scans, indexName, diff3) {
  if (indexName === "") {
    for (const diffEntry of diff3) {
      if (keys.has(diffEntry.key)) {
        return true;
      }
    }
  }
  for (const scanInfo of scans) {
    if (scanInfoMatchesDiff(scanInfo, indexName, diff3)) {
      return true;
    }
  }
  return false;
}
function scanInfoMatchesDiff(scanInfo, changeIndexName, diff3) {
  for (const diffEntry of diff3) {
    if (scanInfoMatchesKey(scanInfo, changeIndexName, diffEntry.key)) {
      return true;
    }
  }
  return false;
}
function scanInfoMatchesKey(scanInfo, changeIndexName, changedKey) {
  const {
    indexName = "",
    limit,
    prefix,
    startKey,
    startExclusive,
    startSecondaryKey
  } = scanInfo.options;
  if (changeIndexName !== indexName) {
    return false;
  }
  if (!indexName) {
    if (limit !== void 0 && limit <= 0) {
      return false;
    }
    if (!prefix && !startKey) {
      return true;
    }
    if (prefix && (!changedKey.startsWith(prefix) || isKeyPastInclusiveLimit(scanInfo, changedKey))) {
      return false;
    }
    if (startKey && (startExclusive && lessThanEq(changedKey, startKey) || lessThan(changedKey, startKey) || isKeyPastInclusiveLimit(scanInfo, changedKey))) {
      return false;
    }
    return true;
  }
  if (!prefix && !startKey && !startSecondaryKey) {
    return true;
  }
  const [changedKeySecondary, changedKeyPrimary] = decodeIndexKey(changedKey);
  if (prefix) {
    if (!changedKeySecondary.startsWith(prefix)) {
      return false;
    }
  }
  if (startSecondaryKey && (startExclusive && lessThanEq(changedKeySecondary, startSecondaryKey) || lessThan(changedKeySecondary, startSecondaryKey))) {
    return false;
  }
  if (startKey && (startExclusive && lessThanEq(changedKeyPrimary, startKey) || lessThan(changedKeyPrimary, startKey))) {
    return false;
  }
  return true;
}
function isKeyPastInclusiveLimit(scanInfo, changedKey) {
  const { inclusiveLimitKey } = scanInfo;
  return scanInfo.options.limit !== void 0 && inclusiveLimitKey !== void 0 && greaterThan(changedKey, inclusiveLimitKey);
}
function* subscriptionsForDiffs(subscriptions, diffs) {
  for (const subscription of subscriptions) {
    if (subscription.matches(diffs)) {
      yield subscription;
    }
  }
}
function watcherMatchesDiff(diff3, prefix, indexName) {
  if (prefix === "") {
    return true;
  }
  const compareKey = indexName ? (diffOp) => decodeIndexKey(diffOp.key)[0] : (diffOp) => diffOp.key;
  const i = diffBinarySearch(diff3, prefix, compareKey);
  return i < diff3.length && compareKey(diff3[i]).startsWith(prefix);
}
function diffBinarySearch(diff3, prefix, compareKey) {
  return binarySearch2(
    diff3.length,
    (i) => compareUTF8(prefix, compareKey(diff3[i]))
  );
}
function getNonCryptoRandomValues(array8) {
  if (array8 === null) {
    throw new TypeError("array cannot be null");
  }
  for (let i = 0; i < array8.length; i++) {
    array8[i] = Math.floor(Math.random() * 256);
  }
  return array8;
}
function getSessionID() {
  if (sessionID === "") {
    const buf = new Uint8Array(4);
    getNonCryptoRandomValues(buf);
    sessionID = Array.from(buf, (x) => x.toString(16)).join("");
  }
  return sessionID;
}
function newRequestID(clientID) {
  const counter = REQUEST_COUNTERS.get(clientID) ?? 0;
  REQUEST_COUNTERS.set(clientID, counter + 1);
  return `${clientID}-${getSessionID()}-${counter}`;
}
async function throwIfError(p) {
  const res = await p;
  if (res) {
    throw res.error;
  }
}
function reload() {
  if (typeof location !== "undefined") {
    location.reload();
  }
}
function validateOptions(options2) {
  const { name, clientMaxAgeMs } = options2;
  if (typeof name !== "string" || !name) {
    throw new TypeError("name is required and must be non-empty");
  }
  if (clientMaxAgeMs !== void 0) {
    const min = Math.max(GC_INTERVAL, HEARTBEAT_INTERVAL);
    if (typeof clientMaxAgeMs !== "number" || clientMaxAgeMs <= min) {
      throw new TypeError(
        `clientAgeMaxMs must be a number larger than ${min}ms`
      );
    }
  }
}
function makeIDBName(name, schemaVersion) {
  return makeIDBNameInternal(name, schemaVersion, Latest);
}
function makeIDBNameInternal(name, schemaVersion, formatVersion) {
  const n2 = `rep:${name}:${formatVersion}`;
  return schemaVersion ? `${n2}:${schemaVersion}` : n2;
}
function createMemStore(name) {
  return new MemStore(name);
}
function getKVStoreProvider(lc, kvStore) {
  switch (kvStore) {
    case "idb":
    case void 0:
      return {
        create: /* @__PURE__ */ __name((name) => newIDBStoreWithMemFallback(lc, name), "create"),
        drop: dropIDBStoreWithMemFallback
      };
    case "mem":
      return {
        create: createMemStore,
        drop: /* @__PURE__ */ __name((name) => dropMemStore(name), "drop")
      };
    default:
      return kvStore;
  }
}
function initCollectIDBDatabases(idbDatabasesStore, kvDropStore, collectInterval, initialCollectDelay, maxAge, enableMutationRecovery, onClientsDeleted, lc, signal) {
  let initial2 = true;
  initBgIntervalProcess(
    "CollectIDBDatabases",
    async () => {
      await collectIDBDatabases(
        idbDatabasesStore,
        Date.now(),
        maxAge,
        kvDropStore,
        enableMutationRecovery,
        onClientsDeleted
      );
    },
    () => {
      if (initial2) {
        initial2 = false;
        return initialCollectDelay;
      }
      return collectInterval;
    },
    lc,
    signal
  );
}
async function collectIDBDatabases(idbDatabasesStore, now, maxAge, kvDropStore, enableMutationRecovery, onClientsDeleted, newDagStore = defaultNewDagStore) {
  const databases = await idbDatabasesStore.getDatabases();
  const dbs = Object.values(databases);
  const collectResults = await Promise.all(
    dbs.map(
      async (db2) => [
        db2.name,
        await gatherDatabaseInfoForCollect(
          db2,
          now,
          maxAge,
          enableMutationRecovery,
          newDagStore
        )
      ]
    )
  );
  const dbNamesToRemove = [];
  const dbNamesToKeep = [];
  const clientIDsToRemove = [];
  const clientGroupIDsToRemove = [];
  for (const [
    dbName,
    [canCollect, clientIDs, clientGroupIDs]
  ] of collectResults) {
    if (canCollect) {
      dbNamesToRemove.push(dbName);
      clientIDsToRemove.push(...clientIDs);
      clientGroupIDsToRemove.push(...clientGroupIDs);
    } else {
      dbNamesToKeep.push(dbName);
    }
  }
  const { errors } = await dropDatabases(
    idbDatabasesStore,
    dbNamesToRemove,
    kvDropStore
  );
  if (errors.length) {
    throw errors[0];
  }
  if (clientIDsToRemove.length || clientGroupIDsToRemove.length) {
    const newClientIDsToRemove = clientIDsToRemove;
    const newClientGroupIDsToRemove = clientGroupIDsToRemove;
    for (const name of dbNamesToKeep) {
      await withWrite(newDagStore(name), async (dagWrite) => {
        const { clientIDs, clientGroupIDs } = await addDeletedClients(
          dagWrite,
          clientIDsToRemove,
          clientGroupIDsToRemove
        );
        newClientIDsToRemove.push(...clientIDs);
        newClientGroupIDsToRemove.push(...clientGroupIDs);
      });
    }
    onClientsDeleted(
      normalize(newClientIDsToRemove),
      normalize(newClientGroupIDsToRemove)
    );
  }
}
async function dropDatabaseInternal(name, idbDatabasesStore, kvDropStore) {
  await kvDropStore(name);
  await idbDatabasesStore.deleteDatabases([name]);
}
async function dropDatabases(idbDatabasesStore, namesToRemove, kvDropStore) {
  const dropStoreResults = await Promise.allSettled(
    namesToRemove.map(async (name) => {
      await dropDatabaseInternal(name, idbDatabasesStore, kvDropStore);
      return name;
    })
  );
  const dropped = [];
  const errors = [];
  for (const result of dropStoreResults) {
    if (result.status === "fulfilled") {
      dropped.push(result.value);
    } else {
      errors.push(result.reason);
    }
  }
  return { dropped, errors };
}
function defaultNewDagStore(name) {
  const perKvStore = new IDBStore(name);
  return new StoreImpl(perKvStore, newRandomHash, assertHash);
}
function gatherDatabaseInfoForCollect(db2, now, maxAge, enableMutationRecovery, newDagStore) {
  if (db2.replicacheFormatVersion > Latest) {
    return [false];
  }
  assert3(db2.lastOpenedTimestampMS !== void 0);
  if (now - db2.lastOpenedTimestampMS < maxAge) {
    return [false];
  }
  assert3(
    db2.replicacheFormatVersion === DD31 || db2.replicacheFormatVersion === V6 || db2.replicacheFormatVersion === V7
  );
  return canDatabaseBeCollectedAndGetDeletedClientIDs(
    enableMutationRecovery,
    newDagStore(db2.name)
  );
}
async function dropDatabase(dbName, opts) {
  const logContext = createLogContext(opts?.logLevel, opts?.logSinks, {
    dropDatabase: void 0
  });
  const kvStoreProvider = getKVStoreProvider(logContext, opts?.kvStore);
  await dropDatabaseInternal(
    dbName,
    new IDBDatabasesStore(kvStoreProvider.create),
    kvStoreProvider.drop
  );
}
function canDatabaseBeCollectedAndGetDeletedClientIDs(enableMutationRecovery, perdag) {
  return withRead(perdag, async (read) => {
    if (enableMutationRecovery) {
      const clientGroups = await getClientGroups(read);
      for (const clientGroup of clientGroups.values()) {
        if (clientGroupHasPendingMutations(clientGroup)) {
          return [false];
        }
      }
    }
    const clients = await getClients(read);
    const { clientIDs, clientGroupIDs } = await getDeletedClients(read);
    const newClientIDs = [...clientIDs];
    const newClientGroupIDs = [...clientGroupIDs];
    for (const [clientID, client2] of clients) {
      newClientIDs.push(clientID);
      newClientGroupIDs.push(client2.clientGroupID);
    }
    return [true, newClientIDs, newClientGroupIDs];
  });
}
function relationships(table22, cb) {
  const relationships2 = cb({ many, one });
  return {
    name: table22.schema.name,
    relationships: relationships2
  };
}
function many(...args) {
  return args.map((arg) => ({
    sourceField: arg.sourceField,
    destField: arg.destField,
    destSchema: arg.destSchema.schema.name,
    cardinality: "many"
  }));
}
function one(...args) {
  return args.map((arg) => ({
    sourceField: arg.sourceField,
    destField: arg.destField,
    destSchema: arg.destSchema.schema.name,
    cardinality: "one"
  }));
}
function hash3(str, words) {
  let hash22 = 0n;
  for (let i = 0; i < words; i++) {
    hash22 = (hash22 << 32n) + BigInt(xxHash32(str, i));
  }
  return hash22;
}
function mapEntries(input, mapper) {
  const output = {};
  for (const entry of Object.entries(input)) {
    const mapped = mapper(entry[0], entry[1]);
    output[mapped[0]] = mapped[1];
  }
  return output;
}
function mapAllEntries(input, mapper) {
  const output = {};
  for (const mapped of mapper(Object.entries(input))) {
    output[mapped[0]] = mapped[1];
  }
  return output;
}
function normalizeClientSchema(schema2) {
  return {
    tables: mapAllEntries(
      schema2.tables,
      (tables) => tables.sort(keyCmp).map(([name, table22]) => [
        name,
        { columns: mapAllEntries(table22.columns, (e3) => e3.sort(keyCmp)) }
      ])
    )
  };
}
function table3(name) {
  return new TableBuilder({
    name,
    columns: {},
    primaryKey: []
  });
}
function string8() {
  return new ColumnBuilder2({
    type: "string",
    optional: false,
    customType: null
  });
}
function number4() {
  return new ColumnBuilder2({
    type: "number",
    optional: false,
    customType: null
  });
}
function boolean3() {
  return new ColumnBuilder2({
    type: "boolean",
    optional: false,
    customType: null
  });
}
function createSchema(options2) {
  const retTables = {};
  const retRelationships = {};
  const serverNames = /* @__PURE__ */ new Set();
  options2.tables.forEach((table22) => {
    const { serverName = table22.schema.name } = table22.schema;
    if (serverNames.has(serverName)) {
      throw new Error(`Multiple tables reference the name "${serverName}"`);
    }
    serverNames.add(serverName);
    if (retTables[table22.schema.name]) {
      throw new Error(
        `Table "${table22.schema.name}" is defined more than once in the schema`
      );
    }
    retTables[table22.schema.name] = table22.build();
  });
  options2.relationships?.forEach((relationships2) => {
    if (retRelationships[relationships2.name]) {
      throw new Error(
        `Relationships for table "${relationships2.name}" are defined more than once in the schema`
      );
    }
    retRelationships[relationships2.name] = relationships2.relationships;
    checkRelationship(
      relationships2.relationships,
      relationships2.name,
      retTables
    );
  });
  return {
    tables: retTables,
    relationships: retRelationships
  };
}
function checkRelationship(relationships2, tableName, tables) {
  Object.entries(relationships2).forEach(([name, rel]) => {
    let source2 = tables[tableName];
    rel.forEach((connection2) => {
      if (!tables[connection2.destSchema]) {
        throw new Error(
          `For relationship "${tableName}"."${name}", destination table "${connection2.destSchema}" is missing in the schema`
        );
      }
      if (!source2.columns[connection2.sourceField[0]]) {
        throw new Error(
          `For relationship "${tableName}"."${name}", the source field "${connection2.sourceField[0]}" is missing in the table schema "${source2.name}"`
        );
      }
      source2 = tables[connection2.destSchema];
    });
  });
}
function clientSchemaFrom(schema2) {
  const client2 = {
    tables: mapEntries(schema2.tables, (name, { serverName, columns }) => [
      serverName ?? name,
      {
        columns: mapEntries(columns, (name2, { serverName: serverName2, type }) => [
          serverName2 ?? name2,
          { type }
        ])
      }
    ])
  };
  const clientSchema2 = normalizeClientSchema(client2);
  const hash22 = h64(JSON.stringify(clientSchema2)).toString(36);
  return { clientSchema: clientSchema2, hash: hash22 };
}
function defined(arr2) {
  let i = arr2.findIndex((x) => x === void 0);
  if (i < 0) {
    return arr2;
  }
  const defined2 = arr2.slice(0, i);
  for (i++; i < arr2.length; i++) {
    const x = arr2[i];
    if (x !== void 0) {
      defined2.push(x);
    }
  }
  return defined2;
}
function areEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((e3, i) => e3 === arr2[i]);
}
function mustCompoundKey(field) {
  assert3(Array.isArray(field) && field.length >= 1);
  return field;
}
function transformAST(ast, transform) {
  const { tableName, columnName } = transform;
  const colName = /* @__PURE__ */ __name((c2) => columnName(ast.table, c2), "colName");
  const key2 = /* @__PURE__ */ __name((table22, k) => {
    const serverKey = k.map((col) => columnName(table22, col));
    return mustCompoundKey(serverKey);
  }, "key");
  const where = ast.where ? transform.where(ast.where) : void 0;
  const transformed = {
    schema: ast.schema,
    table: tableName(ast.table),
    alias: ast.alias,
    where: where ? transformWhere(where, ast.table, transform) : void 0,
    related: ast.related ? transform.related(
      ast.related.map(
        (r3) => ({
          correlation: {
            parentField: key2(ast.table, r3.correlation.parentField),
            childField: key2(r3.subquery.table, r3.correlation.childField)
          },
          hidden: r3.hidden,
          subquery: transformAST(r3.subquery, transform),
          system: r3.system
        })
      )
    ) : void 0,
    start: ast.start ? {
      ...ast.start,
      row: Object.fromEntries(
        Object.entries(ast.start.row).map(([col, val]) => [
          colName(col),
          val
        ])
      )
    } : void 0,
    limit: ast.limit,
    orderBy: ast.orderBy?.map(([col, dir3]) => [colName(col), dir3])
  };
  return transformed;
}
function transformWhere(where, table22, transform) {
  const { columnName } = transform;
  const condValue = /* @__PURE__ */ __name((c2) => c2.type !== "column" ? c2 : { ...c2, name: columnName(table22, c2.name) }, "condValue");
  const key2 = /* @__PURE__ */ __name((table32, k) => {
    const serverKey = k.map((col) => columnName(table32, col));
    return mustCompoundKey(serverKey);
  }, "key");
  if (where.type === "simple") {
    return { ...where, left: condValue(where.left) };
  } else if (where.type === "correlatedSubquery") {
    const { correlation, subquery } = where.related;
    return {
      ...where,
      related: {
        ...where.related,
        correlation: {
          parentField: key2(table22, correlation.parentField),
          childField: key2(subquery.table, correlation.childField)
        },
        subquery: transformAST(subquery, transform)
      }
    };
  }
  return {
    type: where.type,
    conditions: transform.conditions(
      where.conditions.map((c2) => transformWhere(c2, table22, transform))
    )
  };
}
function normalizeAST(ast) {
  let normalized = normalizeCache.get(ast);
  if (!normalized) {
    normalized = transformAST(ast, NORMALIZE_TRANSFORM);
    normalizeCache.set(ast, normalized);
  }
  return normalized;
}
function mapAST(ast, mapper) {
  return transformAST(ast, {
    tableName: /* @__PURE__ */ __name((table22) => mapper.tableName(table22), "tableName"),
    columnName: /* @__PURE__ */ __name((table22, col) => mapper.columnName(table22, col), "columnName"),
    related: /* @__PURE__ */ __name((r3) => r3, "related"),
    where: /* @__PURE__ */ __name((w) => w, "where"),
    conditions: /* @__PURE__ */ __name((c2) => c2, "conditions")
  });
}
function mapCondition(cond, table22, mapper) {
  return transformWhere(cond, table22, {
    tableName: /* @__PURE__ */ __name((table32) => mapper.tableName(table32), "tableName"),
    columnName: /* @__PURE__ */ __name((table32, col) => mapper.columnName(table32, col), "columnName"),
    related: /* @__PURE__ */ __name((r3) => r3, "related"),
    where: /* @__PURE__ */ __name((w) => w, "where"),
    conditions: /* @__PURE__ */ __name((c2) => c2, "conditions")
  });
}
function sortedRelated(related) {
  return related.sort(cmpRelated);
}
function cmpCondition(a, b2) {
  if (a.type === "simple") {
    if (b2.type !== "simple") {
      return -1;
    }
    return compareValuePosition(a.left, b2.left) || compareUTF8MaybeNull(a.op, b2.op) || compareValuePosition(a.right, b2.right);
  }
  if (b2.type === "simple") {
    return 1;
  }
  if (a.type === "correlatedSubquery") {
    if (b2.type !== "correlatedSubquery") {
      return -1;
    }
    return cmpRelated(a.related, b2.related) || compareUTF8MaybeNull(a.op, b2.op);
  }
  if (b2.type === "correlatedSubquery") {
    return -1;
  }
  const val = compareUTF8MaybeNull(a.type, b2.type);
  if (val !== 0) {
    return val;
  }
  for (let l = 0, r3 = 0; l < a.conditions.length && r3 < b2.conditions.length; l++, r3++) {
    const val2 = cmpCondition(a.conditions[l], b2.conditions[r3]);
    if (val2 !== 0) {
      return val2;
    }
  }
  return a.conditions.length - b2.conditions.length;
}
function compareValuePosition(a, b2) {
  if (a.type !== b2.type) {
    return compareUTF8(a.type, b2.type);
  }
  switch (a.type) {
    case "literal":
      assert3(b2.type === "literal");
      return compareUTF8(String(a.value), String(b2.value));
    case "column":
      assert3(b2.type === "column");
      return compareUTF8(a.name, b2.name);
    case "static":
      throw new Error(
        "Static parameters should be resolved before normalization"
      );
  }
}
function cmpRelated(a, b2) {
  return compareUTF8(must(a.subquery.alias), must(b2.subquery.alias));
}
function flattened(cond) {
  if (cond.type === "simple" || cond.type === "correlatedSubquery") {
    return cond;
  }
  const conditions = defined(
    cond.conditions.flatMap(
      (c2) => c2.type === cond.type ? c2.conditions.map((c22) => flattened(c22)) : flattened(c2)
    )
  );
  switch (conditions.length) {
    case 0:
      return void 0;
    case 1:
      return conditions[0];
    default:
      return {
        type: cond.type,
        conditions
      };
  }
}
function compareUTF8MaybeNull(a, b2) {
  if (a !== null && b2 !== null) {
    return compareUTF8(a, b2);
  }
  if (b2 !== null) {
    return -1;
  }
  if (a !== null) {
    return 1;
  }
  return 0;
}
function hashOfAST(ast) {
  const normalized = normalizeAST(ast);
  const cached = hashCache.get(normalized);
  if (cached) {
    return cached;
  }
  const hash22 = h64(JSON.stringify(normalized)).toString(36);
  hashCache.set(normalized, hash22);
  return hash22;
}
function isOneHop(r3) {
  return r3.length === 1;
}
function isTwoHop(r3) {
  return r3.length === 2;
}
function* take(stream, limit) {
  if (limit < 1) {
    return;
  }
  let count3 = 0;
  for (const v2 of stream) {
    yield v2;
    if (++count3 === limit) {
      break;
    }
  }
}
function first(stream) {
  const it = stream[Symbol.iterator]();
  const { value } = it.next();
  it.return?.();
  return value;
}
function maybeSplitAndPushEditChange(change, predicate, output) {
  const oldWasPresent = predicate(change.oldNode.row);
  const newIsPresent = predicate(change.node.row);
  if (oldWasPresent && newIsPresent) {
    output.push(change);
  } else if (oldWasPresent && !newIsPresent) {
    output.push({
      type: "remove",
      node: change.oldNode
    });
  } else if (!oldWasPresent && newIsPresent) {
    output.push({
      type: "add",
      node: change.node
    });
  }
}
function filterPush(change, output, predicate) {
  if (!predicate) {
    output.push(change);
    return;
  }
  switch (change.type) {
    case "add":
    case "remove":
      if (predicate(change.node.row)) {
        output.push(change);
      }
      break;
    case "child":
      if (predicate(change.node.row)) {
        output.push(change);
      }
      break;
    case "edit":
      maybeSplitAndPushEditChange(change, predicate, output);
      break;
    default:
      unreachable(change);
  }
}
function makeStorageKeyForValues(values2) {
  const json22 = JSON.stringify(["pKeySet", ...values2]);
  return json22.substring(1, json22.length - 1) + ",";
}
function makeStorageKeyPrefix(row, key2) {
  return makeStorageKeyForValues(key2.map((k) => row[k]));
}
function makeStorageKey(key2, primaryKey, row) {
  const values2 = key2.map((k) => row[k]);
  for (const key22 of primaryKey) {
    values2.push(row[key22]);
  }
  return makeStorageKeyForValues(values2);
}
function rowEqualsForCompoundKey(a, b2, key2) {
  for (let i = 0; i < key2.length; i++) {
    if (compareValues(a[key2[i]], b2[key2[i]]) !== 0) {
      return false;
    }
  }
  return true;
}
function getTakeStateKey(partitionKey, rowOrConstraint) {
  const partitionValues = [];
  if (partitionKey && rowOrConstraint) {
    for (const key2 of partitionKey) {
      partitionValues.push(rowOrConstraint[key2]);
    }
  }
  return JSON.stringify(["take", ...partitionValues]);
}
function constraintMatchesPartitionKey(constraint, partitionKey) {
  if (constraint === void 0 || partitionKey === void 0) {
    return constraint === partitionKey;
  }
  if (partitionKey.length !== Object.keys(constraint).length) {
    return false;
  }
  for (const key2 of partitionKey) {
    if (!hasOwn(constraint, key2)) {
      return false;
    }
  }
  return true;
}
function makePartitionKeyComparator(partitionKey) {
  return (a, b2) => {
    for (const key2 of partitionKey) {
      const cmp2 = compareValues(a[key2], b2[key2]);
      if (cmp2 !== 0) {
        return cmp2;
      }
    }
    return 0;
  };
}
function getLikePredicate(pattern2, flags) {
  const op = getLikeOp(String(pattern2), flags);
  return (lhs) => {
    assertString(lhs);
    return op(String(lhs));
  };
}
function getLikeOp(pattern2, flags) {
  if (!/_|%|\\/.test(pattern2)) {
    if (flags === "i") {
      const rhsLower = pattern2.toLowerCase();
      return (lhs) => lhs.toLowerCase() === rhsLower;
    }
    return (lhs) => lhs === pattern2;
  }
  const re = patternToRegExp(pattern2, flags);
  return (lhs) => re.test(lhs);
}
function patternToRegExp(source2, flags = "") {
  let pattern2 = "^";
  for (let i = 0; i < source2.length; i++) {
    let c2 = source2[i];
    switch (c2) {
      case "%":
        pattern2 += ".*";
        break;
      case "_":
        pattern2 += ".";
        break;
      // @ts-expect-error fallthrough
      case "\\":
        if (i === source2.length - 1) {
          throw new Error("LIKE pattern must not end with escape character");
        }
        i++;
        c2 = source2[i];
      // fall through
      default:
        if (specialCharsRe.test(c2)) {
          pattern2 += "\\";
        }
        pattern2 += c2;
        break;
    }
  }
  return new RegExp(pattern2 + "$", flags + "m");
}
function createPredicate(condition) {
  if (condition.type !== "simple") {
    const predicates = condition.conditions.map((c2) => createPredicate(c2));
    return condition.type === "and" ? (row) => {
      for (const predicate of predicates) {
        if (!predicate(row)) {
          return false;
        }
      }
      return true;
    } : (row) => {
      for (const predicate of predicates) {
        if (predicate(row)) {
          return true;
        }
      }
      return false;
    };
  }
  const { left } = condition;
  const { right } = condition;
  assert3(
    right.type !== "static",
    "static values should be resolved before creating predicates"
  );
  assert3(
    left.type !== "static",
    "static values should be resolved before creating predicates"
  );
  switch (condition.op) {
    case "IS":
    case "IS NOT": {
      const impl2 = createIsPredicate(right.value, condition.op);
      if (left.type === "literal") {
        const result = impl2(left.value);
        return () => result;
      }
      return (row) => impl2(row[left.name]);
    }
  }
  if (right.value === null || right.value === void 0) {
    return (_row) => false;
  }
  const impl = createPredicateImpl(right.value, condition.op);
  if (left.type === "literal") {
    if (left.value === null || left.value === void 0) {
      return (_row) => false;
    }
    const result = impl(left.value);
    return () => result;
  }
  return (row) => {
    const lhs = row[left.name];
    if (lhs === null || lhs === void 0) {
      return false;
    }
    return impl(lhs);
  };
}
function createIsPredicate(rhs, operator) {
  switch (operator) {
    case "IS":
      return (lhs) => lhs === rhs;
    case "IS NOT":
      return (lhs) => lhs !== rhs;
  }
}
function createPredicateImpl(rhs, operator) {
  switch (operator) {
    case "=":
      return (lhs) => lhs === rhs;
    case "!=":
      return (lhs) => lhs !== rhs;
    case "<":
      return (lhs) => lhs < rhs;
    case "<=":
      return (lhs) => lhs <= rhs;
    case ">":
      return (lhs) => lhs > rhs;
    case ">=":
      return (lhs) => lhs >= rhs;
    case "LIKE":
      return getLikePredicate(rhs, "");
    case "NOT LIKE":
      return not2(getLikePredicate(rhs, ""));
    case "ILIKE":
      return getLikePredicate(rhs, "i");
    case "NOT ILIKE":
      return not2(getLikePredicate(rhs, "i"));
    case "IN": {
      assert3(Array.isArray(rhs));
      const set2 = new Set(rhs);
      return (lhs) => set2.has(lhs);
    }
    case "NOT IN": {
      assert3(Array.isArray(rhs));
      const set2 = new Set(rhs);
      return (lhs) => !set2.has(lhs);
    }
    default:
      operator;
      throw new Error(`Unexpected operator: ${operator}`);
  }
}
function not2(f) {
  return (lhs) => !f(lhs);
}
function transformFilters(filters) {
  if (!filters) {
    return { filters: void 0, conditionsRemoved: false };
  }
  switch (filters.type) {
    case "simple":
      return { filters, conditionsRemoved: false };
    case "correlatedSubquery":
      return { filters: void 0, conditionsRemoved: true };
    case "and": {
      const transformedConditions = [];
      for (const cond of filters.conditions) {
        assert3(cond.type === "simple" || cond.type === "correlatedSubquery");
        if (cond.type === "simple") {
          transformedConditions.push(cond);
        }
      }
      const conditionsRemoved = transformedConditions.length !== filters.conditions.length;
      if (transformedConditions.length === 0) {
        return { filters: void 0, conditionsRemoved };
      }
      if (transformedConditions.length === 1) {
        return {
          filters: transformedConditions[0],
          conditionsRemoved
        };
      }
      return {
        filters: {
          type: "and",
          conditions: transformedConditions
        },
        conditionsRemoved
      };
    }
    case "or": {
      const transformedConditions = [];
      let conditionsRemoved = false;
      for (const cond of filters.conditions) {
        assert3(cond.type !== "or");
        const transformed = transformFilters(cond);
        if (transformed.filters === void 0) {
          return { filters: void 0, conditionsRemoved: true };
        }
        conditionsRemoved = conditionsRemoved || transformed.conditionsRemoved;
        transformedConditions.push(transformed.filters);
      }
      return {
        filters: { type: "or", conditions: transformedConditions },
        conditionsRemoved
      };
    }
    default:
      unreachable(filters);
  }
}
function buildPipeline(ast, delegate) {
  return buildPipelineInternal(ast, delegate, "");
}
function buildPipelineInternal(ast, delegate, name, partitionKey) {
  const source2 = delegate.getSource(ast.table);
  if (!source2) {
    throw new Error(`Source not found: ${ast.table}`);
  }
  ast = uniquifyCorrelatedSubqueryConditionAliases(ast);
  const csqsFromCondition = gatherCorrelatedSubqueryQueriesFromCondition(
    ast.where
  );
  const splitEditKeys = partitionKey ? new Set(partitionKey) : /* @__PURE__ */ new Set();
  for (const csq of csqsFromCondition) {
    for (const key2 of csq.correlation.parentField) {
      splitEditKeys.add(key2);
    }
  }
  if (ast.related) {
    for (const csq of ast.related) {
      for (const key2 of csq.correlation.parentField) {
        splitEditKeys.add(key2);
      }
    }
  }
  const conn = source2.connect(must(ast.orderBy), ast.where, splitEditKeys);
  let end = delegate.decorateInput(conn, `${name}:source(${ast.table})`);
  const { fullyAppliedFilters } = conn;
  if (ast.start) {
    end = delegate.decorateInput(new Skip(end, ast.start), `${name}:skip)`);
  }
  for (const csq of csqsFromCondition) {
    end = applyCorrelatedSubQuery(csq, delegate, end, name);
  }
  if (ast.where && !fullyAppliedFilters) {
    end = applyWhere(end, ast.where, delegate, name);
  }
  if (ast.limit !== void 0) {
    const takeName = `${name}:take`;
    end = delegate.decorateInput(
      new Take(end, delegate.createStorage(takeName), ast.limit, partitionKey),
      takeName
    );
  }
  if (ast.related) {
    for (const csq of ast.related) {
      end = applyCorrelatedSubQuery(csq, delegate, end, name);
    }
  }
  return end;
}
function applyWhere(input, condition, delegate, name) {
  switch (condition.type) {
    case "and":
      return applyAnd(input, condition, delegate, name);
    case "or":
      return applyOr(input, condition, delegate, name);
    case "correlatedSubquery":
      return applyCorrelatedSubqueryCondition(input, condition, delegate, name);
    case "simple":
      return applySimpleCondition(input, condition);
  }
}
function applyAnd(input, condition, delegate, name) {
  for (const subCondition of condition.conditions) {
    input = applyWhere(input, subCondition, delegate, name);
  }
  return input;
}
function applyOr(input, condition, delegate, name) {
  const [subqueryConditions, otherConditions] = groupSubqueryConditions(condition);
  if (subqueryConditions.length === 0) {
    return new Filter(
      input,
      createPredicate({
        type: "or",
        conditions: otherConditions
      })
    );
  }
  const fanOut = new FanOut(input);
  const branches = subqueryConditions.map(
    (subCondition) => applyWhere(fanOut, subCondition, delegate, name)
  );
  if (otherConditions.length > 0) {
    branches.push(
      new Filter(
        fanOut,
        createPredicate({
          type: "or",
          conditions: otherConditions
        })
      )
    );
  }
  const ret = new FanIn(fanOut, branches);
  fanOut.setFanIn(ret);
  return ret;
}
function groupSubqueryConditions(condition) {
  const partitioned = [[], []];
  for (const subCondition of condition.conditions) {
    if (isNotAndDoesNotContainSubquery(subCondition)) {
      partitioned[1].push(subCondition);
    } else {
      partitioned[0].push(subCondition);
    }
  }
  return partitioned;
}
function isNotAndDoesNotContainSubquery(condition) {
  if (condition.type === "correlatedSubquery") {
    return false;
  }
  if (condition.type === "and") {
    return condition.conditions.every(isNotAndDoesNotContainSubquery);
  }
  assert3(condition.type !== "or", "where conditions are expected to be in DNF");
  return true;
}
function applySimpleCondition(input, condition) {
  return new Filter(input, createPredicate(condition));
}
function applyCorrelatedSubQuery(sq, delegate, end, name) {
  assert3(sq.subquery.alias, "Subquery must have an alias");
  const child = buildPipelineInternal(
    sq.subquery,
    delegate,
    `${name}.${sq.subquery.alias}`,
    sq.correlation.childField
  );
  const joinName = `${name}:join(${sq.subquery.alias})`;
  end = new Join({
    parent: end,
    child,
    storage: delegate.createStorage(joinName),
    parentKey: sq.correlation.parentField,
    childKey: sq.correlation.childField,
    relationshipName: sq.subquery.alias,
    hidden: sq.hidden ?? false,
    system: sq.system ?? "client"
  });
  return delegate.decorateInput(end, joinName);
}
function applyCorrelatedSubqueryCondition(input, condition, delegate, name) {
  assert3(condition.op === "EXISTS" || condition.op === "NOT EXISTS");
  const existsName = `${name}:exists(${condition.related.subquery.alias})`;
  return delegate.decorateInput(
    new Exists(
      input,
      delegate.createStorage(existsName),
      must(condition.related.subquery.alias),
      condition.related.correlation.parentField,
      condition.op
    ),
    existsName
  );
}
function gatherCorrelatedSubqueryQueriesFromCondition(condition) {
  const csqs = [];
  const gather = /* @__PURE__ */ __name((condition2) => {
    if (condition2.type === "correlatedSubquery") {
      assert3(condition2.op === "EXISTS" || condition2.op === "NOT EXISTS");
      csqs.push({
        ...condition2.related,
        subquery: {
          ...condition2.related.subquery,
          limit: condition2.related.system === "permissions" ? PERMISSIONS_EXISTS_LIMIT : EXISTS_LIMIT
        }
      });
      return;
    }
    if (condition2.type === "and" || condition2.type === "or") {
      for (const c2 of condition2.conditions) {
        gather(c2);
      }
      return;
    }
  }, "gather");
  if (condition) {
    gather(condition);
  }
  return csqs;
}
function assertOrderingIncludesPK(ordering, pk) {
  const orderingFields = ordering.map(([field]) => field);
  const missingFields = pk.filter((pkField) => !orderingFields.includes(pkField));
  if (missingFields.length > 0) {
    throw new Error(
      `Ordering must include all primary key fields. Missing: ${missingFields.join(
        ", "
      )}. ZQL automatically appends primary key fields to the ordering if they are missing 
      so a common cause of this error is a casing mismatch between Postgres and ZQL.
      E.g., "userid" vs "userID".
      You may want to add double-quotes around your Postgres column names to prevent Postgres from lower-casing them:
      https://www.postgresql.org/docs/current/sql-syntax-lexical.htm`
    );
  }
}
function uniquifyCorrelatedSubqueryConditionAliases(ast) {
  if (!ast.where) {
    return ast;
  }
  const { where } = ast;
  if (where.type !== "and" && where.type !== "or") {
    return ast;
  }
  let count3 = 0;
  const uniquifyCorrelatedSubquery = /* @__PURE__ */ __name((csqc) => ({
    ...csqc,
    related: {
      ...csqc.related,
      subquery: {
        ...csqc.related.subquery,
        alias: (csqc.related.subquery.alias ?? "") + "_" + count3++
      }
    }
  }), "uniquifyCorrelatedSubquery");
  const uniquifyAnd = /* @__PURE__ */ __name((and22) => {
    const conds2 = [];
    for (const cond of and22.conditions) {
      if (cond.type === "correlatedSubquery") {
        conds2.push(uniquifyCorrelatedSubquery(cond));
      } else {
        conds2.push(cond);
      }
    }
    return {
      ...and22,
      conditions: conds2
    };
  }, "uniquifyAnd");
  if (where.type === "and") {
    return {
      ...ast,
      where: uniquifyAnd(where)
    };
  }
  const conds = [];
  for (const cond of where.conditions) {
    if (cond.type === "simple") {
      conds.push(cond);
    } else if (cond.type === "correlatedSubquery") {
      conds.push(uniquifyCorrelatedSubquery(cond));
    } else if (cond.type === "and") {
      conds.push(uniquifyAnd(cond));
    }
  }
  return {
    ...ast,
    where: {
      ...where,
      conditions: conds
    }
  };
}
function and2(...conditions) {
  const expressions = filterTrue(filterUndefined(conditions));
  if (expressions.length === 1) {
    return expressions[0];
  }
  if (expressions.some(isAlwaysFalse)) {
    return FALSE;
  }
  return { type: "and", conditions: expressions };
}
function or2(...conditions) {
  const expressions = filterFalse(filterUndefined(conditions));
  if (expressions.length === 1) {
    return expressions[0];
  }
  if (expressions.some(isAlwaysTrue)) {
    return TRUE;
  }
  return { type: "or", conditions: expressions };
}
function not22(expression) {
  switch (expression.type) {
    case "and":
      return {
        type: "or",
        conditions: expression.conditions.map(not22)
      };
    case "or":
      return {
        type: "and",
        conditions: expression.conditions.map(not22)
      };
    case "correlatedSubquery":
      return {
        type: "correlatedSubquery",
        related: expression.related,
        op: negateOperator(expression.op)
      };
    case "simple":
      return {
        type: "simple",
        op: negateOperator(expression.op),
        left: expression.left,
        right: expression.right
      };
  }
}
function cmp(field, opOrValue, value) {
  let op;
  if (value === void 0) {
    value = opOrValue;
    op = "=";
  } else {
    op = opOrValue;
  }
  return {
    type: "simple",
    left: { type: "column", name: field },
    right: isParameterReference(value) ? value[toStaticParam]() : { type: "literal", value },
    op
  };
}
function isParameterReference(value) {
  return value !== null && typeof value === "object" && value[toStaticParam];
}
function isAlwaysTrue(condition) {
  return condition.type === "and" && condition.conditions.length === 0;
}
function isAlwaysFalse(condition) {
  return condition.type === "or" && condition.conditions.length === 0;
}
function flatten(type, conditions) {
  const flattened2 = [];
  for (const c2 of conditions) {
    if (c2.type === type) {
      flattened2.push(...c2.conditions);
    } else {
      flattened2.push(c2);
    }
  }
  return flattened2;
}
function negateOperator(op) {
  return must(negateOperatorMap[op]);
}
function filterUndefined(array8) {
  return array8.filter((e3) => e3 !== void 0);
}
function filterTrue(conditions) {
  return conditions.filter((c2) => !isAlwaysTrue(c2));
}
function filterFalse(conditions) {
  return conditions.filter((c2) => !isAlwaysFalse(c2));
}
function dnf(condition) {
  return unwrap(dnfInner(condition));
}
function dnfInner(condition) {
  switch (condition.type) {
    case "simple":
    case "correlatedSubquery":
      return { type: "or", conditions: [condition] };
    case "and":
      return distributeAnd(condition.conditions.map(dnfInner));
    case "or":
      return {
        type: "or",
        conditions: flatten(
          "or",
          condition.conditions.map(dnfInner).flatMap((c2) => c2.conditions)
        )
      };
    default:
      unreachable(condition);
  }
}
function distributeAnd(conditions) {
  if (conditions.length === 0) {
    return { type: "or", conditions: [TRUE] };
  }
  return conditions.reduce((acc, orCondition) => {
    const newConditions = [];
    for (const accCondition of acc.conditions) {
      for (const orSubCondition of orCondition.conditions) {
        newConditions.push({
          type: "and",
          conditions: [accCondition, orSubCondition]
        });
      }
    }
    return {
      type: "or",
      conditions: flatten("or", newConditions)
    };
  });
}
function unwrap(c2) {
  if (c2.type === "simple" || c2.type === "correlatedSubquery") {
    return c2;
  }
  if (c2.conditions.length === 1) {
    return unwrap(c2.conditions[0]);
  }
  return { type: c2.type, conditions: flatten(c2.type, c2.conditions.map(unwrap)) };
}
function newQuery(delegate, schema2, table22) {
  return new QueryImpl(delegate, schema2, table22);
}
function newQueryWithDetails(delegate, schema2, tableName, ast, format2) {
  return new QueryImpl(delegate, schema2, tableName, ast, format2);
}
function staticParam(anchorClass, field) {
  return {
    type: "static",
    anchor: anchorClass,
    // for backwards compatibility
    field: field.length === 1 ? field[0] : field
  };
}
function addPrimaryKeys(schema2, orderBy) {
  orderBy = orderBy ?? [];
  const { primaryKey } = schema2;
  const primaryKeysToAdd = new Set(primaryKey);
  for (const [field] of orderBy) {
    primaryKeysToAdd.delete(field);
  }
  if (primaryKeysToAdd.size === 0) {
    return orderBy;
  }
  return [
    ...orderBy,
    ...[...primaryKeysToAdd].map((key2) => [key2, "asc"])
  ];
}
function addPrimaryKeysToAst(schema2, ast) {
  return {
    ...ast,
    orderBy: addPrimaryKeys(schema2, ast.orderBy)
  };
}
function arrayViewFactory(_query, input, format2, onDestroy, onTransactionCommit, queryComplete) {
  const v2 = new ArrayView(input, format2, queryComplete);
  v2.onDestroy = onDestroy;
  onTransactionCommit(() => {
    v2.flush();
  });
  return v2;
}
function isCompoundKey(field) {
  return Array.isArray(field) && field.length >= 1;
}
function clientToServer(tables) {
  return createMapperFrom("client", tables);
}
function serverToClient(tables) {
  return createMapperFrom("server", tables);
}
function createMapperFrom(src, tables) {
  const mapping = new Map(
    Object.entries(tables).map(
      ([tableName, { serverName: serverTableName, columns }]) => {
        let allColumnsSame = true;
        const names = {};
        for (const [name, { serverName }] of Object.entries(columns)) {
          if (serverName && serverName !== name) {
            allColumnsSame = false;
          }
          if (src === "client") {
            names[name] = serverName ?? name;
          } else {
            names[serverName ?? name] = name;
          }
        }
        return [
          src === "client" ? tableName : serverTableName ?? tableName,
          {
            tableName: src === "client" ? serverTableName ?? tableName : tableName,
            columns: names,
            allColumnsSame
          }
        ];
      }
    )
  );
  return new NameMapper(mapping);
}
async function definePermissions(schema2, definer) {
  const expressionBuilders = {};
  for (const name of Object.keys(schema2.tables)) {
    expressionBuilders[name] = new StaticQuery(
      schema2,
      name
    ).expressionBuilder();
  }
  const config2 = await definer();
  return compilePermissions(schema2, config2, expressionBuilders);
}
function compilePermissions(schema2, authz, expressionBuilders) {
  if (!authz) {
    return void 0;
  }
  const nameMapper = clientToServer(schema2.tables);
  const ret = { tables: {} };
  for (const [tableName, tableConfig] of Object.entries(authz)) {
    const serverName = schema2.tables[tableName].serverName ?? tableName;
    ret.tables[serverName] = {
      row: compileRowConfig(
        nameMapper,
        tableName,
        tableConfig.row,
        expressionBuilders[tableName]
      ),
      cell: compileCellConfig(
        nameMapper,
        tableName,
        tableConfig.cell,
        expressionBuilders[tableName]
      )
    };
  }
  return ret;
}
function compileRowConfig(clientToServer2, tableName, rowRules, expressionBuilder) {
  if (!rowRules) {
    return void 0;
  }
  return {
    select: compileRules(
      clientToServer2,
      tableName,
      rowRules.select,
      expressionBuilder
    ),
    insert: compileRules(
      clientToServer2,
      tableName,
      rowRules.insert,
      expressionBuilder
    ),
    update: {
      preMutation: compileRules(
        clientToServer2,
        tableName,
        rowRules.update?.preMutation,
        expressionBuilder
      ),
      postMutation: compileRules(
        clientToServer2,
        tableName,
        rowRules.update?.postMutation,
        expressionBuilder
      )
    },
    delete: compileRules(
      clientToServer2,
      tableName,
      rowRules.delete,
      expressionBuilder
    )
  };
}
function compileRules(clientToServer2, tableName, rules, expressionBuilder) {
  if (!rules) {
    return void 0;
  }
  return rules.map((rule) => {
    const cond = rule(authDataRef, expressionBuilder);
    return ["allow", mapCondition(cond, tableName, clientToServer2)];
  });
}
function compileCellConfig(clientToServer2, tableName, cellRules, expressionBuilder) {
  if (!cellRules) {
    return void 0;
  }
  const ret = {};
  for (const [columnName, rules] of Object.entries(cellRules)) {
    ret[columnName] = {
      select: compileRules(
        clientToServer2,
        tableName,
        rules.select,
        expressionBuilder
      ),
      insert: compileRules(
        clientToServer2,
        tableName,
        rules.insert,
        expressionBuilder
      ),
      update: {
        preMutation: compileRules(
          clientToServer2,
          tableName,
          rules.update?.preMutation,
          expressionBuilder
        ),
        postMutation: compileRules(
          clientToServer2,
          tableName,
          rules.update?.postMutation,
          expressionBuilder
        )
      },
      delete: compileRules(
        clientToServer2,
        tableName,
        rules.delete,
        expressionBuilder
      )
    };
  }
  return ret;
}
function baseTracker(anchor) {
  return new Proxy(
    {
      [toStaticParam]: () => {
        throw new Error("no JWT field specified");
      }
    },
    new CallTracker(anchor, [])
  );
}
function encodeSecProtocols(initConnectionMessage, authToken) {
  const protocols = {
    initConnectionMessage,
    authToken
  };
  return encodeURIComponent(btoa(JSON.stringify(protocols)));
}
function mapCRUD(arg, map) {
  return {
    ops: arg.ops.map(
      ({ op, tableName, primaryKey, value }) => ({
        op,
        tableName: map.tableName(tableName),
        primaryKey: map.columns(tableName, primaryKey),
        value: map.row(tableName, value)
        // The cast is necessary because ts objects to the `value` field
        // for "delete" ops being different.
      })
    )
  };
}
function customMutatorKey(namespace, name) {
  assert3(!namespace.includes("|"), "mutator namespaces must not include a |");
  assert3(!name.includes("|"), "mutator names must not include a |");
  return `${namespace}|${name}`;
}
function nanoid(size2 = 21) {
  const randomBytes2 = getNonCryptoRandomValues(new Uint8Array(size2));
  return randomBytes2.reduce((id, byte) => {
    byte &= 63;
    if (byte < 36) {
      id += byte.toString(36);
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte > 62) {
      id += "-";
    } else {
      id += "_";
    }
    return id;
  }, "");
}
function send2(ws, data) {
  ws.send(JSON.stringify(data));
}
function valuesFrom(root2, comparator2, lowestKey, inclusive) {
  const info3 = findPath(lowestKey, root2, comparator2);
  if (info3 === void 0) {
    return iterator(() => ({ done: true, value: void 0 }));
  }
  let [nodeQueue, nodeIndex, leaf] = info3;
  let i = lowestKey === void 0 ? -1 : indexOf(lowestKey, leaf.keys, 0, comparator2) - 1;
  if (!inclusive && i < leaf.keys.length && // +1 because we did -1 above.
  comparator2(leaf.keys[i + 1], lowestKey) === 0) {
    i++;
  }
  return iterator(() => {
    for (; ; ) {
      if (++i < leaf.keys.length) {
        return { done: false, value: leaf.keys[i] };
      }
      let level = -1;
      for (; ; ) {
        if (++level >= nodeQueue.length) {
          return { done: true, value: void 0 };
        }
        if (++nodeIndex[level] < nodeQueue[level].length) {
          break;
        }
      }
      for (; level > 0; level--) {
        nodeQueue[level - 1] = nodeQueue[level][nodeIndex[level]].children;
        nodeIndex[level - 1] = 0;
      }
      leaf = nodeQueue[0][nodeIndex[0]];
      i = -1;
    }
  });
}
function valuesFromReversed(maxKey, root2, comparator2, highestKey, inclusive) {
  if (highestKey === void 0) {
    highestKey = maxKey;
    if (highestKey === void 0)
      return iterator(() => ({ done: true, value: void 0 }));
  }
  let [nodeQueue, nodeIndex, leaf] = findPath(highestKey, root2, comparator2) || findPath(maxKey, root2, comparator2);
  assert3(!nodeQueue[0] || leaf === nodeQueue[0][nodeIndex[0]]);
  let i = indexOf(highestKey, leaf.keys, 0, comparator2);
  if (inclusive && i < leaf.keys.length && comparator2(leaf.keys[i], highestKey) <= 0) {
    i++;
  }
  return iterator(() => {
    for (; ; ) {
      if (--i >= 0) {
        return { done: false, value: leaf.keys[i] };
      }
      let level;
      for (level = -1; ; ) {
        if (++level >= nodeQueue.length) {
          return { done: true, value: void 0 };
        }
        if (--nodeIndex[level] >= 0) {
          break;
        }
      }
      for (; level > 0; level--) {
        nodeQueue[level - 1] = nodeQueue[level][nodeIndex[level]].children;
        nodeIndex[level - 1] = nodeQueue[level - 1].length - 1;
      }
      leaf = nodeQueue[0][nodeIndex[0]];
      i = leaf.keys.length;
    }
  });
}
function findPath(key2, root2, comparator2) {
  let nextNode = root2;
  const nodeQueue = [];
  const nodeIndex = [];
  if (nextNode.isInternal()) {
    for (let d = 0; nextNode.isInternal(); d++) {
      nodeQueue[d] = nextNode.children;
      nodeIndex[d] = key2 === void 0 ? 0 : indexOf(key2, nextNode.keys, 0, comparator2);
      if (nodeIndex[d] >= nodeQueue[d].length) return;
      nextNode = nodeQueue[d][nodeIndex[d]];
    }
    nodeQueue.reverse();
    nodeIndex.reverse();
  }
  return [nodeQueue, nodeIndex, nextNode];
}
function iterator(next) {
  return {
    next,
    [Symbol.iterator]() {
      return this;
    }
  };
}
function indexOf(key2, keys, failXor, comparator2) {
  let lo = 0;
  let hi = keys.length;
  let mid = hi >> 1;
  while (lo < hi) {
    const c2 = comparator2(keys[mid], key2);
    if (c2 < 0) {
      lo = mid + 1;
    } else if (c2 > 0) {
      hi = mid;
    } else if (c2 === 0) {
      return mid;
    } else {
      if (key2 === key2) {
        return keys.length;
      }
      throw new Error("NaN was used as a key");
    }
    mid = lo + hi >> 1;
  }
  return mid ^ failXor;
}
function comparator(a, b2) {
  return compareUTF8(a[0], b2[0]);
}
function constraintMatchesRow(constraint, row) {
  for (const key2 in constraint) {
    if (!valuesEqual(row[key2], constraint[key2])) {
      return false;
    }
  }
  return true;
}
function constraintMatchesPrimaryKey(constraint, primary) {
  const constraintKeys = Object.keys(constraint);
  if (constraintKeys.length !== primary.length) {
    return false;
  }
  constraintKeys.sort(stringCompare);
  for (let i = 0; i < constraintKeys.length; i++) {
    if (constraintKeys[i][0] !== primary[i]) {
      return false;
    }
  }
  return true;
}
function* generateWithConstraint(it, constraint) {
  for (const node of it) {
    if (constraint && !constraintMatchesRow(constraint, node.row)) {
      break;
    }
    yield node;
  }
}
function* generateWithFilter(it, filter) {
  for (const node of it) {
    if (filter(node.row)) {
      yield node;
    }
  }
}
function* genPush(change, exists2, connections, setOverlay, setSplitEditOverlay) {
  switch (change.type) {
    case "add":
      assert3(
        !exists2(change.row),
        () => `Row already exists ${stringify3(change)}`
      );
      break;
    case "remove":
      assert3(exists2(change.row), () => `Row not found ${stringify3(change)}`);
      break;
    case "edit":
      assert3(exists2(change.oldRow), () => `Row not found ${stringify3(change)}`);
      break;
    default:
      unreachable(change);
  }
  for (const [outputIndex, { output, splitEditKeys, filters }] of connections) {
    if (output) {
      let splitEdit = false;
      if (change.type === "edit" && splitEditKeys) {
        for (const key2 of splitEditKeys) {
          if (!valuesEqual(change.row[key2], change.oldRow[key2])) {
            splitEdit = true;
            break;
          }
        }
      }
      if (splitEdit) {
        assert3(change.type === "edit");
        setSplitEditOverlay({
          outputIndex,
          change: {
            type: "remove",
            row: change.oldRow
          }
        });
        const outputRemove = {
          type: "remove",
          node: {
            row: change.oldRow,
            relationships: {}
          }
        };
        filterPush(outputRemove, output, filters?.predicate);
        yield;
        setSplitEditOverlay(void 0);
        setOverlay({ outputIndex, change });
        const outputAdd = {
          type: "add",
          node: {
            row: change.row,
            relationships: {}
          }
        };
        filterPush(outputAdd, output, filters?.predicate);
        yield;
      } else {
        setOverlay({ outputIndex, change });
        const outputChange = change.type === "edit" ? {
          type: change.type,
          oldNode: {
            row: change.oldRow,
            relationships: {}
          },
          node: {
            row: change.row,
            relationships: {}
          }
        } : {
          type: change.type,
          node: {
            row: change.row,
            relationships: {}
          }
        };
        filterPush(outputChange, output, filters?.predicate);
        yield;
      }
    }
  }
  setOverlay(void 0);
}
function* generateWithStart(nodes, start, compare) {
  if (!start) {
    yield* nodes;
    return;
  }
  let started = false;
  for (const node of nodes) {
    if (!started) {
      if (start.basis === "at") {
        if (compare(node.row, start.row) >= 0) {
          started = true;
        }
      } else if (start.basis === "after") {
        if (compare(node.row, start.row) > 0) {
          started = true;
        }
      }
    }
    if (started) {
      yield node;
    }
  }
}
function* generateWithOverlay(startAt, rows, constraint, overlay, splitEditOverlay, connectionIndex, compare, filterPredicate) {
  let overlayToApply = void 0;
  if (splitEditOverlay && splitEditOverlay.outputIndex === connectionIndex) {
    overlayToApply = splitEditOverlay;
  } else if (overlay && connectionIndex <= overlay.outputIndex) {
    overlayToApply = overlay;
  }
  const overlays = computeOverlays(
    startAt,
    constraint,
    overlayToApply,
    compare,
    filterPredicate
  );
  yield* generateWithOverlayInner(rows, overlays, compare);
}
function computeOverlays(startAt, constraint, overlay, compare, filterPredicate) {
  let overlays = {
    add: void 0,
    remove: void 0
  };
  switch (overlay?.change.type) {
    case "add":
      overlays = {
        add: overlay.change.row,
        remove: void 0
      };
      break;
    case "remove":
      overlays = {
        add: void 0,
        remove: overlay.change.row
      };
      break;
    case "edit":
      overlays = {
        add: overlay.change.row,
        remove: overlay.change.oldRow
      };
      break;
  }
  if (startAt) {
    overlays = overlaysForStartAt(overlays, startAt, compare);
  }
  if (constraint) {
    overlays = overlaysForConstraint(overlays, constraint);
  }
  if (filterPredicate) {
    overlays = overlaysForFilterPredicate(overlays, filterPredicate);
  }
  return overlays;
}
function overlaysForStartAt({ add, remove }, startAt, compare) {
  const undefinedIfBeforeStartAt = /* @__PURE__ */ __name((row) => row === void 0 || compare(row, startAt) < 0 ? void 0 : row, "undefinedIfBeforeStartAt");
  return {
    add: undefinedIfBeforeStartAt(add),
    remove: undefinedIfBeforeStartAt(remove)
  };
}
function overlaysForConstraint({ add, remove }, constraint) {
  const undefinedIfDoesntMatchConstraint = /* @__PURE__ */ __name((row) => row === void 0 || !constraintMatchesRow(constraint, row) ? void 0 : row, "undefinedIfDoesntMatchConstraint");
  return {
    add: undefinedIfDoesntMatchConstraint(add),
    remove: undefinedIfDoesntMatchConstraint(remove)
  };
}
function overlaysForFilterPredicate({ add, remove }, filterPredicate) {
  const undefinedIfDoesntMatchFilter = /* @__PURE__ */ __name((row) => row === void 0 || !filterPredicate(row) ? void 0 : row, "undefinedIfDoesntMatchFilter");
  return {
    add: undefinedIfDoesntMatchFilter(add),
    remove: undefinedIfDoesntMatchFilter(remove)
  };
}
function* generateWithOverlayInner(rowIterator, overlays, compare) {
  let addOverlayYielded = false;
  let removeOverlaySkipped = false;
  for (const row of rowIterator) {
    if (!addOverlayYielded && overlays.add) {
      const cmp2 = compare(overlays.add, row);
      if (cmp2 < 0) {
        addOverlayYielded = true;
        yield { row: overlays.add, relationships: {} };
      }
    }
    if (!removeOverlaySkipped && overlays.remove) {
      const cmp2 = compare(overlays.remove, row);
      if (cmp2 === 0) {
        removeOverlaySkipped = true;
        continue;
      }
    }
    yield { row, relationships: {} };
  }
  if (!addOverlayYielded && overlays.add) {
    yield { row: overlays.add, relationships: {} };
  }
}
function makeBoundComparator(sort) {
  return (a, b2) => {
    for (const entry of sort) {
      const key2 = entry[0];
      const cmp2 = compareBounds(a[key2], b2[key2]);
      if (cmp2 !== 0) {
        return entry[1] === "asc" ? cmp2 : -cmp2;
      }
    }
    return 0;
  };
}
function compareBounds(a, b2) {
  if (a === b2) {
    return 0;
  }
  if (a === minValue) {
    return -1;
  }
  if (b2 === minValue) {
    return 1;
  }
  if (a === maxValue) {
    return 1;
  }
  if (b2 === maxValue) {
    return -1;
  }
  return compareValues(a, b2);
}
function* generateRows(data, scanStart, reverse) {
  yield* data[reverse ? "valuesFromReversed" : "valuesFrom"](
    scanStart
  );
}
function stringify3(change) {
  return JSON.stringify(
    change,
    (_, v2) => typeof v2 === "bigint" ? v2.toString() : v2
  );
}
function toDesiredQueriesKey(clientID, hash22) {
  return DESIRED_QUERIES_KEY_PREFIX + clientID + "/" + hash22;
}
function desiredQueriesPrefixForClient(clientID) {
  return DESIRED_QUERIES_KEY_PREFIX + clientID + "/";
}
function toGotQueriesKey(hash22) {
  return GOT_QUERIES_KEY_PREFIX + hash22;
}
function toPrimaryKeyString(tableName, primaryKey, value) {
  if (primaryKey.length === 1) {
    return ENTITIES_KEY_PREFIX + tableName + "/" + parse4(value[primaryKey[0]], primaryKeyValueSchema);
  }
  const values2 = primaryKey.map((k) => parse4(value[k], primaryKeyValueSchema));
  const str = JSON.stringify(values2);
  const idSegment = h128(str);
  return ENTITIES_KEY_PREFIX + tableName + "/" + idSegment;
}
function sourceNameFromKey(key2) {
  const slash = key2.indexOf("/", ENTITIES_KEY_PREFIX.length);
  return key2.slice(ENTITIES_KEY_PREFIX.length, slash);
}
async function patchBranch(desiredHead, store, fork, readOptions) {
  const diffs = await computeDiffs(
    must(fork.hash),
    desiredHead,
    store,
    readOptions
  );
  if (!diffs) {
    return;
  }
  applyDiffs(diffs, fork);
}
async function computeDiffs(startHash, endHash, store, readOptions) {
  const readFn = /* @__PURE__ */ __name((dagRead) => diff2(
    startHash,
    endHash,
    dagRead,
    {
      shouldComputeDiffs: /* @__PURE__ */ __name(() => true, "shouldComputeDiffs"),
      shouldComputeDiffsForIndex(_name) {
        return false;
      }
    },
    Latest
  ), "readFn");
  let diffs;
  if (readOptions?.openLazySourceRead) {
    diffs = await using(store.read(readOptions.openLazySourceRead), readFn);
  } else if (readOptions?.openLazyRead) {
    diffs = await readFn(readOptions.openLazyRead);
  } else {
    diffs = await withRead(store, readFn);
  }
  return diffs.get("");
}
function applyDiffs(diffs, branch2) {
  for (let i = diffBinarySearch(diffs, ENTITIES_KEY_PREFIX, (diff3) => diff3.key); i < diffs.length; i++) {
    const diff3 = diffs[i];
    const { key: key2 } = diff3;
    if (!key2.startsWith(ENTITIES_KEY_PREFIX)) {
      break;
    }
    const name = sourceNameFromKey(key2);
    const source2 = must(branch2.getSource(name));
    switch (diff3.op) {
      case "del":
        source2.push({
          type: "remove",
          row: diff3.oldValue
        });
        break;
      case "add":
        source2.push({
          type: "add",
          row: diff3.newValue
        });
        break;
      case "change":
        source2.push({
          type: "edit",
          row: diff3.newValue,
          oldRow: diff3.oldValue
        });
        break;
    }
  }
}
function makeCRUDMutate(schema2, repMutate) {
  const { [CRUD_MUTATION_NAME]: zeroCRUD } = repMutate;
  const mutateBatch = /* @__PURE__ */ __name(async (body2) => {
    const ops = [];
    const m = {};
    for (const name of Object.keys(schema2.tables)) {
      m[name] = makeBatchCRUDMutate(name, schema2, ops);
    }
    const rv = await body2(m);
    await zeroCRUD({ ops });
    return rv;
  }, "mutateBatch");
  const mutate = {};
  for (const [name, tableSchema] of Object.entries(schema2.tables)) {
    mutate[name] = makeEntityCRUDMutate(name, tableSchema.primaryKey, zeroCRUD);
  }
  return {
    mutate,
    mutateBatch
  };
}
function makeEntityCRUDMutate(tableName, primaryKey, zeroCRUD) {
  return {
    insert: /* @__PURE__ */ __name((value) => {
      const op = {
        op: "insert",
        tableName,
        primaryKey,
        value
      };
      return zeroCRUD({ ops: [op] });
    }, "insert"),
    upsert: /* @__PURE__ */ __name((value) => {
      const op = {
        op: "upsert",
        tableName,
        primaryKey,
        value
      };
      return zeroCRUD({ ops: [op] });
    }, "upsert"),
    update: /* @__PURE__ */ __name((value) => {
      const op = {
        op: "update",
        tableName,
        primaryKey,
        value
      };
      return zeroCRUD({ ops: [op] });
    }, "update"),
    delete: /* @__PURE__ */ __name((id) => {
      const op = {
        op: "delete",
        tableName,
        primaryKey,
        value: id
      };
      return zeroCRUD({ ops: [op] });
    }, "delete")
  };
}
function makeBatchCRUDMutate(tableName, schema2, ops) {
  const { primaryKey } = schema2.tables[tableName];
  return {
    insert: /* @__PURE__ */ __name((value) => {
      const op = {
        op: "insert",
        tableName,
        primaryKey,
        value
      };
      ops.push(op);
      return promiseVoid;
    }, "insert"),
    upsert: /* @__PURE__ */ __name((value) => {
      const op = {
        op: "upsert",
        tableName,
        primaryKey,
        value
      };
      ops.push(op);
      return promiseVoid;
    }, "upsert"),
    update: /* @__PURE__ */ __name((value) => {
      const op = {
        op: "update",
        tableName,
        primaryKey,
        value
      };
      ops.push(op);
      return promiseVoid;
    }, "update"),
    delete: /* @__PURE__ */ __name((id) => {
      const op = {
        op: "delete",
        tableName,
        primaryKey,
        value: id
      };
      ops.push(op);
      return promiseVoid;
    }, "delete")
  };
}
function makeCRUDMutator(schema2) {
  return /* @__PURE__ */ __name(async function zeroCRUDMutator(tx, crudArg) {
    for (const op of crudArg.ops) {
      switch (op.op) {
        case "insert":
          await insertImpl(tx, op, schema2, void 0);
          break;
        case "upsert":
          await upsertImpl(tx, op, schema2, void 0);
          break;
        case "update":
          await updateImpl(tx, op, schema2, void 0);
          break;
        case "delete":
          await deleteImpl(tx, op, schema2, void 0);
          break;
      }
    }
  }, "zeroCRUDMutator");
}
function defaultOptionalFieldsToNull(schema2, value) {
  let rv = value;
  for (const name in schema2.columns) {
    if (rv[name] === void 0) {
      rv = { ...rv, [name]: null };
    }
  }
  return rv;
}
async function insertImpl(tx, arg, schema2, ivmBranch) {
  const key2 = toPrimaryKeyString(
    arg.tableName,
    schema2.tables[arg.tableName].primaryKey,
    arg.value
  );
  if (!await tx.has(key2)) {
    const val = defaultOptionalFieldsToNull(
      schema2.tables[arg.tableName],
      arg.value
    );
    await tx.set(key2, val);
    if (ivmBranch) {
      must(ivmBranch.getSource(arg.tableName)).push({
        type: "add",
        row: arg.value
      });
    }
  }
}
async function upsertImpl(tx, arg, schema2, ivmBranch) {
  const key2 = toPrimaryKeyString(
    arg.tableName,
    schema2.tables[arg.tableName].primaryKey,
    arg.value
  );
  const val = defaultOptionalFieldsToNull(
    schema2.tables[arg.tableName],
    arg.value
  );
  await tx.set(key2, val);
  if (ivmBranch) {
    must(ivmBranch.getSource(arg.tableName)).push({
      type: "set",
      row: arg.value
    });
  }
}
async function updateImpl(tx, arg, schema2, ivmBranch) {
  const key2 = toPrimaryKeyString(
    arg.tableName,
    schema2.tables[arg.tableName].primaryKey,
    arg.value
  );
  const prev = await tx.get(key2);
  if (prev === void 0) {
    return;
  }
  const update = arg.value;
  const next = { ...prev };
  for (const k in update) {
    if (update[k] !== void 0) {
      next[k] = update[k];
    }
  }
  await tx.set(key2, next);
  if (ivmBranch) {
    must(ivmBranch.getSource(arg.tableName)).push({
      type: "edit",
      oldRow: prev,
      row: next
    });
  }
}
async function deleteImpl(tx, arg, schema2, ivmBranch) {
  const key2 = toPrimaryKeyString(
    arg.tableName,
    schema2.tables[arg.tableName].primaryKey,
    arg.value
  );
  const prev = await tx.get(key2);
  if (prev === void 0) {
    return;
  }
  await tx.del(key2);
  if (ivmBranch) {
    must(ivmBranch.getSource(arg.tableName)).push({
      type: "remove",
      row: prev
    });
  }
}
function makeReplicacheMutator(lc, mutator, schema2, slowMaterializeThreshold) {
  return (repTx, args) => {
    const tx = new TransactionImpl(lc, repTx, schema2, slowMaterializeThreshold);
    return mutator(tx, args);
  };
}
function makeSchemaCRUD(schema2, tx, ivmBranch) {
  return new Proxy(
    {},
    {
      get(target, prop) {
        if (prop in target) {
          return target[prop];
        }
        target[prop] = makeTableCRUD(schema2, prop, tx, ivmBranch);
        return target[prop];
      }
    }
  );
}
function makeSchemaQuery(lc, schema2, ivmBranch, slowMaterializeThreshold) {
  const context3 = new ZeroContext(
    lc,
    ivmBranch,
    () => () => {
    },
    () => {
    },
    (applyViewUpdates) => applyViewUpdates(),
    slowMaterializeThreshold
  );
  return new Proxy(
    {},
    {
      get(target, prop) {
        if (prop in target) {
          return target[prop];
        }
        target[prop] = newQuery(context3, schema2, prop);
        return target[prop];
      }
    }
  );
}
function makeTableCRUD(schema2, tableName, tx, ivmBranch) {
  const table22 = must(schema2.tables[tableName]);
  const { primaryKey } = table22;
  return {
    insert: /* @__PURE__ */ __name((value) => insertImpl(
      tx,
      { op: "insert", tableName, primaryKey, value },
      schema2,
      ivmBranch
    ), "insert"),
    upsert: /* @__PURE__ */ __name((value) => upsertImpl(
      tx,
      { op: "upsert", tableName, primaryKey, value },
      schema2,
      ivmBranch
    ), "upsert"),
    update: /* @__PURE__ */ __name((value) => updateImpl(
      tx,
      { op: "update", tableName, primaryKey, value },
      schema2,
      ivmBranch
    ), "update"),
    delete: /* @__PURE__ */ __name((id) => deleteImpl(
      tx,
      { op: "delete", tableName, primaryKey, value: id },
      schema2,
      ivmBranch
    ), "delete")
  };
}
function shouldEnableAnalytics(server2, enableAnalytics = true) {
  if (!enableAnalytics) {
    return false;
  }
  const serverURL = server2 === null ? null : new URL(server2);
  const socketHostname = serverURL?.hostname;
  return server2 !== null && socketHostname !== void 0 && socketHostname !== "localhost" && !IP_ADDRESS_HOSTNAME_REGEX.test(socketHostname);
}
function toWSString(url) {
  return "ws" + url.slice(4);
}
function appendPath(url, toAppend) {
  return url + (url.endsWith("/") ? toAppend.substring(1) : toAppend);
}
function flattenMessage(message) {
  if (Array.isArray(message) && message.length === 1) {
    return flattenMessage(message[0]);
  }
  return message;
}
function convertError(e3) {
  return {
    name: e3.name,
    message: e3.message,
    stack: e3.stack
  };
}
function convertErrors(message) {
  if (message instanceof Error) {
    return convertError(message);
  }
  if (message instanceof Array) {
    const convertedMessage = [];
    for (const item of message) {
      if (item instanceof Error) {
        convertedMessage.push(convertError(item));
      } else {
        convertedMessage.push(item);
      }
    }
    return convertedMessage;
  }
  return message;
}
function makeMessage(message, context3, logLevel) {
  let safeContext = void 0;
  if (context3 !== void 0) {
    for (const reservedKey of RESERVED_KEYS) {
      if (Object.hasOwn(context3, reservedKey)) {
        if (safeContext === void 0) {
          safeContext = { ...context3 };
        }
        safeContext[RESERVED_KEY_PREFIX + reservedKey] = safeContext[reservedKey];
        delete safeContext[reservedKey];
      }
    }
  }
  const msg = {
    ...safeContext ?? context3,
    date: Date.now(),
    message: convertErrors(flattenMessage(message)),
    status: logLevel
  };
  if (logLevel === "error") {
    msg.error = { origin: "logger" };
  }
  return msg;
}
function createLogOptions(options2, createDatadogLogSink = (options22) => new DatadogLogSink(options22)) {
  const { consoleLogLevel, server: server2, enableAnalytics } = options2;
  if (!enableAnalytics || server2 === null) {
    return {
      logLevel: consoleLogLevel,
      logSink: consoleLogSink
    };
  }
  const serverURL = new URL(server2);
  const { hostname } = serverURL;
  const datadogServiceLabel = hostname.endsWith(ZERO_SASS_DOMAIN) ? hostname.substring(0, hostname.length - ZERO_SASS_DOMAIN.length).toLowerCase() : hostname;
  const baseURL = new URL(appendPath(server2, "/logs/v0/log"));
  const logLevel = consoleLogLevel === "debug" ? "debug" : "info";
  const logSink = new TeeLogSink([
    new LevelFilterLogSink(consoleLogSink, consoleLogLevel),
    new LevelFilterLogSink(
      createDatadogLogSink({
        service: datadogServiceLabel,
        host: location.host,
        version: version22,
        baseURL
      }),
      DATADOG_LOG_LEVEL
    )
  ]);
  return {
    logLevel,
    logSink
  };
}
function getLastConnectErrorValue(reason) {
  if ("server" in reason) {
    return `server_${camelToSnake(reason.server)}`;
  }
  return `client_${camelToSnake(reason.client)}`;
}
function camelToSnake(s3) {
  return s3.split(/\.?(?=[A-Z])/).join("_").toLowerCase();
}
function makePoint(ts, value) {
  return [ts, [value]];
}
function t() {
  return Math.round(Date.now() / 1e3);
}
function reloadWithReason(lc, reload2, reason) {
  if (reloadTimer) {
    lc.warn?.("reload timer already scheduled");
    return;
  }
  const now = Date.now();
  const backoff2 = nextBackoff(lc, now);
  if (typeof sessionStorage !== "undefined") {
    sessionStorage.setItem(RELOAD_BACKOFF_STATE_KEY, JSON.stringify(backoff2));
    sessionStorage.setItem(RELOAD_REASON_STORAGE_KEY, reason);
  }
  const delay = backoff2.lastReloadTime - now;
  lc.error?.(
    reason,
    "\n",
    "reloading",
    delay > 0 ? `in ${delay / 1e3} seconds` : ""
  );
  reloadTimer = setTimeout(() => {
    reloadTimer = null;
    reload2();
  }, delay);
}
function reportReloadReason(lc) {
  if (typeof sessionStorage !== "undefined") {
    const reason = sessionStorage.getItem(RELOAD_REASON_STORAGE_KEY);
    if (reason) {
      sessionStorage.removeItem(RELOAD_REASON_STORAGE_KEY);
      lc.error?.("Zero reloaded the page.", reason);
    }
  }
}
function reloadScheduled() {
  return reloadTimer !== null;
}
function resetBackoff() {
  if (typeof sessionStorage !== "undefined") {
    sessionStorage.removeItem(RELOAD_BACKOFF_STATE_KEY);
  }
}
function nextBackoff(lc, now) {
  if (typeof sessionStorage === "undefined") {
    lc.warn?.(
      `sessionStorage not supported. backing off in ${FALLBACK_RELOAD_INTERVAL_MS / 1e3} seconds`
    );
    return {
      lastReloadTime: now + FALLBACK_RELOAD_INTERVAL_MS,
      nextIntervalMs: MIN_RELOAD_INTERVAL_MS
    };
  }
  const val = sessionStorage.getItem(RELOAD_BACKOFF_STATE_KEY);
  if (!val) {
    return { lastReloadTime: now, nextIntervalMs: MIN_RELOAD_INTERVAL_MS };
  }
  let parsed;
  try {
    parsed = parse4(JSON.parse(val), backoffStateSchema, "passthrough");
  } catch (e3) {
    lc.warn?.("ignoring unparsable backoff state", val, e3);
    return { lastReloadTime: now, nextIntervalMs: MIN_RELOAD_INTERVAL_MS };
  }
  const { lastReloadTime, nextIntervalMs } = parsed;
  if (now - lastReloadTime > MAX_RELOAD_INTERVAL_MS * 2) {
    return { lastReloadTime: now, nextIntervalMs: MIN_RELOAD_INTERVAL_MS };
  }
  if (now < lastReloadTime) {
    return parsed;
  }
  const nextReloadTime = Math.max(now, lastReloadTime + nextIntervalMs);
  return {
    lastReloadTime: nextReloadTime,
    nextIntervalMs: Math.min(nextIntervalMs * 2, MAX_RELOAD_INTERVAL_MS)
  };
}
function isServerError(ex) {
  return ex instanceof ServerError;
}
function isAuthError(ex) {
  return isServerError(ex) && isAuthErrorKind(ex.kind);
}
function isAuthErrorKind(kind) {
  return kind === AuthInvalidated || kind === Unauthorized;
}
function isBackoffError(ex) {
  if (isServerError(ex)) {
    switch (ex.errorBody.kind) {
      case Rebalance:
      case Rehome:
      case ServerOverloaded:
        return ex.errorBody;
    }
  }
  return void 0;
}
function validateServerParam(paramName, server2) {
  const expectedProtocol = "http";
  const forExample = /* @__PURE__ */ __name((path2 = "") => ` For example: "${expectedProtocol}s://myapp-myteam.zero.ms/${path2}".`, "forExample");
  if (!server2.startsWith(`${expectedProtocol}://`) && !server2.startsWith(`${expectedProtocol}s://`)) {
    throw new Error(
      `ZeroOptions.${paramName} must use the "${expectedProtocol}" or "${expectedProtocol}s" scheme.`
    );
  }
  let url;
  try {
    url = new URL(server2);
  } catch {
    throw new Error(
      `ZeroOptions.${paramName} must be a valid URL.${forExample()}`
    );
  }
  const urlString = url.toString();
  const pathComponents = url.pathname.split("/");
  if (pathComponents[0] === "") {
    pathComponents.shift();
  }
  if (pathComponents[pathComponents.length - 1] === "") {
    pathComponents.pop();
  }
  if (pathComponents.length > 1) {
    throw new Error(
      `ZeroOptions.${paramName} may have at most one path component.${forExample(
        "zero"
      )}`
    );
  }
  for (const [property, invalidEndsWith] of [
    ["search", "?"],
    ["hash", "#"]
  ]) {
    if (url[property] || urlString.endsWith(invalidEndsWith)) {
      throw new Error(
        `ZeroOptions.${paramName} must not contain a ${property} component.${forExample()}`
      );
    }
  }
  return urlString;
}
function getServer(server2) {
  const WS = getBrowserGlobal("WebSocket");
  if (!WS) {
    console.warn(
      "Zero started in an unsupported environment, no data will be synced."
    );
    return null;
  }
  if (server2 === void 0 || server2 === null) {
    console.warn(
      "Zero starting up with no server URL. This is supported for unit testing and prototyping, but no data will be synced."
    );
    return null;
  }
  return validateServerParam("server", server2);
}
function mergePokes(pokeBuffer, schema2, serverToClient2) {
  if (pokeBuffer.length === 0) {
    return void 0;
  }
  const { baseCookie } = pokeBuffer[0].pokeStart;
  const lastPoke = pokeBuffer[pokeBuffer.length - 1];
  const { cookie } = lastPoke.pokeEnd;
  const mergedPatch = [];
  const mergedLastMutationIDChanges = {};
  let prevPokeEnd = void 0;
  for (const pokeAccumulator of pokeBuffer) {
    if (prevPokeEnd && pokeAccumulator.pokeStart.baseCookie && pokeAccumulator.pokeStart.baseCookie > prevPokeEnd.cookie) {
      throw Error(
        `unexpected cookie gap ${JSON.stringify(prevPokeEnd)} ${JSON.stringify(
          pokeAccumulator.pokeStart
        )}`
      );
    }
    prevPokeEnd = pokeAccumulator.pokeEnd;
    for (const pokePart of pokeAccumulator.parts) {
      if (pokePart.lastMutationIDChanges) {
        for (const [clientID, lastMutationID] of Object.entries(
          pokePart.lastMutationIDChanges
        )) {
          mergedLastMutationIDChanges[clientID] = lastMutationID;
        }
      }
      if (pokePart.desiredQueriesPatches) {
        for (const [clientID, queriesPatch] of Object.entries(
          pokePart.desiredQueriesPatches
        )) {
          mergedPatch.push(
            ...queriesPatch.map(
              (op) => queryPatchOpToReplicachePatchOp(
                op,
                (hash22) => toDesiredQueriesKey(clientID, hash22),
                serverToClient2
              )
            )
          );
        }
      }
      if (pokePart.gotQueriesPatch) {
        mergedPatch.push(
          ...pokePart.gotQueriesPatch.map(
            (op) => queryPatchOpToReplicachePatchOp(
              op,
              toGotQueriesKey,
              serverToClient2
            )
          )
        );
      }
      if (pokePart.rowsPatch) {
        mergedPatch.push(
          ...pokePart.rowsPatch.map(
            (p) => rowsPatchOpToReplicachePatchOp(p, schema2, serverToClient2)
          )
        );
      }
    }
  }
  return {
    baseCookie,
    pullResponse: {
      lastMutationIDChanges: mergedLastMutationIDChanges,
      patch: mergedPatch,
      cookie
    }
  };
}
function queryPatchOpToReplicachePatchOp(op, toKey, serverToClient2) {
  switch (op.op) {
    case "clear":
      return op;
    case "del":
      return {
        op: "del",
        key: toKey(op.hash)
      };
    case "put":
    default:
      return {
        op: "put",
        key: toKey(op.hash),
        value: mapAST(op.ast, serverToClient2)
      };
  }
}
function rowsPatchOpToReplicachePatchOp(op, schema2, serverToClient2) {
  if (op.op === "clear") {
    return op;
  }
  const tableName = serverToClient2.tableName(op.tableName, op);
  switch (op.op) {
    case "del":
      return {
        op: "del",
        key: toPrimaryKeyString(
          tableName,
          schema2.tables[tableName].primaryKey,
          serverToClient2.row(op.tableName, op.id)
        )
      };
    case "put":
      return {
        op: "put",
        key: toPrimaryKeyString(
          tableName,
          schema2.tables[tableName].primaryKey,
          serverToClient2.row(op.tableName, op.value)
        ),
        value: serverToClient2.row(op.tableName, op.value)
      };
    case "update":
      return {
        op: "update",
        key: toPrimaryKeyString(
          tableName,
          schema2.tables[tableName].primaryKey,
          serverToClient2.row(op.tableName, op.id)
        ),
        merge: op.merge ? serverToClient2.row(op.tableName, op.merge) : void 0,
        constrain: serverToClient2.columns(op.tableName, op.constrain)
      };
    default:
      throw new Error("to be implemented");
  }
}
function rafFallback(callback) {
  setTimeout(callback, 0);
}
function convertOnUpdateNeededReason(reason) {
  return { type: reason.type };
}
function updateNeededReloadReason(reason, serverErrMsg) {
  const { type } = reason;
  let reasonMsg = "";
  switch (type) {
    case "NewClientGroup":
      reasonMsg = "This client could not sync with a newer client. This is probably due to another tab loading a newer incompatible version of the app's code.";
      break;
    case "VersionNotSupported":
      reasonMsg = "The server no longer supports this client's protocol version.";
      break;
    case "SchemaVersionNotSupported":
      reasonMsg = "Client and server schemas incompatible.";
      break;
    default:
      unreachable(type);
  }
  if (serverErrMsg) {
    reasonMsg += " " + serverErrMsg;
  }
  return reasonMsg;
}
function serverAheadReloadReason(kind) {
  return `Server reported that client is ahead of server (${kind}). This probably happened because the server is in development mode and restarted. Currently when this happens, the dev server loses its state and on reconnect sees the client as ahead. If you see this in other cases, it may be a bug in Zero.`;
}
function onClientStateNotFoundServerReason(serverErrMsg) {
  return `Server could not find state needed to synchronize this client. ${serverErrMsg}`;
}
async function createSocket(rep, queryManager, deleteClientsManager, socketOrigin, baseCookie, clientID, clientGroupID, clientSchema2, userID, auth, lmid, wsid, debugPerf, lc, maxHeaderLength = 1024 * 8, additionalConnectParams) {
  const url = new URL(
    appendPath(socketOrigin, `/sync/v${PROTOCOL_VERSION}/connect`)
  );
  const { searchParams } = url;
  searchParams.set("clientID", clientID);
  searchParams.set("clientGroupID", clientGroupID);
  searchParams.set("userID", userID);
  searchParams.set("baseCookie", baseCookie === null ? "" : String(baseCookie));
  searchParams.set("ts", String(performance.now()));
  searchParams.set("lmid", String(lmid));
  searchParams.set("wsid", wsid);
  if (debugPerf) {
    searchParams.set("debugPerf", true.toString());
  }
  if (additionalConnectParams) {
    for (const k in additionalConnectParams) {
      if (searchParams.has(k)) {
        lc.warn?.(`skipping conflicting parameter ${k}`);
      } else {
        searchParams.set(k, additionalConnectParams[k]);
      }
    }
  }
  lc.info?.("Connecting to", url.toString());
  const WS = mustGetBrowserGlobal("WebSocket");
  const queriesPatchP = rep.query((tx) => queryManager.getQueriesPatch(tx));
  let deletedClients = await deleteClientsManager.getDeletedClients();
  let queriesPatch = await queriesPatchP;
  let secProtocol = encodeSecProtocols(
    [
      "initConnection",
      {
        desiredQueriesPatch: [...queriesPatch.values()],
        deleted: skipEmptyDeletedClients(deletedClients),
        // The clientSchema only needs to be sent for the very first request.
        // Henceforth it is stored with the CVR and verified automatically.
        ...baseCookie === null ? { clientSchema: clientSchema2 } : {}
      }
    ],
    auth
  );
  if (secProtocol.length > maxHeaderLength) {
    secProtocol = encodeSecProtocols(void 0, auth);
    queriesPatch = void 0;
  } else {
    deletedClients = void 0;
  }
  return [
    new WS(
      // toString() required for RN URL polyfill.
      url.toString(),
      secProtocol
    ),
    queriesPatch,
    skipEmptyDeletedClients(deletedClients)
  ];
}
function skipEmptyArray(arr2) {
  return arr2 && arr2.length > 0 ? arr2 : void 0;
}
function skipEmptyDeletedClients(deletedClients) {
  if (!deletedClients) {
    return void 0;
  }
  const { clientIDs, clientGroupIDs } = deletedClients;
  if ((!clientIDs || clientIDs.length === 0) && (!clientGroupIDs || clientGroupIDs.length === 0)) {
    return void 0;
  }
  const data = {};
  data.clientIDs = skipEmptyArray(clientIDs);
  data.clientGroupIDs = skipEmptyArray(clientGroupIDs);
  return data;
}
function addWebSocketIDFromSocketToLogContext({ url }, lc) {
  const wsid = new URL(url).searchParams.get("wsid") ?? nanoid();
  return addWebSocketIDToLogContext(wsid, lc);
}
function addWebSocketIDToLogContext(wsid, lc) {
  return lc.withContext("wsid", wsid);
}
function promiseRace(ps) {
  return Promise.race(ps.map((p, i) => p.then(() => i)));
}
var isProd, defaultPullers, promiseTrue, promiseFalse, promiseUndefined, promiseVoid, promiseNever, deepFrozenObjects, deleteSentinel, WriteImplBase, RELAXED, OBJECT_STORE, IDBStore, ReadImpl, WriteImpl, IDBNotFoundError, AbortError, promiseVoid2, promiseNever2, valita_exports, AbstractType2, STRING_LENGTH, hashRe, emptyUUID, emptyHash, newRandomHash, hashSchema, Chunk, RefCountUpdates, ChunkNotFoundError, StoreImpl, ReadImpl2, WriteImpl2, DELETED_CLIENTS_HEAD_NAME, deletedClientsSchema, legacyDeletedClientsSchema, DD31, V6, V7, Latest, localNavigator, ReadImpl3, WriteImpl3, stores, MemStore, IDBStoreWithMemFallback, DocumentVisibilityWatcherImpl, resolvedPromise, promiseThatNeverResolves, DocumentVisibilityWatcherNoDoc, ConnectionLoopDelegateImpl, PullDelegate, PushDelegate, MIN_DELAY_MS, MAX_DELAY_MS, ConnectionLoop, CONNECTION_MEMORY_COUNT, IterWrapper, SIZE_TAG, SIZE_INT32, SIZE_SMI, SIZE_DOUBLE, entryFixed, LazyStore, LazyRead, LazyWrite, ChunksCache, LocalDD31, SnapshotDD31, DEFAULT_HEAD_NAME, Commit, NODE_LEVEL, NODE_ENTRIES, NodeImpl, DataNodeImpl, InternalNodeImpl, emptyDataNode, emptyDataNodeImpl, SPLICE_UNASSIGNED, SPLICE_AT, SPLICE_REMOVED, SPLICE_ADDED, SPLICE_FROM, KEY, VALUE, NODE_HEADER_SIZE, BTreeRead, Add, Remove, IndexRead, IndexWrite, KEY_VERSION_0, KEY_SEPARATOR, Read, TransactionClosedError, ScanResultImpl, AsyncIterableIteratorToArrayWrapperImpl, transactionIDCounter, ReadTransactionImpl, SubscriptionTransactionWrapper, zeroData, WriteTransactionImpl, BTreeWrite, DiffsMap, Write, defaultPushers, indexDefinitionSchema, indexDefinitionsSchema, clientGroupSchema, CLIENT_GROUPS_HEAD_NAME, Applied, NoOp, CookieMismatch, PullError, SYNC_HEAD_NAME, PULL_VERSION_DD31, path, jsonSchema, jsonObjectSchema, PushError, clientGroupIDSchema, clientIDSchema, PUSH_VERSION_DD31, mutationV1Schema, pushRequestV1Schema, MUTATION_RECOVERY_LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT, NoopBroadcastChannel, bc, clientV5Schema, clientV6Schema, CLIENTS_HEAD_NAME, clientSchema, ClientStateNotFoundError, FIND_MATCHING_CLIENT_TYPE_NEW, FIND_MATCHING_CLIENT_TYPE_FORK, FIND_MATCHING_CLIENT_TYPE_HEAD, CLIENT_MAX_INACTIVE_TIME, GC_INTERVAL, latestGCUpdate, GC_INTERVAL_MS, latestGCUpdate2, HEARTBEAT_INTERVAL, latestHeartbeatUpdate, IDB_DATABASES_VERSION, IDB_DATABASES_DB_NAME, testNamespace, DBS_KEY, PROFILE_ID_KEY, IDBDatabasesStore, Visitor, GatherMemoryOnlyVisitor, GatherNotCachedVisitor, GATHER_SIZE_LIMIT, DELAY_MS, ProcessScheduler, InitialRun, Regular, emptySet, unitializedLastValue, SubscriptionImpl, WatchSubscription, SubscriptionsManagerImpl, sessionID, REQUEST_COUNTERS, version3, MAX_REAUTH_TRIES, PERSIST_IDLE_TIMEOUT_MS, REFRESH_IDLE_TIMEOUT_MS, PERSIST_THROTTLE_MS, REFRESH_THROTTLE_MS, LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT, RECOVER_MUTATIONS_INTERVAL_MS, noop22, updateNeededReasonNewClientGroup, ReplicacheImpl, closingInstances, httpStatusUnauthorized, ReportError, COLLECT_IDB_INTERVAL, INITIAL_COLLECT_IDB_DELAY, h64, h128, valueTypeSchema, columnSchemaSchema, tableSchemaSchema, clientSchemaSchema, keyCmp, TableBuilder, TableBuilderWithColumns, ColumnBuilder2, valueSchema, rowSchema, selectorSchema, toStaticParam, orderingElementSchema, orderingSchema, primitiveSchema, equalityOpsSchema, orderOpsSchema, likeOpsSchema, inOpsSchema, simpleOperatorSchema, literalReferenceSchema, columnReferenceSchema, parameterReferenceSchema, conditionValueSchema, simpleConditionSchema, correlatedSubqueryConditionOperatorSchema, correlatedSubqueryConditionSchema, conditionSchema, conjunctionSchema, disjunctionSchema, compoundKeySchema, correlationSchema, correlatedSubquerySchemaOmitSubquery, correlatedSubquerySchema, astSchema, normalizeCache, NORMALIZE_TRANSFORM, hashCache, throwOutput, Exists, FanIn, FanOut, Filter, Join, Skip, MAX_BOUND_KEY, Take, specialCharsRe, EXISTS_LIMIT, PERMISSIONS_EXISTS_LIMIT, ArrayView, ExpressionBuilder, TRUE, FALSE, negateSimpleOperatorMap, negateOperatorMap, astForTestingSymbol, SUBQ_PREFIX, AbstractQuery, completedAstSymbol, QueryImpl, StaticQuery, NameMapper, ANYONE_CAN, CallTracker, authDataRef, preMutationRowRef, deleteClientsBodySchema, deleteClientsMessageSchema, putOpSchema, delOpSchema, clearOpSchema, patchOpSchema, queriesPatchSchema, connectedBodySchema, connectedMessageSchema, initConnectionBodySchema, initConnectionMessageSchema, AuthInvalidated, ClientNotFound, InvalidConnectionRequest, InvalidConnectionRequestBaseCookie, InvalidConnectionRequestLastMutationID, InvalidConnectionRequestClientDeleted, InvalidMessage, InvalidPush, MutationFailed, MutationRateLimited, Rebalance, Rehome, Unauthorized, VersionNotSupported, SchemaVersionNotSupported, ServerOverloaded, Internal, basicErrorKindSchema, basicErrorBodySchema, backoffErrorKindSchema, backoffBodySchema, errorBodySchema, errorMessageSchema, primaryKeySchema, primaryKeyValueSchema, primaryKeyValueRecordSchema, putOpSchema2, updateOpSchema, delOpSchema2, clearOpSchema2, rowPatchOpSchema, rowsPatchSchema, versionSchema, nullableVersionSchema, pokeStartBodySchema, pokePartBodySchema, pokeEndBodySchema, pokeStartMessageSchema, pokePartMessageSchema, pokeEndMessageSchema, pongBodySchema, pongMessageSchema, pullRequestBodySchema, pullResponseBodySchema, pullRequestMessageSchema, pullResponseMessageSchema, warmBodySchema, warmMessageSchema, downstreamSchema, CRUD, Custom, PROTOCOL_VERSION, MIN_SERVER_SUPPORTED_SYNC_PROTOCOL, MIN_SERVER_SUPPORTED_PERMISSIONS_PROTOCOL, CRUD_MUTATION_NAME, insertOpSchema, upsertOpSchema, updateOpSchema2, deleteOpSchema, crudOpSchema, crudArgSchema, crudArgsSchema, crudMutationSchema, customMutationSchema, mutationSchema, pushBodySchema, pushMessageSchema, mutationIDSchema, appErrorSchema, zeroErrorSchema, mutationOkSchema, mutationErrorSchema, mutationResultSchema, mutationResponseSchema, pushOkSchema, unsupportedPushVersionSchema, unsupportedSchemaVersionSchema, pushErrorSchema, pushResponseSchema, Disconnected, Connecting, Connected, MAX_NODE_SIZE, BTreeSet, BNode, BNodeInternal, emptyLeaf, MemoryStorage, MemorySource, minValue, maxValue, DESIRED_QUERIES_KEY_PREFIX, GOT_QUERIES_KEY_PREFIX, ENTITIES_KEY_PREFIX, IVMSourceBranch, ZeroContext, TransactionImpl, DeleteClientsManager, IPV4_ADDRESS_REGEX, IPV6_ADDRESS_HOSTNAME_REGEX, IP_ADDRESS_HOSTNAME_REGEX, DD_BASE_URL, MAX_LOG_ENTRIES_PER_FLUSH, FORCE_FLUSH_THRESHOLD, MAX_ENTRY_BYTES, MAX_MESSAGE_RETRIES, MAX_ENTRY_CHARS, DatadogLogSink, LOG_SINK_FLUSH_RETRY_COUNT, LOG_SINK_FLUSH_DELAY_ATTRIBUTE, RESERVED_KEY_PREFIX, RESERVED_KEYS, version22, LevelFilterLogSink, DATADOG_LOG_LEVEL, ZERO_SASS_DOMAIN, TimeToConnectMs, LastConnectError, TimeToConnectMsV2, LastConnectErrorV2, TotalTimeToConnectMs, NotConnected, DID_NOT_CONNECT_VALUE, REPORT_INTERVAL_MS, MetricManager, Gauge, State, TimedOut, Success, QueryManager, RELOAD_REASON_STORAGE_KEY, RELOAD_BACKOFF_STATE_KEY, backoffStateSchema, MIN_RELOAD_INTERVAL_MS, MAX_RELOAD_INTERVAL_MS, FALLBACK_RELOAD_INTERVAL_MS, reloadTimer, ServerError, PokeHandler, ZeroRep, onSetConnectionStateSymbol, exposedToTestingSymbol, createLogOptionsSymbol, RUN_LOOP_INTERVAL_MS, PING_INTERVAL_MS, PING_TIMEOUT_MS, PULL_TIMEOUT_MS, DEFAULT_DISCONNECT_HIDDEN_DELAY_MS, CONNECT_TIMEOUT_MS, CHECK_CONNECTIVITY_ON_ERROR_FREQUENCY, NULL_LAST_MUTATION_ID_SENT, ON_CLIENT_STATE_NOT_FOUND_REASON_CLIENT, CLOSE_CODE_NORMAL, Zero, TimedOutError, CloseError;
var init_chunk_6KJRALZP = __esm({
  "node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-6KJRALZP.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_chunk_5X3DESC6();
    init_chunk_MJCITZ5S();
    init_chunk_424PT5DM();
    init_resolver();
    init_resolver();
    init_mjs();
    init_mjs();
    init_logger2();
    init_lock();
    init_lock();
    init_logger2();
    init_resolver();
    init_resolver();
    init_resolver();
    init_lock();
    init_src2();
    init_src2();
    init_src2();
    init_lock();
    init_mjs();
    init_resolver();
    init_src2();
    init_js_xxhash();
    init_src2();
    init_resolver();
    init_logger2();
    init_resolver();
    init_src2();
    init_logger2();
    init_lock();
    init_logger2();
    init_lock();
    __name(callDefaultFetch, "callDefaultFetch");
    isProd = false;
    __name(deepEqual, "deepEqual");
    __name(assertJSONValue, "assertJSONValue");
    __name(assertJSONObject, "assertJSONObject");
    __name(assertObjectIsJSONObject, "assertObjectIsJSONObject");
    __name(assertJSONArray, "assertJSONArray");
    __name(isJSONValue, "isJSONValue");
    __name(isJSONObject, "isJSONObject");
    __name(objectIsJSONObject, "objectIsJSONObject");
    __name(isJSONArray, "isJSONArray");
    __name(stringCompare, "stringCompare");
    __name(compareCookies, "compareCookies");
    __name(getCompareValue, "getCompareValue");
    __name(assertCookie, "assertCookie");
    __name(isError2, "isError");
    __name(isErrorResponse, "isErrorResponse");
    __name(isClientStateNotFoundResponse, "isClientStateNotFoundResponse");
    __name(isVersionNotSupportedResponse, "isVersionNotSupportedResponse");
    __name(assertVersionNotSupportedResponse, "assertVersionNotSupportedResponse");
    __name(assertHTTPRequestInfo, "assertHTTPRequestInfo");
    __name(assertPatchOperations, "assertPatchOperations");
    __name(assertPatchOperation, "assertPatchOperation");
    __name(getDefaultPuller, "getDefaultPuller");
    defaultPullers = /* @__PURE__ */ new WeakSet();
    __name(isDefaultPuller, "isDefaultPuller");
    __name(assertPullResponseV1, "assertPullResponseV1");
    __name(assertLastMutationIDChanges, "assertLastMutationIDChanges");
    __name(assertPullerResultV1, "assertPullerResultV1");
    __name(getBrowserGlobal, "getBrowserGlobal");
    __name(getBrowserGlobalMethod, "getBrowserGlobalMethod");
    __name(mustGetBrowserGlobal, "mustGetBrowserGlobal");
    promiseTrue = Promise.resolve(true);
    promiseFalse = Promise.resolve(false);
    promiseUndefined = Promise.resolve(void 0);
    promiseVoid = Promise.resolve();
    promiseNever = new Promise(() => {
    });
    deepFrozenObjects = /* @__PURE__ */ new WeakSet();
    __name(deepFreeze, "deepFreeze");
    __name(deepFreezeInternal, "deepFreezeInternal");
    __name(deepFreezeArray, "deepFreezeArray");
    __name(deepFreezeObject, "deepFreezeObject");
    __name(assertDeepFrozen, "assertDeepFrozen");
    __name(isDeepFrozen, "isDeepFrozen");
    __name(deepFreezeAllowUndefined, "deepFreezeAllowUndefined");
    deleteSentinel = Symbol();
    WriteImplBase = class {
      static {
        __name(this, "WriteImplBase");
      }
      _pending = /* @__PURE__ */ new Map();
      #read;
      constructor(read) {
        this.#read = read;
      }
      has(key2) {
        switch (this._pending.get(key2)) {
          case void 0:
            return this.#read.has(key2);
          case deleteSentinel:
            return promiseFalse;
          default:
            return promiseTrue;
        }
      }
      async get(key2) {
        const v2 = this._pending.get(key2);
        switch (v2) {
          case deleteSentinel:
            return void 0;
          case void 0: {
            const v3 = await this.#read.get(key2);
            return deepFreezeAllowUndefined(v3);
          }
          default:
            return v2;
        }
      }
      put(key2, value) {
        this._pending.set(key2, deepFreeze(value));
        return promiseVoid;
      }
      del(key2) {
        this._pending.set(key2, deleteSentinel);
        return promiseVoid;
      }
      release() {
        this.#read.release();
      }
      get closed() {
        return this.#read.closed;
      }
    };
    RELAXED = { durability: "relaxed" };
    OBJECT_STORE = "chunks";
    IDBStore = class {
      static {
        __name(this, "IDBStore");
      }
      #db;
      #closed = false;
      #idbDeleted = false;
      constructor(name) {
        this.#db = openDatabase(name);
      }
      read() {
        return this.#withReopen(readImpl);
      }
      write() {
        return this.#withReopen(writeImpl);
      }
      async close() {
        if (!this.#idbDeleted) {
          const db2 = await this.#db;
          db2.close();
        }
        this.#closed = true;
      }
      get closed() {
        return this.#closed;
      }
      async #withReopen(fn) {
        const reopenExistingDB = /* @__PURE__ */ __name(async (name) => {
          const { promise, resolve: resolve2, reject } = resolver();
          const req = indexedDB.open(name);
          req.onupgradeneeded = () => {
            const tx = req.transaction;
            assertNotNull(tx);
            tx.abort();
            this.#idbDeleted = true;
            reject(new IDBNotFoundError(`Replicache IndexedDB not found: ${name}`));
          };
          req.onsuccess = () => resolve2(req.result);
          req.onerror = () => reject(req.error);
          const db22 = await promise;
          db22.onversionchange = () => db22.close();
          return db22;
        }, "reopenExistingDB");
        const db2 = await this.#db;
        try {
          return fn(db2);
        } catch (e3) {
          if (!this.#closed && e3 instanceof DOMException) {
            if (e3.name === "InvalidStateError") {
              this.#db = reopenExistingDB(db2.name);
              const reopened = await this.#db;
              return fn(reopened);
            } else if (e3.name === "NotFoundError") {
              this.#idbDeleted = true;
              mustGetBrowserGlobal("indexedDB").deleteDatabase(db2.name);
              throw new IDBNotFoundError(
                `Replicache IndexedDB ${db2.name} missing object store. Deleting db.`
              );
            }
          }
          throw e3;
        }
      }
    };
    ReadImpl = class {
      static {
        __name(this, "ReadImpl");
      }
      #tx;
      #closed = false;
      constructor(tx) {
        this.#tx = tx;
      }
      has(key2) {
        return new Promise((resolve2, reject) => {
          const req = objectStore(this.#tx).count(key2);
          req.onsuccess = () => resolve2(req.result > 0);
          req.onerror = () => reject(req.error);
        });
      }
      get(key2) {
        return new Promise((resolve2, reject) => {
          const req = objectStore(this.#tx).get(key2);
          req.onsuccess = () => resolve2(deepFreezeAllowUndefined(req.result));
          req.onerror = () => reject(req.error);
        });
      }
      release() {
        this.#closed = true;
      }
      get closed() {
        return this.#closed;
      }
    };
    WriteImpl = class extends WriteImplBase {
      static {
        __name(this, "WriteImpl");
      }
      #tx;
      #closed = false;
      constructor(tx) {
        super(new ReadImpl(tx));
        this.#tx = tx;
      }
      commit() {
        if (this._pending.size === 0) {
          return promiseVoid;
        }
        return new Promise((resolve2, reject) => {
          const tx = this.#tx;
          const store = objectStore(tx);
          for (const [key2, val] of this._pending) {
            if (val === deleteSentinel) {
              store.delete(key2);
            } else {
              store.put(val, key2);
            }
          }
          tx.oncomplete = () => resolve2();
          tx.onerror = () => reject(tx.error);
        });
      }
      release() {
        this.#closed = true;
      }
      get closed() {
        return this.#closed;
      }
    };
    __name(writeImpl, "writeImpl");
    __name(readImpl, "readImpl");
    __name(objectStore, "objectStore");
    __name(openDatabase, "openDatabase");
    IDBNotFoundError = class extends Error {
      static {
        __name(this, "IDBNotFoundError");
      }
      name = "IDBNotFoundError";
    };
    AbortError = class extends Error {
      static {
        __name(this, "AbortError");
      }
      name = "AbortError";
    };
    promiseVoid2 = Promise.resolve();
    promiseNever2 = new Promise(() => void 0);
    __name(sleep, "sleep");
    __name(sleepWithAbort, "sleepWithAbort");
    __name(initBgIntervalProcess, "initBgIntervalProcess");
    __name(runBgIntervalProcess, "runBgIntervalProcess");
    __name(randomUint64, "randomUint64");
    valita_exports = {};
    __export2(valita_exports, {
      assert: /* @__PURE__ */ __name(() => assert22, "assert"),
      deepPartial: /* @__PURE__ */ __name(() => deepPartial, "deepPartial"),
      instanceOfAbstractType: /* @__PURE__ */ __name(() => instanceOfAbstractType, "instanceOfAbstractType"),
      is: /* @__PURE__ */ __name(() => is2, "is"),
      parse: /* @__PURE__ */ __name(() => parse4, "parse"),
      readonly: /* @__PURE__ */ __name(() => readonly, "readonly"),
      readonlyArray: /* @__PURE__ */ __name(() => readonlyArray, "readonlyArray"),
      readonlyObject: /* @__PURE__ */ __name(() => readonlyObject, "readonlyObject"),
      readonlyRecord: /* @__PURE__ */ __name(() => readonlyRecord, "readonlyRecord"),
      test: /* @__PURE__ */ __name(() => test, "test"),
      testOptional: /* @__PURE__ */ __name(() => testOptional, "testOptional")
    });
    __reExport(valita_exports, mjs_exports);
    __name(toDisplay, "toDisplay");
    __name(toDisplayAtPath, "toDisplayAtPath");
    __name(displayList, "displayList");
    __name(getMessage, "getMessage");
    __name(getDeepestUnionParseError, "getDeepestUnionParseError");
    __name(pathCmp, "pathCmp");
    __name(parse4, "parse");
    __name(is2, "is");
    __name(assert22, "assert2");
    __name(test, "test");
    __name(testOptional, "testOptional");
    __name(readonly, "readonly");
    __name(readonlyObject, "readonlyObject");
    __name(readonlyArray, "readonlyArray");
    __name(readonlyRecord, "readonlyRecord");
    AbstractType2 = Object.getPrototypeOf(
      Object.getPrototypeOf(string().optional())
    ).constructor;
    __name(instanceOfAbstractType, "instanceOfAbstractType");
    __name(deepPartial, "deepPartial");
    STRING_LENGTH = 22;
    hashRe = /^[0-9a-v-]+$/;
    emptyUUID = "0".repeat(STRING_LENGTH);
    emptyHash = emptyUUID;
    newRandomHash = makeNewRandomHashFunctionInternal();
    __name(toStringAndSlice, "toStringAndSlice");
    __name(makeNewRandomHashFunctionInternal, "makeNewRandomHashFunctionInternal");
    __name(isHash, "isHash");
    __name(assertHash, "assertHash");
    hashSchema = valita_exports.string().assert(isHash, "Invalid hash");
    __name(asRefs, "asRefs");
    __name(toRefs, "toRefs");
    Chunk = class {
      static {
        __name(this, "Chunk");
      }
      hash;
      data;
      /**
       * Meta is an array of refs. If there are no refs we do not write a meta
       * chunk.
       */
      meta;
      constructor(hash22, data, refs) {
        assert3(
          !refs.includes(hash22),
          "Chunk cannot reference itself"
        );
        assertDeepFrozen(data);
        this.hash = hash22;
        this.data = data;
        this.meta = refs;
      }
    };
    __name(assertRefs, "assertRefs");
    __name(createChunk, "createChunk");
    __name(computeRefCountUpdates, "computeRefCountUpdates");
    RefCountUpdates = class {
      static {
        __name(this, "RefCountUpdates");
      }
      #newHeads;
      #oldHeads;
      #putChunks;
      #delegate;
      #refsCounted;
      #refCountUpdates;
      #loadedRefCountPromises;
      #isLazyDelegate;
      constructor(headChanges, putChunks, delegate) {
        const newHeads = [];
        const oldHeads = [];
        for (const changedHead of headChanges) {
          if (changedHead.old !== changedHead.new) {
            changedHead.old && oldHeads.push(changedHead.old);
            changedHead.new && newHeads.push(changedHead.new);
          }
        }
        this.#newHeads = newHeads;
        this.#oldHeads = oldHeads;
        this.#putChunks = putChunks;
        this.#delegate = delegate;
        this.#refCountUpdates = /* @__PURE__ */ new Map();
        this.#loadedRefCountPromises = /* @__PURE__ */ new Map();
        this.#isLazyDelegate = delegate.areRefsCounted !== void 0;
        this.#refsCounted = this.#isLazyDelegate ? /* @__PURE__ */ new Set() : null;
      }
      async compute() {
        for (const n2 of this.#newHeads) {
          await this.#changeRefCount(n2, 1);
        }
        await Promise.all(
          Array.from(
            this.#putChunks.values(),
            (hash22) => this.#ensureRefCountLoaded(hash22)
          )
        );
        if (this.#isLazyDelegate) {
          assert3(this.#delegate.areRefsCounted);
          assert3(this.#refsCounted);
          let refCountsUpdated;
          do {
            refCountsUpdated = false;
            for (const hash22 of this.#putChunks.values()) {
              if (!this.#delegate.areRefsCounted(hash22) && !this.#refsCounted.has(hash22) && this.#refCountUpdates.get(hash22) !== 0) {
                await this.#updateRefsCounts(hash22, 1);
                refCountsUpdated = true;
                break;
              }
            }
          } while (refCountsUpdated);
        }
        for (const o2 of this.#oldHeads) {
          await this.#changeRefCount(o2, -1);
        }
        if (!isProd) {
          for (const [hash22, update] of this.#refCountUpdates) {
            assert3(
              update >= 0,
              `ref count update must be non-negative. ${hash22}:${update}`
            );
          }
        }
        return this.#refCountUpdates;
      }
      async #changeRefCount(hash22, delta) {
        await this.#ensureRefCountLoaded(hash22);
        if (this.#updateRefCount(hash22, delta)) {
          await this.#updateRefsCounts(hash22, delta);
        }
      }
      async #updateRefsCounts(hash22, delta) {
        if (hash22 === emptyHash) {
          return;
        }
        const refs = await this.#delegate.getRefs(hash22);
        if (!isProd) {
          assert3(
            refs || this.#isLazyDelegate && !this.#putChunks.has(hash22),
            "refs must be defined"
          );
        }
        if (refs !== void 0) {
          this.#refsCounted?.add(hash22);
          const ps = refs.map((ref) => this.#changeRefCount(ref, delta));
          await Promise.all(ps);
        }
      }
      #ensureRefCountLoaded(hash22) {
        let p = this.#loadedRefCountPromises.get(hash22);
        if (p === void 0) {
          p = (async () => {
            const value = await this.#delegate.getRefCount(hash22) || 0;
            this.#refCountUpdates.set(hash22, value);
            return value;
          })();
          this.#loadedRefCountPromises.set(hash22, p);
        }
        return p;
      }
      #updateRefCount(hash22, delta) {
        const oldCount = this.#refCountUpdates.get(hash22);
        assertNumber(oldCount);
        this.#refCountUpdates.set(hash22, oldCount + delta);
        return oldCount === 0 && delta === 1 || oldCount === 1 && delta === -1;
      }
    };
    __name(chunkDataKey, "chunkDataKey");
    __name(chunkMetaKey, "chunkMetaKey");
    __name(chunkRefCountKey, "chunkRefCountKey");
    __name(headKey, "headKey");
    ChunkNotFoundError = class extends Error {
      static {
        __name(this, "ChunkNotFoundError");
      }
      name = "ChunkNotFoundError";
      hash;
      constructor(hash22) {
        super(`Chunk not found ${hash22}`);
        this.hash = hash22;
      }
    };
    __name(mustGetChunk, "mustGetChunk");
    __name(mustGetHeadHash, "mustGetHeadHash");
    StoreImpl = class {
      static {
        __name(this, "StoreImpl");
      }
      #kv;
      #chunkHasher;
      #assertValidHash;
      constructor(kv, chunkHasher, assertValidHash) {
        this.#kv = kv;
        this.#chunkHasher = chunkHasher;
        this.#assertValidHash = assertValidHash;
      }
      async read() {
        return new ReadImpl2(await this.#kv.read(), this.#assertValidHash);
      }
      async write() {
        return new WriteImpl2(
          await this.#kv.write(),
          this.#chunkHasher,
          this.#assertValidHash
        );
      }
      close() {
        return this.#kv.close();
      }
    };
    ReadImpl2 = class {
      static {
        __name(this, "ReadImpl2");
      }
      _tx;
      assertValidHash;
      constructor(kv, assertValidHash) {
        this._tx = kv;
        this.assertValidHash = assertValidHash;
      }
      hasChunk(hash22) {
        return this._tx.has(chunkDataKey(hash22));
      }
      async getChunk(hash22) {
        const data = await this._tx.get(chunkDataKey(hash22));
        if (data === void 0) {
          return void 0;
        }
        const refsVal = await this._tx.get(chunkMetaKey(hash22));
        let refs;
        if (refsVal !== void 0) {
          assertRefs(refsVal);
          refs = refsVal;
        } else {
          refs = [];
        }
        return new Chunk(hash22, data, refs);
      }
      mustGetChunk(hash22) {
        return mustGetChunk(this, hash22);
      }
      async getHead(name) {
        const data = await this._tx.get(headKey(name));
        if (data === void 0) {
          return void 0;
        }
        assertHash(data);
        return data;
      }
      release() {
        this._tx.release();
      }
      get closed() {
        return this._tx.closed;
      }
    };
    WriteImpl2 = class extends ReadImpl2 {
      static {
        __name(this, "WriteImpl2");
      }
      #chunkHasher;
      #putChunks = /* @__PURE__ */ new Set();
      #changedHeads = /* @__PURE__ */ new Map();
      constructor(kvw, chunkHasher, assertValidHash) {
        super(kvw, assertValidHash);
        this.#chunkHasher = chunkHasher;
      }
      createChunk = /* @__PURE__ */ __name((data, refs) => createChunk(data, refs, this.#chunkHasher), "createChunk");
      get kvWrite() {
        return this._tx;
      }
      async putChunk(c2) {
        const { hash: hash22, data, meta } = c2;
        this.assertValidHash(hash22);
        const key2 = chunkDataKey(hash22);
        const p1 = this._tx.put(key2, data);
        let p2;
        if (meta.length > 0) {
          for (const h of meta) {
            this.assertValidHash(h);
          }
          p2 = this._tx.put(chunkMetaKey(hash22), meta);
        }
        this.#putChunks.add(hash22);
        await p1;
        await p2;
      }
      setHead(name, hash22) {
        return this.#setHead(name, hash22);
      }
      removeHead(name) {
        return this.#setHead(name, void 0);
      }
      async #setHead(name, hash22) {
        const oldHash = await this.getHead(name);
        const hk = headKey(name);
        let p1;
        if (hash22 === void 0) {
          p1 = this._tx.del(hk);
        } else {
          p1 = this._tx.put(hk, hash22);
        }
        const v2 = this.#changedHeads.get(name);
        if (v2 === void 0) {
          this.#changedHeads.set(name, { new: hash22, old: oldHash });
        } else {
          v2.new = hash22;
        }
        await p1;
      }
      async commit() {
        const refCountUpdates = await computeRefCountUpdates(
          this.#changedHeads.values(),
          this.#putChunks,
          this
        );
        await this.#applyRefCountUpdates(refCountUpdates);
        await this._tx.commit();
      }
      async getRefCount(hash22) {
        const value = await this._tx.get(chunkRefCountKey(hash22));
        if (value === void 0) {
          return void 0;
        }
        assertNumber(value);
        if (value < 0 || value > 65535 || value !== (value | 0)) {
          throw new Error(
            `Invalid ref count ${value}. We expect the value to be a Uint16`
          );
        }
        return value;
      }
      async getRefs(hash22) {
        const meta = await this._tx.get(chunkMetaKey(hash22));
        if (meta === void 0) {
          return [];
        }
        assertRefs(meta);
        return meta;
      }
      async #applyRefCountUpdates(refCountCache) {
        const ps = [];
        for (const [hash22, count3] of refCountCache) {
          if (count3 === 0) {
            ps.push(this.#removeAllRelatedKeys(hash22));
          } else {
            const refCountKey = chunkRefCountKey(hash22);
            ps.push(this._tx.put(refCountKey, count3));
          }
        }
        await Promise.all(ps);
      }
      async #removeAllRelatedKeys(hash22) {
        await Promise.all([
          this._tx.del(chunkDataKey(hash22)),
          this._tx.del(chunkMetaKey(hash22)),
          this._tx.del(chunkRefCountKey(hash22))
        ]);
        this.#putChunks.delete(hash22);
      }
      release() {
        this._tx.release();
      }
    };
    DELETED_CLIENTS_HEAD_NAME = "deleted-clients";
    deletedClientsSchema = readonlyObject({
      clientIDs: readonlyArray(valita_exports.string()),
      clientGroupIDs: readonlyArray(valita_exports.string())
    });
    legacyDeletedClientsSchema = readonlyArray(valita_exports.string());
    __name(setDeletedClients, "setDeletedClients");
    __name(getDeletedClients, "getDeletedClients");
    __name(addDeletedClients, "addDeletedClients");
    __name(removeDeletedClients, "removeDeletedClients");
    __name(normalize, "normalize");
    DD31 = 5;
    V6 = 6;
    V7 = 7;
    Latest = V7;
    __name(createLogContext, "createLogContext");
    localNavigator = typeof navigator !== "undefined" ? navigator : void 0;
    ReadImpl3 = class {
      static {
        __name(this, "ReadImpl3");
      }
      #map;
      #release;
      #closed = false;
      constructor(map, release2) {
        this.#map = map;
        this.#release = release2;
      }
      release() {
        this.#release();
        this.#closed = true;
      }
      get closed() {
        return this.#closed;
      }
      has(key2) {
        return Promise.resolve(this.#map.has(key2));
      }
      get(key2) {
        return Promise.resolve(this.#map.get(key2));
      }
    };
    WriteImpl3 = class extends WriteImplBase {
      static {
        __name(this, "WriteImpl3");
      }
      #map;
      constructor(map, release2) {
        super(new ReadImpl3(map, release2));
        this.#map = map;
      }
      commit() {
        this._pending.forEach((value, key2) => {
          if (value === deleteSentinel) {
            this.#map.delete(key2);
          } else {
            this.#map.set(key2, value);
          }
        });
        this._pending.clear();
        this.release();
        return promiseVoid;
      }
    };
    stores = /* @__PURE__ */ new Map();
    __name(dropMemStore, "dropMemStore");
    MemStore = class {
      static {
        __name(this, "MemStore");
      }
      #map;
      #rwLock;
      #closed = false;
      constructor(name) {
        const entry = stores.get(name);
        let lock;
        let map;
        if (entry) {
          ({ lock, map } = entry);
        } else {
          lock = new RWLock();
          map = /* @__PURE__ */ new Map();
          stores.set(name, { lock, map });
        }
        this.#rwLock = lock;
        this.#map = map;
      }
      async read() {
        const release2 = await this.#rwLock.read();
        return new ReadImpl3(this.#map, release2);
      }
      async write() {
        const release2 = await this.#rwLock.write();
        return new WriteImpl3(this.#map, release2);
      }
      close() {
        this.#closed = true;
        return promiseVoid;
      }
      get closed() {
        return this.#closed;
      }
    };
    IDBStoreWithMemFallback = class {
      static {
        __name(this, "IDBStoreWithMemFallback");
      }
      #lc;
      #name;
      #store;
      constructor(lc, name) {
        this.#lc = lc;
        this.#name = name;
        this.#store = new IDBStore(name);
      }
      read() {
        return this.#withBrainTransplant((s3) => s3.read());
      }
      write() {
        return this.#withBrainTransplant((s3) => s3.write());
      }
      async #withBrainTransplant(f) {
        try {
          return await f(this.#store);
        } catch (e3) {
          if (isFirefoxPrivateBrowsingError(e3)) {
            if (this.#store instanceof IDBStore) {
              this.#lc.info?.(
                "Switching to MemStore because of Firefox private browsing error"
              );
              this.#store = new MemStore(this.#name);
            }
            return f(this.#store);
          }
          throw e3;
        }
      }
      close() {
        return this.#store.close();
      }
      get closed() {
        return this.#store.closed;
      }
    };
    __name(isFirefoxPrivateBrowsingError, "isFirefoxPrivateBrowsingError");
    __name(isFirefox, "isFirefox");
    __name(newIDBStoreWithMemFallback, "newIDBStoreWithMemFallback");
    __name(dropIDBStoreWithMemFallback, "dropIDBStoreWithMemFallback");
    __name(dropIDBStore, "dropIDBStore");
    __name(getDocumentVisibilityWatcher, "getDocumentVisibilityWatcher");
    DocumentVisibilityWatcherImpl = class {
      static {
        __name(this, "DocumentVisibilityWatcherImpl");
      }
      #doc;
      #hiddenIntervalMS;
      #timeoutID = 0;
      // This trails doc.visibilityState by hiddenIntervalMS when being hidden. This
      // is because we want to wait for the tab to be hidden for a while before
      // considering as hidden.
      visibilityState;
      #promises = /* @__PURE__ */ new Set();
      constructor(doc, hiddenIntervalMS, signal) {
        this.#doc = doc;
        this.#hiddenIntervalMS = hiddenIntervalMS;
        this.visibilityState = doc.visibilityState;
        this.#doc.addEventListener("visibilitychange", this.#onVisibilityChange, {
          signal
        });
      }
      #onVisibilityChange = /* @__PURE__ */ __name(() => {
        if (this.#doc.visibilityState === "visible") {
          clearTimeout(this.#timeoutID);
          this.#setVisibilityState("visible");
        } else {
          this.#timeoutID = setTimeout(() => {
            this.#setVisibilityState("hidden");
          }, this.#hiddenIntervalMS);
        }
      }, "#onVisibilityChange");
      #setVisibilityState(visibilityState) {
        if (visibilityState === this.visibilityState) {
          return;
        }
        this.visibilityState = visibilityState;
        for (const entry of this.#promises) {
          const { resolve: resolve2, state: state2 } = entry;
          if (state2 === visibilityState) {
            resolve2();
            this.#promises.delete(entry);
          }
        }
      }
      waitForVisible() {
        return this.#waitFor("visible");
      }
      waitForHidden() {
        return this.#waitFor("hidden");
      }
      #waitFor(state2) {
        if (this.visibilityState === state2) {
          return Promise.resolve();
        }
        const { promise, resolve: resolve2 } = resolver();
        this.#promises.add({ resolve: resolve2, state: state2 });
        return promise;
      }
    };
    resolvedPromise = Promise.resolve();
    promiseThatNeverResolves = new Promise(() => void 0);
    DocumentVisibilityWatcherNoDoc = class {
      static {
        __name(this, "DocumentVisibilityWatcherNoDoc");
      }
      visibilityState = "visible";
      waitForVisible() {
        return resolvedPromise;
      }
      waitForHidden() {
        return promiseThatNeverResolves;
      }
    };
    ConnectionLoopDelegateImpl = class {
      static {
        __name(this, "ConnectionLoopDelegateImpl");
      }
      rep;
      invokeSend;
      // TODO: Remove the ability to have more than one concurrent connection and update tests.
      // Bug: https://github.com/rocicorp/replicache-internal/issues/303
      maxConnections = 1;
      constructor(rep, invokeSend) {
        this.rep = rep;
        this.invokeSend = invokeSend;
      }
      get maxDelayMs() {
        return this.rep.requestOptions.maxDelayMs;
      }
      get minDelayMs() {
        return this.rep.requestOptions.minDelayMs;
      }
    };
    PullDelegate = class extends ConnectionLoopDelegateImpl {
      static {
        __name(this, "PullDelegate");
      }
      debounceDelay = 0;
      get watchdogTimer() {
        return this.rep.pullInterval;
      }
    };
    PushDelegate = class extends ConnectionLoopDelegateImpl {
      static {
        __name(this, "PushDelegate");
      }
      get debounceDelay() {
        return this.rep.pushDelay;
      }
      watchdogTimer = null;
    };
    MIN_DELAY_MS = 30;
    MAX_DELAY_MS = 6e4;
    ConnectionLoop = class {
      static {
        __name(this, "ConnectionLoop");
      }
      // ConnectionLoop runs a loop sending network requests (either pushes or
      // pulls) to the server. Our goal, generally, is to send requests as fast as
      // we can, but to adjust in case of slowness, network errors, etc. We will
      // send requests in parallel if the server supports it. We also debounce
      // pushes since they frequently happen in series very near to one another
      // (e.g., during drag'n drops).
      //
      // The loop flows through the following states forever, until it is closed:
      //
      // Pending: Wait for event or watchdog
      //          |
      //          v
      // Debounce: Wait for more events (we debounce pushes)
      //          |
      //          v
      // Wait for available connection (we limit number of parallel requests
      // allowed)
      //          |
      //          v
      // Wait to send (if requests are taking too long, we will slow down)
      //          |
      //          v
      // Send (asynchronously, wrt the loop)
      //          |
      //          v
      // Back to the pending!
      // Controls whether the next iteration of the loop will wait at the pending
      // state.
      #pendingResolver = resolver();
      /**
       * This resolver is used to allow us to skip sleeps when we do send(true)
       */
      #skipSleepsResolver = resolver();
      /**
       * Resolver for the next send. Never rejects. Returns an error instead since
       * this resolver is used in cases where they might not be someone waiting,
       * and we don't want an unhandled promise rejection in that case.
       */
      #sendResolver = resolver();
      #delegate;
      #closed = false;
      /**
       * Number of pending send calls.
       *
       * We keep track of this because if close happens while we are waiting for the
       * send to resolve we should reject the send promise.
       */
      #sendCounter = 0;
      #lc;
      #visibilityWatcher;
      constructor(lc, delegate, visibilityWatcher) {
        this.#lc = lc;
        this.#delegate = delegate;
        this.#visibilityWatcher = visibilityWatcher;
        void this.run();
      }
      close() {
        this.#closed = true;
        if (this.#sendCounter > 0) {
          this.#sendResolver.resolve({ error: closeError() });
        }
      }
      /**
       *
       * @returns Returns undefined if ok, otherwise it return the error that caused
       * the send to fail.
       */
      async send(now) {
        if (this.#closed) {
          return { error: closeError() };
        }
        this.#sendCounter++;
        this.#lc.debug?.("send", now);
        if (now) {
          this.#skipSleepsResolver.resolve();
        } else {
          await this.#visibilityWatcher?.waitForVisible();
        }
        this.#pendingResolver.resolve();
        const result = await this.#sendResolver.promise;
        this.#sendCounter--;
        return result;
      }
      async run() {
        const sendRecords = [];
        let recoverResolver = resolver();
        let lastSendTime;
        let counter = 0;
        const delegate = this.#delegate;
        const { debug: debug4 } = this.#lc;
        let delay = 0;
        debug4?.("Starting connection loop");
        const sleepMaybeSkip = /* @__PURE__ */ __name((ms) => Promise.race([this.#skipSleepsResolver.promise, sleep(ms)]), "sleepMaybeSkip");
        while (!this.#closed) {
          debug4?.(
            didLastSendRequestFail(sendRecords) ? "Last request failed. Trying again" : "Waiting for a send"
          );
          const races = [this.#pendingResolver.promise];
          const t22 = delegate.watchdogTimer;
          if (t22 !== null) {
            races.push(sleep(t22));
          }
          await Promise.race(races);
          if (this.#closed) break;
          debug4?.("Waiting for debounce");
          await sleepMaybeSkip(delegate.debounceDelay);
          if (this.#closed) break;
          debug4?.("debounced");
          this.#pendingResolver = resolver();
          if (counter >= delegate.maxConnections) {
            debug4?.("Too many request in flight. Waiting until one finishes...");
            await this.#waitUntilAvailableConnection();
            if (this.#closed) break;
            debug4?.("...finished");
          }
          if (counter > 0 || didLastSendRequestFail(sendRecords)) {
            delay = computeDelayAndUpdateDurations(delay, delegate, sendRecords);
            debug4?.(
              didLastSendRequestFail(sendRecords) ? "Last connection errored. Sleeping for" : "More than one outstanding connection (" + counter + "). Sleeping for",
              delay,
              "ms"
            );
          } else {
            delay = 0;
          }
          const clampedDelay = Math.min(
            delegate.maxDelayMs,
            Math.max(delegate.minDelayMs, delay)
          );
          if (lastSendTime !== void 0) {
            const timeSinceLastSend = Date.now() - lastSendTime;
            if (clampedDelay > timeSinceLastSend) {
              await Promise.race([
                sleepMaybeSkip(clampedDelay - timeSinceLastSend),
                recoverResolver.promise
              ]);
              if (this.#closed) break;
            }
          }
          counter++;
          (async () => {
            const start = Date.now();
            let ok2;
            let error3;
            try {
              lastSendTime = start;
              debug4?.("Sending request");
              this.#skipSleepsResolver = resolver();
              ok2 = await delegate.invokeSend();
              debug4?.("Send returned", ok2);
            } catch (e3) {
              debug4?.("Send failed", e3);
              error3 = e3;
              ok2 = false;
            }
            if (this.#closed) {
              debug4?.("Closed after invokeSend");
              return;
            }
            debug4?.("Request done", { duration: Date.now() - start, ok: ok2 });
            sendRecords.push({ duration: Date.now() - start, ok: ok2 });
            if (recovered(sendRecords)) {
              recoverResolver.resolve();
              recoverResolver = resolver();
            }
            counter--;
            this.#connectionAvailable();
            const sendResolver = this.#sendResolver;
            this.#sendResolver = resolver();
            if (error3) {
              sendResolver.resolve({ error: error3 });
            } else {
              sendResolver.resolve(void 0);
            }
            if (!ok2) {
              this.#pendingResolver.resolve();
            }
          })();
        }
      }
      #waitingConnectionResolve = void 0;
      #connectionAvailable() {
        if (this.#waitingConnectionResolve) {
          const resolve2 = this.#waitingConnectionResolve;
          this.#waitingConnectionResolve = void 0;
          resolve2();
        }
      }
      #waitUntilAvailableConnection() {
        const { promise, resolve: resolve2 } = resolver();
        this.#waitingConnectionResolve = resolve2;
        return promise;
      }
    };
    CONNECTION_MEMORY_COUNT = 9;
    __name(closeError, "closeError");
    __name(computeDelayAndUpdateDurations, "computeDelayAndUpdateDurations");
    __name(median, "median");
    __name(didLastSendRequestFail, "didLastSendRequestFail");
    __name(recovered, "recovered");
    __name(joinIterables, "joinIterables");
    __name(filterIter, "filterIter");
    __name(mapIter, "mapIter");
    IterWrapper = class _IterWrapper {
      static {
        __name(this, "_IterWrapper");
      }
      iter;
      constructor(iter) {
        this.iter = iter;
      }
      [Symbol.iterator]() {
        return this.iter[Symbol.iterator]();
      }
      map(f) {
        return new _IterWrapper(mapIter(this.iter, f));
      }
      filter(p) {
        return new _IterWrapper(filterIter(this.iter, p));
      }
    };
    __name(wrapIterable, "wrapIterable");
    __name(mergeIterables, "mergeIterables");
    SIZE_TAG = 1;
    SIZE_INT32 = 4;
    SIZE_SMI = 5;
    SIZE_DOUBLE = 8;
    __name(getSizeOfValue, "getSizeOfValue");
    __name(isSmi, "isSmi");
    entryFixed = 2 * SIZE_TAG + SIZE_INT32 + SIZE_TAG + SIZE_INT32;
    __name(getSizeOfEntry, "getSizeOfEntry");
    LazyStore = class {
      static {
        __name(this, "LazyStore");
      }
      /**
       * This lock is used to ensure correct isolation of Reads and Writes.
       * Multiple Reads are allowed in parallel but only a single Write.  Reads and
       * Writes see an isolated view of the store (corresponding to the Serializable
       * level of transaction isolation defined in the SQL standard).
       *
       * To ensure these semantics the read lock must be acquired when a Read is
       * created and held til it is closed, and a Write lock must be acquired when a
       * Write is created and held til it is committed or closed.
       *
       * Code must have a read or write lock to
       * - read `_heads`
       * - read `_memOnlyChunks`
       * - read `_sourceStore`
       * - read and write `_sourceChunksCache`
       * - read and write `_refCounts`
       * - read and write `_refs`
       * and must have a write lock to
       * - write `_heads`
       * - write `_memOnlyChunks`
       */
      #rwLock = new RWLock();
      #heads = /* @__PURE__ */ new Map();
      #sourceStore;
      #chunkHasher;
      #assertValidHash;
      /** The following are protected so testing subclass can access. */
      _memOnlyChunks = /* @__PURE__ */ new Map();
      _sourceChunksCache;
      /**
       * Ref counts are maintained so that chunks which are unreachable
       * from this stores heads can be eagerly and deterministically deleted from
       * `this._memOnlyChunks` and `this._sourceChunksCache`.
       *
       * These ref counts are independent from `this._sourceStore`'s ref counts.
       * These ref counts are based on reachability from `this._heads`.
       * A chunk is deleted from `this._memOnlyChunks` or
       * `this._sourceChunksCache` (which ever it is in) when its ref count becomes
       * zero.
       * These ref counts count the refs in `this._heads` and `this._refs`.
       *
       * Not all reachable chunk's refs are included in `this._refs`, because this
       * would require loading all chunks reachable in the source store in a
       * non-lazy manner. `this._refs` contains the refs of all currently reachable
       * chunks that were ever in `this._memOnlyChunks` or
       * `this._sourceChunksCache` (even if they have been evicted).  A
       * chunk's ref information is lazily discovered and stored in `this._refs` and
       * counted in `this._refCounts`. A chunk's entries in `this._refs` and
       * `this._refCounts` are only deleted when a chunk is deleted due to it
       * becoming unreachable (it is not deleted if the chunk is evicted from the
       * source-store cache).
       *
       * The major implication of this lazy discovery of source store refs, is that
       * a reachable source store chunk may not be cached when loaded, because it is
       * not known to be reachable because some of the pertinent refs have not been
       * discovered.  However, in practice chunks are read by traversing the graph
       * starting from a head, and all pertinent refs are discovered as part of the
       * traversal.
       *
       * These ref counts can be changed in two ways:
       * 1. A LazyRead has a cache miss and loads a chunk from the source store that
       * is reachable from this._heads.  If this chunk's refs are not currently
       * counted, it will not have an entry in `this._refs`.  In this case, the
       * chunks refs will be put in `this._refs` and `this._refCounts` will be
       * updated to count them.
       * 2. A LazyWrite commit updates a head (which can result in increasing or
       * decreasing ref count) or puts a reachable chunk (either a `memory-only` or
       * `source` chunk) that references this hash (increasing ref count).  The
       * computation of these ref count changes is delegated to the
       * `computeRefCountUpdates` shared with dag.StoreImpl.  In order to
       * delegate determining reachability to `computeRefCountUpdates` and defer
       * this determination until commit time, LazyWrite treats cache misses
       * as a 'put' of the lazily-loaded chunk.
       *
       * A chunk's hash may have an entry in `this._refCounts` without that
       * chunk have ever been in `this._memOnlyChunks` or `this._sourceChunksCache`.
       * This is the case when a head or a reachable chunk that was ever in
       * `this._memOnlyChunks` or `this._sourceChunksCache` references a chunk
       * which is not currently cached (either because it has not been read, or
       * because it has been evicted).
       */
      _refCounts = /* @__PURE__ */ new Map();
      _refs = /* @__PURE__ */ new Map();
      constructor(sourceStore, sourceCacheSizeLimit, chunkHasher, assertValidHash, getSizeOfChunk = getSizeOfValue) {
        this._sourceChunksCache = new ChunksCache(
          sourceCacheSizeLimit,
          getSizeOfChunk,
          this._refCounts,
          this._refs
        );
        this.#sourceStore = sourceStore;
        this.#chunkHasher = chunkHasher;
        this.#assertValidHash = assertValidHash;
      }
      async read(sourceRead) {
        const release2 = await this.#rwLock.read();
        return new LazyRead(
          this.#heads,
          this._memOnlyChunks,
          this._sourceChunksCache,
          this.#sourceStore,
          release2,
          this.#assertValidHash,
          sourceRead
        );
      }
      async write() {
        const release2 = await this.#rwLock.write();
        return new LazyWrite(
          this.#heads,
          this._memOnlyChunks,
          this._sourceChunksCache,
          this.#sourceStore,
          this._refCounts,
          this._refs,
          release2,
          this.#chunkHasher,
          this.#assertValidHash
        );
      }
      close() {
        return promiseVoid;
      }
      /**
       * Does not acquire any lock on the store.
       */
      isCached(chunkHash) {
        return this._sourceChunksCache.getWithoutUpdatingLRU(chunkHash) !== void 0;
      }
      withSuspendedSourceCacheEvictsAndDeletes(fn) {
        return this._sourceChunksCache.withSuspendedEvictsAndDeletes(fn);
      }
    };
    LazyRead = class {
      static {
        __name(this, "LazyRead");
      }
      _heads;
      _memOnlyChunks;
      _sourceChunksCache;
      _sourceStore;
      #sourceRead = void 0;
      #release;
      #closed = false;
      assertValidHash;
      #sourceReadOwnedByCaller;
      constructor(heads, memOnlyChunks, sourceChunksCache, sourceStore, release2, assertValidHash, sourceRead) {
        this._heads = heads;
        this._memOnlyChunks = memOnlyChunks;
        this._sourceChunksCache = sourceChunksCache;
        this._sourceStore = sourceStore;
        this.#release = release2;
        this.assertValidHash = assertValidHash;
        this.#sourceRead = sourceRead !== void 0 ? Promise.resolve(sourceRead) : void 0;
        this.#sourceReadOwnedByCaller = sourceRead !== void 0;
      }
      isMemOnlyChunkHash(hash22) {
        return this._memOnlyChunks.has(hash22);
      }
      async hasChunk(hash22) {
        return await this.getChunk(hash22) !== void 0;
      }
      async getChunk(hash22) {
        const memOnlyChunk = this._memOnlyChunks.get(hash22);
        if (memOnlyChunk !== void 0) {
          return memOnlyChunk;
        }
        let chunk = this._sourceChunksCache.get(hash22);
        if (chunk === void 0) {
          chunk = await (await this._getSourceRead()).getChunk(hash22);
          if (chunk !== void 0) {
            this._sourceChunksCache.put(chunk);
          }
        }
        return chunk;
      }
      mustGetChunk(hash22) {
        return mustGetChunk(this, hash22);
      }
      getHead(name) {
        return Promise.resolve(this._heads.get(name));
      }
      release() {
        if (!this.#closed) {
          this.#release();
          if (!this.#sourceReadOwnedByCaller) {
            this.#sourceRead?.then((read) => read.release()).catch((_) => {
            });
          }
          this.#closed = true;
        }
      }
      get closed() {
        return this.#closed;
      }
      _getSourceRead() {
        if (!this.#sourceRead) {
          this.#sourceRead = this._sourceStore.read();
        }
        return this.#sourceRead;
      }
    };
    LazyWrite = class extends LazyRead {
      static {
        __name(this, "LazyWrite");
      }
      #refCounts;
      #refs;
      #chunkHasher;
      _pendingHeadChanges = /* @__PURE__ */ new Map();
      _pendingMemOnlyChunks = /* @__PURE__ */ new Map();
      _pendingCachedChunks = /* @__PURE__ */ new Map();
      #createdChunks = /* @__PURE__ */ new Set();
      constructor(heads, memOnlyChunks, sourceChunksCache, sourceStore, refCounts, refs, release2, chunkHasher, assertValidHash) {
        super(
          heads,
          memOnlyChunks,
          sourceChunksCache,
          sourceStore,
          release2,
          assertValidHash
        );
        this.#refCounts = refCounts;
        this.#refs = refs;
        this.#chunkHasher = chunkHasher;
      }
      createChunk = /* @__PURE__ */ __name((data, refs) => {
        const chunk = createChunk(data, refs, this.#chunkHasher);
        this.#createdChunks.add(chunk.hash);
        return chunk;
      }, "createChunk");
      putChunk(c2, size2) {
        const { hash: hash22, meta } = c2;
        this.assertValidHash(hash22);
        if (meta.length > 0) {
          for (const h of meta) {
            this.assertValidHash(h);
          }
        }
        if (this.#createdChunks.has(hash22) || this.isMemOnlyChunkHash(hash22)) {
          this._pendingMemOnlyChunks.set(hash22, c2);
        } else {
          this._pendingCachedChunks.set(hash22, { chunk: c2, size: size2 ?? -1 });
        }
        return promiseVoid;
      }
      async setHead(name, hash22) {
        await this.#setHead(name, hash22);
      }
      async removeHead(name) {
        await this.#setHead(name, void 0);
      }
      async #setHead(name, hash22) {
        const oldHash = await this.getHead(name);
        const v2 = this._pendingHeadChanges.get(name);
        if (v2 === void 0) {
          this._pendingHeadChanges.set(name, { new: hash22, old: oldHash });
        } else {
          v2.new = hash22;
        }
      }
      isMemOnlyChunkHash(hash22) {
        return this._pendingMemOnlyChunks.has(hash22) || super.isMemOnlyChunkHash(hash22);
      }
      async getChunk(hash22) {
        const pendingMemOnlyChunk = this._pendingMemOnlyChunks.get(hash22);
        if (pendingMemOnlyChunk !== void 0) {
          return pendingMemOnlyChunk;
        }
        const memOnlyChunk = this._memOnlyChunks.get(hash22);
        if (memOnlyChunk !== void 0) {
          return memOnlyChunk;
        }
        const pendingCachedChunk = this._pendingCachedChunks.get(hash22);
        if (pendingCachedChunk !== void 0) {
          return pendingCachedChunk.chunk;
        }
        let chunk = this._sourceChunksCache.get(hash22);
        if (chunk === void 0) {
          chunk = await (await this._getSourceRead()).getChunk(hash22);
          if (chunk !== void 0) {
            this._pendingCachedChunks.set(chunk.hash, { chunk, size: -1 });
          }
        }
        return chunk;
      }
      getHead(name) {
        const headChange = this._pendingHeadChanges.get(name);
        if (headChange) {
          return Promise.resolve(headChange.new);
        }
        return super.getHead(name);
      }
      async commit() {
        const pendingChunks = new Set(
          joinIterables(
            this._pendingMemOnlyChunks.keys(),
            this._pendingCachedChunks.keys()
          )
        );
        const refCountUpdates = await computeRefCountUpdates(
          this._pendingHeadChanges.values(),
          pendingChunks,
          this
        );
        for (const [hash22, count3] of refCountUpdates) {
          if (this.isMemOnlyChunkHash(hash22)) {
            if (count3 === 0) {
              this.#refCounts.delete(hash22);
              this._memOnlyChunks.delete(hash22);
              this.#refs.delete(hash22);
            } else {
              this.#refCounts.set(hash22, count3);
              const chunk = this._pendingMemOnlyChunks.get(hash22);
              if (chunk) {
                this.#refs.set(hash22, chunk.meta);
                this._memOnlyChunks.set(hash22, chunk);
              }
            }
            refCountUpdates.delete(hash22);
          }
        }
        this._sourceChunksCache.updateForCommit(
          this._pendingCachedChunks,
          refCountUpdates
        );
        for (const [name, headChange] of this._pendingHeadChanges) {
          if (headChange.new) {
            this._heads.set(name, headChange.new);
          } else {
            this._heads.delete(name);
          }
        }
        this._pendingMemOnlyChunks.clear();
        this._pendingCachedChunks.clear();
        this._pendingHeadChanges.clear();
        this.release();
      }
      getRefCount(hash22) {
        return this.#refCounts.get(hash22);
      }
      getRefs(hash22) {
        const pendingMemOnlyChunk = this._pendingMemOnlyChunks.get(hash22);
        if (pendingMemOnlyChunk) {
          return pendingMemOnlyChunk.meta;
        }
        const memOnlyChunk = this._memOnlyChunks.get(hash22);
        if (memOnlyChunk) {
          return memOnlyChunk.meta;
        }
        const pendingCachedChunk = this._pendingCachedChunks.get(hash22);
        if (pendingCachedChunk !== void 0) {
          return pendingCachedChunk.chunk.meta;
        }
        return this.#refs.get(hash22);
      }
      areRefsCounted(hash22) {
        return this.#refs.has(hash22);
      }
      chunksPersisted(chunkHashes) {
        const chunksToCache = [];
        for (const chunkHash of chunkHashes) {
          const chunk = this._memOnlyChunks.get(chunkHash);
          if (chunk) {
            this._memOnlyChunks.delete(chunkHash);
            chunksToCache.push(chunk);
          }
        }
        this._sourceChunksCache.persisted(chunksToCache);
      }
    };
    ChunksCache = class {
      static {
        __name(this, "ChunksCache");
      }
      #cacheSizeLimit;
      #getSizeOfChunk;
      #refCounts;
      #refs;
      #size = 0;
      #evictsAndDeletesSuspended = false;
      #suspendedDeletes = [];
      /**
       * Iteration order is from least to most recently used.
       *
       * Public so that testing subclass can access.
       */
      cacheEntries = /* @__PURE__ */ new Map();
      constructor(cacheSizeLimit, getSizeOfChunk, refCounts, refs) {
        this.#cacheSizeLimit = cacheSizeLimit;
        this.#getSizeOfChunk = getSizeOfChunk;
        this.#refCounts = refCounts;
        this.#refs = refs;
      }
      get(hash22) {
        const cacheEntry = this.cacheEntries.get(hash22);
        if (cacheEntry) {
          this.cacheEntries.delete(hash22);
          this.cacheEntries.set(hash22, cacheEntry);
        }
        return cacheEntry?.chunk;
      }
      getWithoutUpdatingLRU(hash22) {
        return this.cacheEntries.get(hash22)?.chunk;
      }
      put(chunk) {
        const { hash: hash22 } = chunk;
        const oldCacheEntry = this.cacheEntries.get(hash22);
        if (oldCacheEntry) {
          this.cacheEntries.delete(hash22);
          this.cacheEntries.set(hash22, oldCacheEntry);
          return;
        }
        const refCount = this.#refCounts.get(hash22);
        if (refCount === void 0 || refCount < 1) {
          return;
        }
        if (!this.#cacheChunk(chunk)) {
          return;
        }
        if (!this.#refs.has(hash22)) {
          for (const refHash of chunk.meta) {
            this.#refCounts.set(refHash, (this.#refCounts.get(refHash) || 0) + 1);
          }
          this.#refs.set(hash22, chunk.meta);
        }
        this.#ensureCacheSizeLimit();
      }
      #ensureCacheSizeLimit() {
        if (this.#evictsAndDeletesSuspended) {
          return;
        }
        for (const entry of this.cacheEntries.values()) {
          if (this.#size <= this.#cacheSizeLimit) {
            break;
          }
          this.#evict(entry);
        }
      }
      #cacheChunk(chunk, size2) {
        const chunkSize = size2 ?? this.#getSizeOfChunk(chunk);
        if (chunkSize > this.#cacheSizeLimit) {
          return false;
        }
        this.#size += chunkSize;
        this.cacheEntries.set(chunk.hash, { chunk, size: chunkSize });
        return true;
      }
      #evict(cacheEntry) {
        const { hash: hash22 } = cacheEntry.chunk;
        this.#size -= cacheEntry.size;
        this.cacheEntries.delete(hash22);
      }
      #deleteEntryByHash(hash22) {
        this.#refCounts.delete(hash22);
        this.#refs.delete(hash22);
        const cacheEntry = this.cacheEntries.get(hash22);
        if (cacheEntry) {
          this.#size -= cacheEntry.size;
          this.cacheEntries.delete(hash22);
        }
      }
      updateForCommit(chunksToPut, refCountUpdates) {
        for (const [hash22, count3] of refCountUpdates) {
          if (count3 === 0) {
            if (!this.#evictsAndDeletesSuspended) {
              this.#deleteEntryByHash(hash22);
            } else {
              this.#refCounts.set(hash22, 0);
              this.#suspendedDeletes.push(hash22);
            }
          } else {
            this.#refCounts.set(hash22, count3);
            const chunkAndSize = chunksToPut.get(hash22);
            if (chunkAndSize) {
              const { chunk, size: size2 } = chunkAndSize;
              const oldCacheEntry = this.cacheEntries.get(hash22);
              if (oldCacheEntry) {
                this.cacheEntries.delete(hash22);
                this.cacheEntries.set(hash22, oldCacheEntry);
              } else {
                this.#cacheChunk(chunk, size2 !== -1 ? size2 : void 0);
                this.#refs.set(hash22, chunk.meta);
              }
            }
          }
        }
        this.#ensureCacheSizeLimit();
      }
      persisted(chunks) {
        for (const chunk of chunks) {
          this.#cacheChunk(chunk);
        }
        this.#ensureCacheSizeLimit();
      }
      async withSuspendedEvictsAndDeletes(fn) {
        this.#evictsAndDeletesSuspended = true;
        try {
          return await fn();
        } finally {
          this.#evictsAndDeletesSuspended = false;
          for (const hash22 of this.#suspendedDeletes) {
            if (this.#refCounts.get(hash22) === 0) {
              this.#deleteEntryByHash(hash22);
            }
          }
          this.#ensureCacheSizeLimit();
        }
      }
    };
    LocalDD31 = 4;
    SnapshotDD31 = 5;
    DEFAULT_HEAD_NAME = "main";
    __name(commitIsLocalDD31, "commitIsLocalDD31");
    __name(commitIsLocal, "commitIsLocal");
    __name(commitIsSnapshot, "commitIsSnapshot");
    Commit = class {
      static {
        __name(this, "Commit");
      }
      chunk;
      constructor(chunk) {
        this.chunk = chunk;
      }
      get meta() {
        return this.chunk.data.meta;
      }
      get valueHash() {
        return this.chunk.data.valueHash;
      }
      getMutationID(clientID, dagRead) {
        return getMutationID(clientID, dagRead, this.meta);
      }
      async getNextMutationID(clientID, dagRead) {
        return await this.getMutationID(clientID, dagRead) + 1;
      }
      get indexes() {
        return this.chunk.data.indexes;
      }
    };
    __name(getMutationID, "getMutationID");
    __name(localMutations, "localMutations");
    __name(localMutationsDD31, "localMutationsDD31");
    __name(localMutationsGreaterThan, "localMutationsGreaterThan");
    __name(baseSnapshotFromHead, "baseSnapshotFromHead");
    __name(baseSnapshotHashFromHash, "baseSnapshotHashFromHash");
    __name(baseSnapshotFromHash, "baseSnapshotFromHash");
    __name(baseSnapshotFromCommit, "baseSnapshotFromCommit");
    __name(snapshotMetaParts, "snapshotMetaParts");
    __name(compareCookiesForSnapshots, "compareCookiesForSnapshots");
    __name(commitChain, "commitChain");
    __name(commitFromHash, "commitFromHash");
    __name(commitFromHead, "commitFromHead");
    __name(assertLocalMetaDD31, "assertLocalMetaDD31");
    __name(isLocalMetaDD31, "isLocalMetaDD31");
    __name(assertSnapshotMetaDD31, "assertSnapshotMetaDD31");
    __name(assertLastMutationIDs, "assertLastMutationIDs");
    __name(assertSnapshotCommitDD31, "assertSnapshotCommitDD31");
    __name(isSnapshotMetaDD31, "isSnapshotMetaDD31");
    __name(assertMeta, "assertMeta");
    __name(chunkIndexDefinitionEqualIgnoreName, "chunkIndexDefinitionEqualIgnoreName");
    __name(assertChunkIndexDefinition, "assertChunkIndexDefinition");
    __name(toChunkIndexDefinition, "toChunkIndexDefinition");
    __name(assertIndexRecord, "assertIndexRecord");
    __name(assertIndexRecords, "assertIndexRecords");
    __name(newLocalDD31, "newLocalDD31");
    __name(newSnapshotDD31, "newSnapshotDD31");
    __name(newSnapshotCommitDataDD31, "newSnapshotCommitDataDD31");
    __name(fromChunk, "fromChunk");
    __name(commitFromCommitData, "commitFromCommitData");
    __name(getRefs, "getRefs");
    __name(makeCommitData, "makeCommitData");
    __name(assertCommitData, "assertCommitData");
    __name(validateChunk, "validateChunk");
    __name(binarySearch2, "binarySearch");
    NODE_LEVEL = 0;
    NODE_ENTRIES = 1;
    __name(makeNodeChunkData, "makeNodeChunkData");
    __name(findLeaf, "findLeaf");
    __name(binarySearch22, "binarySearch2");
    __name(binarySearchFound, "binarySearchFound");
    __name(parseBTreeNode, "parseBTreeNode");
    __name(assertEntry, "assertEntry");
    __name(convertNonV7Entry, "convertNonV7Entry");
    NodeImpl = class {
      static {
        __name(this, "NodeImpl");
      }
      entries;
      hash;
      isMutable;
      #childNodeSize = -1;
      constructor(entries, hash22, isMutable) {
        this.entries = entries;
        this.hash = hash22;
        this.isMutable = isMutable;
      }
      maxKey() {
        return this.entries[this.entries.length - 1][0];
      }
      getChildNodeSize(tree) {
        if (this.#childNodeSize !== -1) {
          return this.#childNodeSize;
        }
        let sum = tree.chunkHeaderSize;
        for (const entry of this.entries) {
          sum += entry[2];
        }
        return this.#childNodeSize = sum;
      }
      _updateNode(tree) {
        this.#childNodeSize = -1;
        tree.updateNode(
          this
        );
      }
    };
    __name(toChunkData, "toChunkData");
    DataNodeImpl = class extends NodeImpl {
      static {
        __name(this, "DataNodeImpl");
      }
      level = 0;
      set(key2, value, entrySize, tree) {
        let deleteCount;
        const i = binarySearch22(key2, this.entries);
        if (!binarySearchFound(i, this.entries, key2)) {
          deleteCount = 0;
        } else {
          deleteCount = 1;
        }
        return Promise.resolve(
          this.#splice(tree, i, deleteCount, [key2, value, entrySize])
        );
      }
      #splice(tree, start, deleteCount, ...items) {
        if (this.isMutable) {
          this.entries.splice(start, deleteCount, ...items);
          this._updateNode(tree);
          return this;
        }
        const entries = readonlySplice(this.entries, start, deleteCount, ...items);
        return tree.newDataNodeImpl(entries);
      }
      del(key2, tree) {
        const i = binarySearch22(key2, this.entries);
        if (!binarySearchFound(i, this.entries, key2)) {
          return Promise.resolve(this);
        }
        return Promise.resolve(this.#splice(tree, i, 1));
      }
      async *keys(_tree) {
        for (const entry of this.entries) {
          yield entry[0];
        }
      }
      async *entriesIter(_tree) {
        for (const entry of this.entries) {
          yield entry;
        }
      }
    };
    __name(readonlySplice, "readonlySplice");
    InternalNodeImpl = class _InternalNodeImpl extends NodeImpl {
      static {
        __name(this, "_InternalNodeImpl");
      }
      level;
      constructor(entries, hash22, level, isMutable) {
        super(entries, hash22, isMutable);
        this.level = level;
      }
      async set(key2, value, entrySize, tree) {
        let i = binarySearch22(key2, this.entries);
        if (i === this.entries.length) {
          i--;
        }
        const childHash = this.entries[i][1];
        const oldChildNode = await tree.getNode(childHash);
        const childNode = await oldChildNode.set(key2, value, entrySize, tree);
        const childNodeSize = childNode.getChildNodeSize(tree);
        if (childNodeSize > tree.maxSize || childNodeSize < tree.minSize) {
          return this.#mergeAndPartition(tree, i, childNode);
        }
        const newEntry = createNewInternalEntryForNode(
          childNode,
          tree.getEntrySize
        );
        return this.#replaceChild(tree, i, newEntry);
      }
      /**
       * This merges the child node entries with previous or next sibling and then
       * partitions the merged entries.
       */
      async #mergeAndPartition(tree, i, childNode) {
        const level = this.level - 1;
        const thisEntries = this.entries;
        let values2;
        let startIndex;
        let removeCount;
        if (i > 0) {
          const hash22 = thisEntries[i - 1][1];
          const previousSibling = await tree.getNode(hash22);
          values2 = joinIterables(
            previousSibling.entries,
            childNode.entries
          );
          startIndex = i - 1;
          removeCount = 2;
        } else if (i < thisEntries.length - 1) {
          const hash22 = thisEntries[i + 1][1];
          const nextSibling = await tree.getNode(hash22);
          values2 = joinIterables(
            childNode.entries,
            nextSibling.entries
          );
          startIndex = i;
          removeCount = 2;
        } else {
          values2 = childNode.entries;
          startIndex = i;
          removeCount = 1;
        }
        const partitions = partition(
          values2,
          (value) => value[2],
          tree.minSize - tree.chunkHeaderSize,
          tree.maxSize - tree.chunkHeaderSize
        );
        const newEntries = [];
        for (const entries2 of partitions) {
          const node = tree.newNodeImpl(entries2, level);
          const newHashEntry = createNewInternalEntryForNode(
            node,
            tree.getEntrySize
          );
          newEntries.push(newHashEntry);
        }
        if (this.isMutable) {
          this.entries.splice(startIndex, removeCount, ...newEntries);
          this._updateNode(tree);
          return this;
        }
        const entries = readonlySplice(
          thisEntries,
          startIndex,
          removeCount,
          ...newEntries
        );
        return tree.newInternalNodeImpl(entries, this.level);
      }
      #replaceChild(tree, index10, newEntry) {
        if (this.isMutable) {
          this.entries.splice(index10, 1, newEntry);
          this._updateNode(tree);
          return this;
        }
        const entries = readonlySplice(this.entries, index10, 1, newEntry);
        return tree.newInternalNodeImpl(entries, this.level);
      }
      async del(key2, tree) {
        const i = binarySearch22(key2, this.entries);
        if (i === this.entries.length) {
          return this;
        }
        const childHash = this.entries[i][1];
        const oldChildNode = await tree.getNode(childHash);
        const oldHash = oldChildNode.hash;
        const childNode = await oldChildNode.del(key2, tree);
        if (childNode.hash === oldHash) {
          return this;
        }
        if (childNode.entries.length === 0) {
          const entries = readonlySplice(this.entries, i, 1);
          return tree.newInternalNodeImpl(entries, this.level);
        }
        if (i === 0 && this.entries.length === 1) {
          return childNode;
        }
        if (childNode.getChildNodeSize(tree) > tree.minSize) {
          const entry = createNewInternalEntryForNode(childNode, tree.getEntrySize);
          return this.#replaceChild(tree, i, entry);
        }
        return this.#mergeAndPartition(tree, i, childNode);
      }
      async *keys(tree) {
        for (const entry of this.entries) {
          const childNode = await tree.getNode(entry[1]);
          yield* childNode.keys(tree);
        }
      }
      async *entriesIter(tree) {
        for (const entry of this.entries) {
          const childNode = await tree.getNode(entry[1]);
          yield* childNode.entriesIter(tree);
        }
      }
      getChildren(start, length, tree) {
        const ps = [];
        for (let i = start; i < length && i < this.entries.length; i++) {
          ps.push(tree.getNode(this.entries[i][1]));
        }
        return Promise.all(ps);
      }
      async getCompositeChildren(start, length, tree) {
        const { level } = this;
        if (length === 0) {
          return new _InternalNodeImpl([], newRandomHash(), level - 1, true);
        }
        const output = await this.getChildren(start, start + length, tree);
        if (level > 1) {
          const entries2 = [];
          for (const child of output) {
            entries2.push(...child.entries);
          }
          return new _InternalNodeImpl(entries2, newRandomHash(), level - 1, true);
        }
        assert3(level === 1);
        const entries = [];
        for (const child of output) {
          entries.push(...child.entries);
        }
        return new DataNodeImpl(entries, newRandomHash(), true);
      }
    };
    __name(newNodeImpl, "newNodeImpl");
    __name(isDataNodeImpl, "isDataNodeImpl");
    __name(partition, "partition");
    emptyDataNode = makeNodeChunkData(
      0,
      [],
      Latest
    );
    emptyDataNodeImpl = new DataNodeImpl([], emptyHash, false);
    __name(createNewInternalEntryForNode, "createNewInternalEntryForNode");
    SPLICE_UNASSIGNED = -1;
    SPLICE_AT = 0;
    SPLICE_REMOVED = 1;
    SPLICE_ADDED = 2;
    SPLICE_FROM = 3;
    KEY = 0;
    VALUE = 1;
    __name(computeSplices, "computeSplices");
    NODE_HEADER_SIZE = 11;
    BTreeRead = class {
      static {
        __name(this, "BTreeRead");
      }
      _cache = /* @__PURE__ */ new Map();
      _dagRead;
      _formatVersion;
      rootHash;
      getEntrySize;
      chunkHeaderSize;
      constructor(dagRead, formatVersion, root2 = emptyHash, getEntrySize = getSizeOfEntry, chunkHeaderSize = NODE_HEADER_SIZE) {
        this._dagRead = dagRead;
        this._formatVersion = formatVersion;
        this.rootHash = root2;
        this.getEntrySize = getEntrySize;
        this.chunkHeaderSize = chunkHeaderSize;
      }
      async getNode(hash22) {
        if (hash22 === emptyHash) {
          return emptyDataNodeImpl;
        }
        const cached = this._cache.get(hash22);
        if (cached) {
          return cached;
        }
        const chunk = await this._dagRead.mustGetChunk(hash22);
        const data = parseBTreeNode(
          chunk.data,
          this._formatVersion,
          this.getEntrySize
        );
        const impl = newNodeImpl(
          data[NODE_ENTRIES],
          hash22,
          data[NODE_LEVEL],
          false
        );
        this._cache.set(hash22, impl);
        return impl;
      }
      async get(key2) {
        const leaf = await findLeaf(key2, this.rootHash, this, this.rootHash);
        const index10 = binarySearch22(key2, leaf.entries);
        if (!binarySearchFound(index10, leaf.entries, key2)) {
          return void 0;
        }
        return leaf.entries[index10][1];
      }
      async has(key2) {
        const leaf = await findLeaf(key2, this.rootHash, this, this.rootHash);
        const index10 = binarySearch22(key2, leaf.entries);
        return binarySearchFound(index10, leaf.entries, key2);
      }
      async isEmpty() {
        const { rootHash } = this;
        const node = await this.getNode(this.rootHash);
        if (this.rootHash !== rootHash) {
          return this.isEmpty();
        }
        return node.entries.length === 0;
      }
      // We don't do any encoding of the key in the map, so we have no way of
      // determining from an entry.key alone whether it is a regular key or an
      // encoded IndexKey in an index map. Without encoding regular map keys the
      // caller has to deal with encoding and decoding the keys for the index map.
      scan(fromKey) {
        return scanForHash(
          this.rootHash,
          () => this.rootHash,
          this.rootHash,
          fromKey,
          async (hash22) => {
            const cached = await this.getNode(hash22);
            if (cached) {
              return [
                cached.level,
                cached.isMutable ? cached.entries.slice() : cached.entries
              ];
            }
            const chunk = await this._dagRead.mustGetChunk(hash22);
            return parseBTreeNode(
              chunk.data,
              this._formatVersion,
              this.getEntrySize
            );
          }
        );
      }
      async *keys() {
        const node = await this.getNode(this.rootHash);
        yield* node.keys(this);
      }
      async *entries() {
        const node = await this.getNode(this.rootHash);
        yield* node.entriesIter(this);
      }
      [Symbol.asyncIterator]() {
        return this.entries();
      }
      async *diff(last) {
        const [currentNode, lastNode] = await Promise.all([
          this.getNode(this.rootHash),
          last.getNode(last.rootHash)
        ]);
        yield* diffNodes(lastNode, currentNode, last, this);
      }
    };
    __name(diffNodes, "diffNodes");
    __name(diffEntries, "diffEntries");
    __name(scanForHash, "scanForHash");
    __name(allEntriesAsDiff, "allEntriesAsDiff");
    Add = 0;
    Remove = 1;
    IndexRead = class {
      static {
        __name(this, "IndexRead");
      }
      meta;
      map;
      constructor(meta, map) {
        this.meta = meta;
        this.map = map;
      }
    };
    IndexWrite = class extends IndexRead {
      static {
        __name(this, "IndexWrite");
      }
      // Note: does not update self.meta.valueHash (doesn't need to at this point as flush
      // is only called during commit.)
      flush() {
        return this.map.flush();
      }
      clear() {
        return this.map.clear();
      }
    };
    __name(indexValue, "indexValue");
    __name(getIndexKeys, "getIndexKeys");
    KEY_VERSION_0 = "\0";
    KEY_SEPARATOR = "\0";
    __name(encodeIndexKey, "encodeIndexKey");
    __name(encodeIndexScanKey, "encodeIndexScanKey");
    __name(decodeIndexKey, "decodeIndexKey");
    __name(evaluateJSONPointer, "evaluateJSONPointer");
    Read = class {
      static {
        __name(this, "Read");
      }
      #dagRead;
      map;
      indexes;
      constructor(dagRead, map, indexes) {
        this.#dagRead = dagRead;
        this.map = map;
        this.indexes = indexes;
      }
      has(key2) {
        return this.map.has(key2);
      }
      get(key2) {
        return this.map.get(key2);
      }
      isEmpty() {
        return this.map.isEmpty();
      }
      getMapForIndex(indexName) {
        const idx = this.indexes.get(indexName);
        if (idx === void 0) {
          throw new Error(`Unknown index name: ${indexName}`);
        }
        return idx.map;
      }
      get closed() {
        return this.#dagRead.closed;
      }
      close() {
        this.#dagRead.release();
      }
    };
    __name(readFromDefaultHead, "readFromDefaultHead");
    __name(readFromHead, "readFromHead");
    __name(readFromHash, "readFromHash");
    __name(readFromCommit, "readFromCommit");
    __name(readIndexesForRead, "readIndexesForRead");
    __name(asyncIterableToArray, "asyncIterableToArray");
    __name(isScanIndexOptions, "isScanIndexOptions");
    __name(normalizeScanOptionIndexedStartKey, "normalizeScanOptionIndexedStartKey");
    __name(toDbScanOptions, "toDbScanOptions");
    TransactionClosedError = class extends Error {
      static {
        __name(this, "TransactionClosedError");
      }
      constructor() {
        super("Transaction is closed");
      }
    };
    __name(throwIfClosed, "throwIfClosed");
    __name(rejectIfClosed, "rejectIfClosed");
    ScanResultImpl = class {
      static {
        __name(this, "ScanResultImpl");
      }
      #iter;
      #options;
      #dbDelegateOptions;
      #onLimitKey;
      constructor(iter, options2, dbDelegateOptions, onLimitKey) {
        this.#iter = iter;
        this.#options = options2;
        this.#dbDelegateOptions = dbDelegateOptions;
        this.#onLimitKey = onLimitKey;
      }
      /** The default AsyncIterable. This is the same as {@link values}. */
      [Symbol.asyncIterator]() {
        return this.values();
      }
      /** Async iterator over the values of the {@link ReadTransaction.scan | scan} call. */
      values() {
        return new AsyncIterableIteratorToArrayWrapperImpl(
          this.#newIterator((e3) => e3[1])
        );
      }
      /**
       * Async iterator over the keys of the {@link ReadTransaction.scan | scan}
       * call. If the {@link ReadTransaction.scan | scan} is over an index the key
       * is a tuple of `[secondaryKey: string, primaryKey]`
       */
      keys() {
        return new AsyncIterableIteratorToArrayWrapperImpl(
          this.#newIterator((e3) => e3[0])
        );
      }
      /**
       * Async iterator over the entries of the {@link ReadTransaction.scan | scan}
       * call. An entry is a tuple of key values. If the
       * {@link ReadTransaction.scan | scan} is over an index the key is a tuple of
       * `[secondaryKey: string, primaryKey]`
       */
      entries() {
        return new AsyncIterableIteratorToArrayWrapperImpl(
          this.#newIterator((e3) => [e3[0], e3[1]])
        );
      }
      /** Returns all the values as an array. Same as `values().toArray()` */
      toArray() {
        return this.values().toArray();
      }
      #newIterator(toValue) {
        return scanIterator(
          toValue,
          this.#iter,
          this.#options,
          this.#dbDelegateOptions,
          this.#onLimitKey
        );
      }
    };
    AsyncIterableIteratorToArrayWrapperImpl = class {
      static {
        __name(this, "AsyncIterableIteratorToArrayWrapperImpl");
      }
      #it;
      constructor(it) {
        this.#it = it;
      }
      next() {
        return this.#it.next();
      }
      [Symbol.asyncIterator]() {
        return this.#it[Symbol.asyncIterator]();
      }
      toArray() {
        return asyncIterableToArray(this.#it);
      }
    };
    __name(scanIterator, "scanIterator");
    __name(shouldSkipIndexScan, "shouldSkipIndexScan");
    __name(shouldSkipNonIndexScan, "shouldSkipNonIndexScan");
    __name(fromKeyForIndexScanInternal, "fromKeyForIndexScanInternal");
    transactionIDCounter = 0;
    ReadTransactionImpl = class {
      static {
        __name(this, "ReadTransactionImpl");
      }
      clientID;
      dbtx;
      _lc;
      /**
       * The location in which this transaction is being used. This is either `client` or `server`.
       */
      location;
      /** @deprecated Use {@link ReadTransaction.location} instead. */
      environment;
      constructor(clientID, dbRead, lc, rpcName = "openReadTransaction") {
        this.clientID = clientID;
        this.dbtx = dbRead;
        this._lc = lc.withContext(rpcName).withContext("txid", transactionIDCounter++);
        this.environment = "client";
        this.location = "client";
      }
      get(key2) {
        return rejectIfClosed(this.dbtx) || this.dbtx.get(key2);
      }
      // eslint-disable-next-line require-await
      async has(key2) {
        throwIfClosed(this.dbtx);
        return this.dbtx.has(key2);
      }
      // eslint-disable-next-line require-await
      async isEmpty() {
        throwIfClosed(this.dbtx);
        return this.dbtx.isEmpty();
      }
      scan(options2) {
        return scan(options2, this.dbtx, noop4);
      }
    };
    __name(noop4, "noop");
    __name(scan, "scan");
    SubscriptionTransactionWrapper = class {
      static {
        __name(this, "SubscriptionTransactionWrapper");
      }
      #keys = /* @__PURE__ */ new Set();
      #scans = [];
      #tx;
      constructor(tx) {
        this.#tx = tx;
      }
      get environment() {
        return this.#tx.location;
      }
      get location() {
        return this.#tx.location;
      }
      get clientID() {
        return this.#tx.clientID;
      }
      isEmpty() {
        this.#scans.push({ options: {} });
        return this.#tx.isEmpty();
      }
      get(key2) {
        this.#keys.add(key2);
        return this.#tx.get(key2);
      }
      has(key2) {
        this.#keys.add(key2);
        return this.#tx.has(key2);
      }
      scan(options2) {
        const scanInfo = {
          options: toDbScanOptions(options2),
          inclusiveLimitKey: void 0
        };
        this.#scans.push(scanInfo);
        return scan(options2, this.#tx.dbtx, (inclusiveLimitKey) => {
          scanInfo.inclusiveLimitKey = inclusiveLimitKey;
        });
      }
      get keys() {
        return this.#keys;
      }
      get scans() {
        return this.#scans;
      }
    };
    zeroData = Symbol();
    WriteTransactionImpl = class extends ReadTransactionImpl {
      static {
        __name(this, "WriteTransactionImpl");
      }
      reason;
      mutationID;
      [zeroData];
      constructor(clientID, mutationID, reason, zData, dbWrite, lc, rpcName = "openWriteTransaction") {
        super(clientID, dbWrite, lc, rpcName);
        this.mutationID = mutationID;
        this.reason = reason;
        this[zeroData] = zData;
      }
      put(key2, value) {
        return this.set(key2, value);
      }
      async set(key2, value) {
        throwIfClosed(this.dbtx);
        await this.dbtx.put(this._lc, key2, deepFreeze(value));
      }
      del(key2) {
        return rejectIfClosed(this.dbtx) ?? this.dbtx.del(this._lc, key2);
      }
    };
    __name(getScanIterator, "getScanIterator");
    __name(fromKeyForNonIndexScan, "fromKeyForNonIndexScan");
    __name(makeScanResultFromScanIteratorInternal, "makeScanResultFromScanIteratorInternal");
    __name(getScanIteratorForIndexMap, "getScanIteratorForIndexMap");
    __name(diff, "diff");
    BTreeWrite = class extends BTreeRead {
      static {
        __name(this, "BTreeWrite");
      }
      /**
       * This rw lock is used to ensure we do not mutate the btree in parallel. It
       * would be a problem if we didn't have the lock in cases like this:
       *
       * ```ts
       * const p1 = tree.put('a', 0);
       * const p2 = tree.put('b', 1);
       * await p1;
       * await p2;
       * ```
       *
       * because both `p1` and `p2` would start from the old root hash but a put
       * changes the root hash so the two concurrent puts would lead to only one of
       * them actually working, and it is not deterministic which one would finish
       * last.
       */
      #lock = new Lock();
      #modified = /* @__PURE__ */ new Map();
      minSize;
      maxSize;
      constructor(dagWrite, formatVersion, root2 = emptyHash, minSize = 8 * 1024, maxSize = 16 * 1024, getEntrySize = getSizeOfEntry, chunkHeaderSize) {
        super(dagWrite, formatVersion, root2, getEntrySize, chunkHeaderSize);
        this.minSize = minSize;
        this.maxSize = maxSize;
      }
      #addToModified(node) {
        assert3(node.isMutable);
        this.#modified.set(node.hash, node);
        this._cache.set(node.hash, node);
      }
      updateNode(node) {
        assert3(node.isMutable);
        this.#modified.delete(node.hash);
        node.hash = newRandomHash();
        this.#addToModified(node);
      }
      newInternalNodeImpl(entries, level) {
        const n2 = new InternalNodeImpl(entries, newRandomHash(), level, true);
        this.#addToModified(n2);
        return n2;
      }
      newDataNodeImpl(entries) {
        const n2 = new DataNodeImpl(entries, newRandomHash(), true);
        this.#addToModified(n2);
        return n2;
      }
      newNodeImpl(entries, level) {
        const n2 = newNodeImpl(entries, newRandomHash(), level, true);
        this.#addToModified(n2);
        return n2;
      }
      put(key2, value) {
        return this.#lock.withLock(async () => {
          const oldRootNode = await this.getNode(this.rootHash);
          const entrySize = this.getEntrySize(key2, value);
          const rootNode = await oldRootNode.set(key2, value, entrySize, this);
          if (rootNode.getChildNodeSize(this) > this.maxSize) {
            const headerSize = this.chunkHeaderSize;
            const partitions = partition(
              rootNode.entries,
              (value2) => value2[2],
              this.minSize - headerSize,
              this.maxSize - headerSize
            );
            const { level } = rootNode;
            const entries = partitions.map((entries2) => {
              const node = this.newNodeImpl(entries2, level);
              return createNewInternalEntryForNode(node, this.getEntrySize);
            });
            const newRoot = this.newInternalNodeImpl(entries, level + 1);
            this.rootHash = newRoot.hash;
            return;
          }
          this.rootHash = rootNode.hash;
        });
      }
      del(key2) {
        return this.#lock.withLock(async () => {
          const oldRootNode = await this.getNode(this.rootHash);
          const newRootNode = await oldRootNode.del(key2, this);
          const found = this.rootHash !== newRootNode.hash;
          if (found) {
            if (newRootNode.level > 0 && newRootNode.entries.length === 1) {
              this.rootHash = newRootNode.entries[0][1];
            } else {
              this.rootHash = newRootNode.hash;
            }
          }
          return found;
        });
      }
      clear() {
        return this.#lock.withLock(() => {
          this.#modified.clear();
          this.rootHash = emptyHash;
        });
      }
      flush() {
        return this.#lock.withLock(async () => {
          const dagWrite = this._dagRead;
          if (this.rootHash === emptyHash) {
            const chunk = dagWrite.createChunk(emptyDataNode, []);
            await dagWrite.putChunk(chunk);
            return chunk.hash;
          }
          const newChunks = [];
          const newRoot = gatherNewChunks(
            this.rootHash,
            newChunks,
            dagWrite.createChunk,
            this.#modified,
            this._formatVersion
          );
          await Promise.all(newChunks.map((chunk) => dagWrite.putChunk(chunk)));
          this.#modified.clear();
          this.rootHash = newRoot;
          return newRoot;
        });
      }
    };
    __name(gatherNewChunks, "gatherNewChunks");
    __name(lazy2, "lazy");
    DiffsMap = class extends Map {
      static {
        __name(this, "DiffsMap");
      }
      set(key2, value) {
        if (value.length === 0) {
          return this;
        }
        return super.set(key2, value);
      }
    };
    __name(diff2, "diff2");
    __name(diffCommits, "diffCommits");
    __name(addDiffsForIndexes, "addDiffsForIndexes");
    Write = class extends Read {
      static {
        __name(this, "Write");
      }
      #dagWrite;
      #basis;
      #meta;
      #clientID;
      #formatVersion;
      constructor(dagWrite, map, basis, meta, indexes, clientID, formatVersion) {
        super(dagWrite, map, indexes);
        this.#dagWrite = dagWrite;
        this.#basis = basis;
        this.#meta = meta;
        this.#clientID = clientID;
        this.#formatVersion = formatVersion;
        if (basis === void 0) {
          assert3(meta.basisHash === emptyHash);
        } else {
          assert3(meta.basisHash === basis.chunk.hash);
        }
      }
      /**
       * The value needs to be frozen since it is kept in memory and used later for
       * comparison as well as returned in `get`.
       */
      async put(lc, key2, value) {
        const oldVal = lazy2(() => this.map.get(key2));
        await updateIndexes(lc, this.indexes, key2, oldVal, value);
        await this.map.put(key2, value);
      }
      getMutationID() {
        return getMutationID(this.#clientID, this.#dagWrite, this.#meta);
      }
      async del(lc, key2) {
        const oldVal = lazy2(() => this.map.get(key2));
        if (oldVal !== void 0) {
          await updateIndexes(lc, this.indexes, key2, oldVal, void 0);
        }
        return this.map.del(key2);
      }
      async clear() {
        await this.map.clear();
        const ps = [];
        for (const idx of this.indexes.values()) {
          ps.push(idx.clear());
        }
        await Promise.all(ps);
      }
      async putCommit() {
        const valueHash = await this.map.flush();
        const indexRecords = [];
        for (const index10 of this.indexes.values()) {
          const valueHash2 = await index10.flush();
          const indexRecord = {
            definition: index10.meta.definition,
            valueHash: valueHash2
          };
          indexRecords.push(indexRecord);
        }
        let commit;
        const meta = this.#meta;
        switch (meta.type) {
          case LocalDD31: {
            assert3(this.#formatVersion >= DD31);
            const {
              basisHash,
              mutationID,
              mutatorName,
              mutatorArgsJSON,
              originalHash,
              timestamp: timestamp2
            } = meta;
            commit = newLocalDD31(
              this.#dagWrite.createChunk,
              basisHash,
              await baseSnapshotHashFromHash(basisHash, this.#dagWrite),
              mutationID,
              mutatorName,
              mutatorArgsJSON,
              originalHash,
              valueHash,
              indexRecords,
              timestamp2,
              this.#clientID
            );
            break;
          }
          case SnapshotDD31: {
            assert3(this.#formatVersion > DD31);
            const { basisHash, lastMutationIDs, cookieJSON } = meta;
            commit = newSnapshotDD31(
              this.#dagWrite.createChunk,
              basisHash,
              lastMutationIDs,
              cookieJSON,
              valueHash,
              indexRecords
            );
            break;
          }
        }
        await this.#dagWrite.putChunk(commit.chunk);
        return commit;
      }
      // Return value is the hash of the new commit.
      async commit(headName) {
        const commit = await this.putCommit();
        const commitHash = commit.chunk.hash;
        await this.#dagWrite.setHead(headName, commitHash);
        await this.#dagWrite.commit();
        return commitHash;
      }
      async commitWithDiffs(headName, diffConfig) {
        const commit = this.putCommit();
        const diffMap = await this.#generateDiffs(diffConfig);
        const commitHash = (await commit).chunk.hash;
        await this.#dagWrite.setHead(headName, commitHash);
        await this.#dagWrite.commit();
        return [commitHash, diffMap];
      }
      async #generateDiffs(diffConfig) {
        const diffsMap = new DiffsMap();
        if (!diffConfig.shouldComputeDiffs()) {
          return diffsMap;
        }
        let valueDiff = [];
        if (this.#basis) {
          const basisMap = new BTreeRead(
            this.#dagWrite,
            this.#formatVersion,
            this.#basis.valueHash
          );
          valueDiff = await diff(basisMap, this.map);
        }
        diffsMap.set("", valueDiff);
        let basisIndexes;
        if (this.#basis) {
          basisIndexes = readIndexesForRead(
            this.#basis,
            this.#dagWrite,
            this.#formatVersion
          );
        } else {
          basisIndexes = /* @__PURE__ */ new Map();
        }
        for (const [name, index10] of this.indexes) {
          if (!diffConfig.shouldComputeDiffsForIndex(name)) {
            continue;
          }
          const basisIndex = basisIndexes.get(name);
          assert3(index10 !== basisIndex);
          const indexDiffResult = await (basisIndex ? diff(basisIndex.map, index10.map) : (
            // No basis. All keys are new.
            allEntriesAsDiff(index10.map, "add")
          ));
          diffsMap.set(name, indexDiffResult);
        }
        for (const [name, basisIndex] of basisIndexes) {
          if (!this.indexes.has(name) && diffConfig.shouldComputeDiffsForIndex(name)) {
            const indexDiffResult = await allEntriesAsDiff(basisIndex.map, "del");
            diffsMap.set(name, indexDiffResult);
          }
        }
        return diffsMap;
      }
      close() {
        this.#dagWrite.release();
      }
    };
    __name(newWriteLocal, "newWriteLocal");
    __name(newWriteSnapshotDD31, "newWriteSnapshotDD31");
    __name(updateIndexes, "updateIndexes");
    __name(readIndexesForWrite, "readIndexesForWrite");
    __name(createIndexBTree, "createIndexBTree");
    __name(rebaseMutation, "rebaseMutation");
    __name(rebaseMutationAndPutCommit, "rebaseMutationAndPutCommit");
    __name(rebaseMutationAndCommit, "rebaseMutationAndCommit");
    __name(getDefaultPusher, "getDefaultPusher");
    defaultPushers = /* @__PURE__ */ new WeakSet();
    __name(isDefaultPusher, "isDefaultPusher");
    indexDefinitionSchema = readonlyObject({
      prefix: valita_exports.string().optional(),
      jsonPointer: valita_exports.string(),
      allowEmpty: valita_exports.boolean().optional()
    });
    indexDefinitionsSchema = readonlyRecord(
      indexDefinitionSchema
    );
    __name(indexDefinitionEqual, "indexDefinitionEqual");
    __name(indexDefinitionsEqual, "indexDefinitionsEqual");
    clientGroupSchema = readonlyObject({
      /**
       * The hash of the commit in the perdag last persisted to this client group.
       * Should only be updated by clients assigned to this client group.
       */
      headHash: hashSchema,
      /**
       * Set of mutator names common to all clients assigned to this client group.
       */
      mutatorNames: readonlyArray(valita_exports.string()),
      /**
       * Index definitions common to all clients assigned to this client group.
       */
      indexes: indexDefinitionsSchema,
      /**
       * The highest mutation ID of every client assigned to this client group.
       * Should only be updated by clients assigned to this client group. Read by
       * other clients to determine if there are unacknowledged pending mutations
       * for them to try to recover. This is redundant with information in the
       * commit graph at `headHash`, but allows other clients to determine if there
       * are unacknowledged pending mutations without having to load the commit
       * graph.
       */
      mutationIDs: readonlyRecord(valita_exports.number()),
      /**
       * The highest lastMutationID received from the server for every client
       * assigned to this client group.
       *
       * Should be updated by the clients assigned to this client group whenever
       * they persist to this client group. Read by other clients to determine if
       * there are unacknowledged pending mutations for them to recover and
       * *updated* by other clients upon successfully recovering pending mutations
       * to avoid redundant pushes of pending mutations.
       *
       * Note: This will be the same as the `lastMutationIDs` of the base snapshot
       * of the client group's commit graph when written by clients assigned to this
       * client group.  However, when written by another client recovering mutations
       * it may be different because the other client does not update the commit
       * graph.
       */
      lastServerAckdMutationIDs: valita_exports.record(valita_exports.number()),
      /**
       * If the server deletes this client group it can signal that the client group
       * was deleted. If that happens we mark this client group as disabled so that
       * we do not use it again when creating new clients.
       */
      disabled: valita_exports.boolean()
    });
    CLIENT_GROUPS_HEAD_NAME = "client-groups";
    __name(assertClientGroup, "assertClientGroup");
    __name(chunkDataToClientGroupMap, "chunkDataToClientGroupMap");
    __name(clientGroupMapToChunkData, "clientGroupMapToChunkData");
    __name(getClientGroupsAtHash, "getClientGroupsAtHash");
    __name(getClientGroups, "getClientGroups");
    __name(setClientGroups, "setClientGroups");
    __name(setClientGroup, "setClientGroup");
    __name(validateClientGroupUpdate, "validateClientGroupUpdate");
    __name(setValidatedClientGroups, "setValidatedClientGroups");
    __name(mutatorNamesEqual, "mutatorNamesEqual");
    __name(getClientGroup, "getClientGroup");
    __name(clientGroupHasPendingMutations, "clientGroupHasPendingMutations");
    __name(disableClientGroup, "disableClientGroup");
    __name(toError, "toError");
    __name(withRead, "withRead");
    __name(withWriteNoImplicitCommit, "withWriteNoImplicitCommit");
    __name(withWrite, "withWrite");
    __name(using, "using");
    Applied = 0;
    NoOp = 1;
    CookieMismatch = 2;
    __name(apply, "apply");
    PullError = class extends Error {
      static {
        __name(this, "PullError");
      }
      name = "PullError";
      // causedBy is used instead of cause, because while cause has been proposed as a
      // JavaScript language standard for this purpose (see
      // https://github.com/tc39/proposal-error-cause) current browser behavior is
      // inconsistent.
      causedBy;
      constructor(causedBy) {
        super("Failed to pull");
        this.causedBy = causedBy;
      }
    };
    SYNC_HEAD_NAME = "sync";
    PULL_VERSION_DD31 = 1;
    __name(beginPullV1, "beginPullV1");
    __name(callPuller, "callPuller");
    __name(badOrderMessage, "badOrderMessage");
    __name(handlePullResponseV1, "handlePullResponseV1");
    __name(maybeEndPull, "maybeEndPull");
    path = [];
    jsonSchema = valita_exports.unknown().chain((v2) => {
      if (isProd) {
        return ok(v2);
      }
      const rv = isJSONValue(v2, path) ? ok(v2) : err({
        message: `Not a JSON value`,
        path: path.slice()
      });
      path.length = 0;
      return rv;
    });
    jsonObjectSchema = valita_exports.unknown().chain((v2) => {
      if (isProd) {
        return ok(v2);
      }
      const rv = isJSONObject(v2, path) ? ok(v2) : err({
        message: `Not a JSON object`,
        path: path.slice()
      });
      path.length = 0;
      return rv;
    });
    __name(assertPusherResult, "assertPusherResult");
    __name(assertPushResponse, "assertPushResponse");
    PushError = class extends Error {
      static {
        __name(this, "PushError");
      }
      name = "PushError";
      // causedBy is used instead of cause, because while cause has been proposed as a
      // JavaScript language standard for this purpose (see
      // https://github.com/tc39/proposal-error-cause) current browser behavior is
      // inconsistent.
      causedBy;
      constructor(causedBy) {
        super("Failed to push");
        this.causedBy = causedBy;
      }
    };
    clientGroupIDSchema = valita_exports.string();
    clientIDSchema = valita_exports.string();
    PUSH_VERSION_DD31 = 1;
    mutationV1Schema = readonlyObject({
      id: valita_exports.number(),
      name: valita_exports.string(),
      args: jsonSchema,
      timestamp: valita_exports.number(),
      clientID: clientIDSchema
    });
    pushRequestV1Schema = valita_exports.object({
      pushVersion: valita_exports.literal(1),
      schemaVersion: valita_exports.string(),
      profileID: valita_exports.string(),
      clientGroupID: clientGroupIDSchema,
      mutations: valita_exports.array(mutationV1Schema)
    });
    __name(convertDD31, "convertDD31");
    __name(push3, "push");
    __name(callPusher, "callPusher");
    MUTATION_RECOVERY_LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT = 10 * 2 ** 20;
    NoopBroadcastChannel = class {
      static {
        __name(this, "NoopBroadcastChannel");
      }
      name;
      onmessage = null;
      onmessageerror = null;
      constructor(name) {
        this.name = name;
      }
      addEventListener() {
      }
      removeEventListener() {
      }
      dispatchEvent() {
        return false;
      }
      close() {
      }
      postMessage() {
      }
    };
    bc = typeof BroadcastChannel === "undefined" ? NoopBroadcastChannel : BroadcastChannel;
    __name(makeChannelNameV0, "makeChannelNameV0");
    __name(makeChannelNameV1, "makeChannelNameV1");
    __name(isNewClientChannelMessageV1, "isNewClientChannelMessageV1");
    __name(initNewClientChannel, "initNewClientChannel");
    __name(makeChannelName, "makeChannelName");
    __name(assertPersistInfo, "assertPersistInfo");
    __name(initOnPersistChannel, "initOnPersistChannel");
    __name(pendingMutationsForAPI, "pendingMutationsForAPI");
    __name(makeClientID, "makeClientID");
    clientV5Schema = readonlyObject({
      heartbeatTimestampMs: valita_exports.number(),
      headHash: hashSchema,
      /**
       * The hash of a commit we are in the middle of refreshing into this client's
       * memdag.
       */
      tempRefreshHash: hashSchema.nullable(),
      /**
       * ID of this client's perdag client group. This needs to be sent in pull
       * request (to enable syncing all last mutation ids in the client group).
       */
      clientGroupID: clientGroupIDSchema
    });
    clientV6Schema = readonlyObject({
      heartbeatTimestampMs: valita_exports.number(),
      /**
       * A set of hashes, which contains:
       * 1. The hash of the last commit this client refreshed from its client group
       *    (this is the commit it bootstrapped from until it completes its first
       *    refresh).
       * 2. One or more hashes that were added to retain chunks of a commit while it
       *    was being refreshed into this client's memdag. (This can be one or more
       *    because refresh's cleanup step is a separate transaction and can fail).
       * Upon refresh completing and successfully running its clean up step, this
       * set will contain a single hash: the hash of the last commit this client
       * refreshed.
       */
      refreshHashes: readonlyArray(hashSchema),
      /**
       * The hash of the last snapshot commit persisted by this client to this
       * client's client group, or null if has never persisted a snapshot.
       */
      persistHash: hashSchema.nullable(),
      /**
       * ID of this client's perdag client group. This needs to be sent in pull
       * request (to enable syncing all last mutation ids in the client group).
       */
      clientGroupID: clientGroupIDSchema
    });
    __name(isClientV6, "isClientV6");
    CLIENTS_HEAD_NAME = "clients";
    clientSchema = valita_exports.union(clientV5Schema, clientV6Schema);
    __name(assertClient, "assertClient");
    __name(assertClientV6, "assertClientV6");
    __name(chunkDataToClientMap, "chunkDataToClientMap");
    __name(clientMapToChunkData, "clientMapToChunkData");
    __name(getClients, "getClients");
    __name(getClientsAtHash, "getClientsAtHash");
    ClientStateNotFoundError = class extends Error {
      static {
        __name(this, "ClientStateNotFoundError");
      }
      name = "ClientStateNotFoundError";
      id;
      constructor(id) {
        super(`Client state not found, id: ${id}`);
        this.id = id;
      }
    };
    __name(assertHasClientState, "assertHasClientState");
    __name(hasClientState, "hasClientState");
    __name(getClient, "getClient");
    __name(mustGetClient, "mustGetClient");
    __name(initClientV6, "initClientV6");
    __name(findMatchingOldIndex, "findMatchingOldIndex");
    FIND_MATCHING_CLIENT_TYPE_NEW = 0;
    FIND_MATCHING_CLIENT_TYPE_FORK = 1;
    FIND_MATCHING_CLIENT_TYPE_HEAD = 2;
    __name(findMatchingClient, "findMatchingClient");
    __name(getRefsForClients, "getRefsForClients");
    __name(getClientGroupForClient, "getClientGroupForClient");
    __name(getClientGroupIDForClient, "getClientGroupIDForClient");
    __name(setClient, "setClient");
    __name(setClients, "setClients");
    CLIENT_MAX_INACTIVE_TIME = 24 * 60 * 60 * 1e3;
    GC_INTERVAL = 5 * 60 * 1e3;
    __name(initClientGC, "initClientGC");
    __name(gcClients, "gcClients");
    GC_INTERVAL_MS = 5 * 60 * 1e3;
    __name(initClientGroupGC, "initClientGroupGC");
    __name(gcClientGroups, "gcClientGroups");
    HEARTBEAT_INTERVAL = 60 * 1e3;
    __name(startHeartbeats, "startHeartbeats");
    __name(writeHeartbeat, "writeHeartbeat");
    IDB_DATABASES_VERSION = 0;
    IDB_DATABASES_DB_NAME = "replicache-dbs-v" + IDB_DATABASES_VERSION;
    testNamespace = "";
    __name(getIDBDatabasesDBName, "getIDBDatabasesDBName");
    DBS_KEY = "dbs";
    PROFILE_ID_KEY = "profileId";
    __name(assertIndexedDBDatabaseRecord, "assertIndexedDBDatabaseRecord");
    __name(assertIndexedDBDatabase, "assertIndexedDBDatabase");
    IDBDatabasesStore = class {
      static {
        __name(this, "IDBDatabasesStore");
      }
      #kvStore;
      constructor(createKVStore) {
        this.#kvStore = createKVStore(getIDBDatabasesDBName());
      }
      putDatabase(db2) {
        return this.#putDatabase({ ...db2, lastOpenedTimestampMS: Date.now() });
      }
      putDatabaseForTesting(db2) {
        return this.#putDatabase(db2);
      }
      #putDatabase(db2) {
        return withWrite(this.#kvStore, async (write) => {
          const oldDbRecord = await getDatabases(write);
          const dbRecord = {
            ...oldDbRecord,
            [db2.name]: db2
          };
          await write.put(DBS_KEY, dbRecord);
          return dbRecord;
        });
      }
      clearDatabases() {
        return withWrite(this.#kvStore, (write) => write.del(DBS_KEY));
      }
      deleteDatabases(names) {
        return withWrite(this.#kvStore, async (write) => {
          const oldDbRecord = await getDatabases(write);
          const dbRecord = {
            ...oldDbRecord
          };
          for (const name of names) {
            delete dbRecord[name];
          }
          await write.put(DBS_KEY, dbRecord);
        });
      }
      getDatabases() {
        return withRead(this.#kvStore, getDatabases);
      }
      close() {
        return this.#kvStore.close();
      }
      getProfileID() {
        return withWrite(this.#kvStore, async (write) => {
          let profileId = await write.get(PROFILE_ID_KEY);
          if (profileId === void 0) {
            profileId = `p${makeClientID()}`;
            await write.put(PROFILE_ID_KEY, profileId);
          }
          assertString(profileId);
          return profileId;
        });
      }
    };
    __name(getDatabases, "getDatabases");
    Visitor = class {
      static {
        __name(this, "Visitor");
      }
      #seen = /* @__PURE__ */ new Set();
      #dagRead;
      constructor(dagRead) {
        this.#dagRead = dagRead;
      }
      async visit(h) {
        if (this.#seen.has(h)) {
          return;
        }
        this.#seen.add(h);
        const chunk = await this.#dagRead.mustGetChunk(h);
        await this.visitChunk(chunk);
      }
      async visitChunk(chunk) {
        await Promise.all(chunk.meta.map((ref) => this.visit(ref)));
      }
    };
    GatherMemoryOnlyVisitor = class extends Visitor {
      static {
        __name(this, "GatherMemoryOnlyVisitor");
      }
      #gatheredChunks = /* @__PURE__ */ new Map();
      #lazyRead;
      constructor(dagRead) {
        super(dagRead);
        this.#lazyRead = dagRead;
      }
      get gatheredChunks() {
        return this.#gatheredChunks;
      }
      visit(h) {
        if (!this.#lazyRead.isMemOnlyChunkHash(h)) {
          return promiseVoid;
        }
        return super.visit(h);
      }
      visitChunk(chunk) {
        this.#gatheredChunks.set(chunk.hash, chunk);
        return super.visitChunk(chunk);
      }
    };
    __name(persistDD31, "persistDD31");
    __name(getClientGroupInfo, "getClientGroupInfo");
    __name(rebase, "rebase");
    GatherNotCachedVisitor = class extends Visitor {
      static {
        __name(this, "GatherNotCachedVisitor");
      }
      #gatheredChunks = /* @__PURE__ */ new Map();
      #gatheredChunksTotalSize = 0;
      #lazyStore;
      #gatherSizeLimit;
      #getSizeOfChunk;
      constructor(dagRead, lazyStore, gatherSizeLimit, getSizeOfChunk = getSizeOfValue) {
        super(dagRead);
        this.#lazyStore = lazyStore;
        this.#gatherSizeLimit = gatherSizeLimit;
        this.#getSizeOfChunk = getSizeOfChunk;
      }
      get gatheredChunks() {
        return this.#gatheredChunks;
      }
      visit(h) {
        if (this.#gatheredChunksTotalSize >= this.#gatherSizeLimit || this.#lazyStore.isCached(h)) {
          return promiseVoid;
        }
        return super.visit(h);
      }
      visitChunk(chunk) {
        if (this.#gatheredChunksTotalSize < this.#gatherSizeLimit) {
          const size2 = this.#getSizeOfChunk(chunk);
          this.#gatheredChunks.set(chunk.hash, { chunk, size: size2 });
          this.#gatheredChunksTotalSize += size2;
        }
        return super.visitChunk(chunk);
      }
    };
    GATHER_SIZE_LIMIT = 5 * 2 ** 20;
    DELAY_MS = 300;
    __name(refresh, "refresh");
    __name(shouldAbortRefresh, "shouldAbortRefresh");
    __name(requestIdle, "requestIdle");
    ProcessScheduler = class {
      static {
        __name(this, "ProcessScheduler");
      }
      #process;
      #idleTimeoutMs;
      #throttleMs;
      #abortSignal;
      #requestIdle;
      #scheduledResolver = void 0;
      #runResolver = void 0;
      #runPromise = Promise.resolve();
      #throttlePromise = Promise.resolve();
      /**
       * Supports scheduling a `process` to be run with certain constraints.
       *  - Process runs are never concurrent.
       *  - Multiple calls to schedule will be fulfilled by a single process
       *    run started after the call to schedule.  A call is never fulfilled by an
       *    already running process run.  This can be thought of as debouncing.
       *  - Process runs are throttled so that the process runs at most once every
       *    `throttleMs`.
       *  - Process runs try to run during an idle period, but will delay at most
       *    `idleTimeoutMs`.
       *  - Scheduled runs which have not completed when `abortSignal` is aborted
       *    will reject with an `AbortError`.
       */
      constructor(process22, idleTimeoutMs, throttleMs, abortSignal, requestIdle2 = requestIdle) {
        this.#process = process22;
        this.#idleTimeoutMs = idleTimeoutMs;
        this.#throttleMs = throttleMs;
        this.#abortSignal = abortSignal;
        this.#requestIdle = requestIdle2;
        this.#abortSignal.addEventListener(
          "abort",
          () => {
            const abortError = new AbortError("Aborted");
            this.#runResolver?.reject(abortError);
            this.#scheduledResolver?.reject(abortError);
            this.#runResolver = void 0;
            this.#scheduledResolver = void 0;
          },
          { once: true }
        );
      }
      schedule() {
        if (this.#abortSignal.aborted) {
          return Promise.reject(new AbortError("Aborted"));
        }
        if (this.#scheduledResolver) {
          return this.#scheduledResolver.promise;
        }
        this.#scheduledResolver = resolver();
        void this.#scheduleInternal();
        return this.#scheduledResolver.promise;
      }
      async #scheduleInternal() {
        try {
          await this.#runPromise;
        } catch (e3) {
        }
        await this.#throttlePromise;
        if (!this.#scheduledResolver) {
          return;
        }
        await this.#requestIdle(this.#idleTimeoutMs);
        if (!this.#scheduledResolver) {
          return;
        }
        this.#throttlePromise = throttle(this.#throttleMs, this.#abortSignal);
        this.#runResolver = this.#scheduledResolver;
        this.#scheduledResolver = void 0;
        try {
          this.#runPromise = this.#process();
          await this.#runPromise;
          this.#runResolver?.resolve();
        } catch (e3) {
          this.#runResolver?.reject(e3);
        }
        this.#runResolver = void 0;
      }
    };
    __name(throttle, "throttle");
    __name(setIntervalWithSignal, "setIntervalWithSignal");
    InitialRun = 0;
    Regular = 1;
    emptySet = /* @__PURE__ */ new Set();
    unitializedLastValue = Symbol();
    SubscriptionImpl = class {
      static {
        __name(this, "SubscriptionImpl");
      }
      #body;
      #onData;
      #lastValue = unitializedLastValue;
      #keys = emptySet;
      #scans = [];
      onError;
      onDone;
      #isEqual;
      constructor(body2, onData, onError, onDone, isEqual = deepEqual) {
        this.#body = body2;
        this.#onData = onData;
        this.onError = onError;
        this.onDone = onDone;
        this.#isEqual = isEqual;
      }
      hasIndexSubscription(indexName) {
        for (const scan2 of this.#scans) {
          if (scan2.options.indexName === indexName) {
            return true;
          }
        }
        return false;
      }
      invoke(tx, _kind, _diffs) {
        return this.#body(tx);
      }
      matches(diffs) {
        for (const [indexName, diff3] of diffs) {
          if (diffMatchesSubscription(this.#keys, this.#scans, indexName, diff3)) {
            return true;
          }
        }
        return false;
      }
      updateDeps(keys, scans) {
        this.#keys = keys;
        this.#scans = scans;
      }
      onData(result) {
        if (this.#lastValue === unitializedLastValue || !this.#isEqual(this.#lastValue, result)) {
          this.#lastValue = result;
          this.#onData(result);
        }
      }
    };
    WatchSubscription = class {
      static {
        __name(this, "WatchSubscription");
      }
      #callback;
      #prefix;
      #indexName;
      #initialValuesInFirstDiff;
      onError = void 0;
      onDone = void 0;
      constructor(callback, options2) {
        this.#callback = callback;
        this.#prefix = options2?.prefix ?? "";
        this.#indexName = options2?.indexName;
        this.#initialValuesInFirstDiff = options2?.initialValuesInFirstDiff ?? false;
      }
      hasIndexSubscription(indexName) {
        return this.#indexName === indexName;
      }
      onData(result) {
        if (result !== void 0) {
          this.#callback(result);
        }
      }
      invoke(tx, kind, diffs) {
        const invoke = /* @__PURE__ */ __name(async (indexName, prefix, compareKey, convertInternalDiff) => {
          let diff3;
          if (kind === InitialRun) {
            if (!this.#initialValuesInFirstDiff) {
              return void 0;
            }
            assert3(diffs === void 0);
            const newDiff2 = [];
            for await (const entry of tx.scan({ prefix, indexName }).entries()) {
              newDiff2.push({
                op: "add",
                key: entry[0],
                newValue: entry[1]
              });
            }
            diff3 = newDiff2;
          } else {
            assert3(diffs);
            const maybeDiff = diffs.get(indexName ?? "") ?? [];
            diff3 = convertInternalDiff(maybeDiff);
          }
          const newDiff = [];
          const { length } = diff3;
          for (let i = diffBinarySearch(diff3, prefix, compareKey); i < length; i++) {
            if (compareKey(diff3[i]).startsWith(prefix)) {
              newDiff.push(diff3[i]);
            } else {
              break;
            }
          }
          return kind === InitialRun || newDiff.length > 0 ? newDiff : void 0;
        }, "invoke");
        if (this.#indexName) {
          return invoke(
            this.#indexName,
            this.#prefix,
            (diff3) => diff3.key[0],
            (internalDiff) => convertDiffValues(internalDiff, decodeIndexKey)
          );
        }
        return invoke(
          void 0,
          this.#prefix,
          (diff3) => diff3.key,
          (internalDiff) => convertDiffValues(internalDiff, (k) => k)
        );
      }
      matches(diffs) {
        const diff3 = diffs.get(this.#indexName ?? "");
        if (diff3 === void 0) {
          return false;
        }
        return watcherMatchesDiff(diff3, this.#prefix, this.#indexName);
      }
      updateDeps(_keys, _scans) {
      }
    };
    __name(convertDiffValues, "convertDiffValues");
    SubscriptionsManagerImpl = class {
      static {
        __name(this, "SubscriptionsManagerImpl");
      }
      #subscriptions = /* @__PURE__ */ new Set();
      #pendingSubscriptions = /* @__PURE__ */ new Set();
      #queryInternal;
      #lc;
      hasPendingSubscriptionRuns = false;
      #signal;
      constructor(queryInternal, lc, signal) {
        this.#queryInternal = queryInternal;
        this.#lc = lc;
        this.#signal = signal;
      }
      add(subscription) {
        this.#subscriptions.add(subscription);
        void this.#scheduleInitialSubscriptionRun(
          subscription
        );
        return () => this.#subscriptions.delete(subscription);
      }
      clear() {
        for (const subscription of this.#subscriptions) {
          subscription.onDone?.();
        }
        this.#subscriptions.clear();
      }
      fire(diffs) {
        const subscriptions = subscriptionsForDiffs(this.#subscriptions, diffs);
        return this.#fireSubscriptions(subscriptions, Regular, diffs);
      }
      async #fireSubscriptions(subscriptions, kind, diffs) {
        if (this.#signal.aborted) {
          return;
        }
        const subs = [...subscriptions];
        if (subs.length === 0) {
          return;
        }
        const results = await this.#queryInternal(
          (tx) => Promise.allSettled(
            subs.map(async (s3) => {
              const stx = new SubscriptionTransactionWrapper(tx);
              try {
                return await s3.invoke(stx, kind, diffs);
              } finally {
                s3.updateDeps(stx.keys, stx.scans);
              }
            })
          )
        );
        this.callCallbacks(subs, results);
      }
      // Public method so that ZQL can wrap it in a transaction.
      callCallbacks(subs, results) {
        for (let i = 0; i < subs.length; i++) {
          const s3 = subs[i];
          const result = results[i];
          if (result.status === "fulfilled") {
            s3.onData(result.value);
          } else {
            if (s3.onError) {
              s3.onError(result.reason);
            } else {
              this.#lc.error?.("Error in subscription body:", result.reason);
            }
          }
        }
      }
      async #scheduleInitialSubscriptionRun(s3) {
        this.#pendingSubscriptions.add(s3);
        if (!this.hasPendingSubscriptionRuns) {
          this.hasPendingSubscriptionRuns = true;
          await Promise.resolve();
          this.hasPendingSubscriptionRuns = false;
          const subscriptions = [...this.#pendingSubscriptions];
          this.#pendingSubscriptions.clear();
          await this.#fireSubscriptions(
            subscriptions,
            InitialRun,
            void 0
          );
        }
      }
      shouldComputeDiffs() {
        return this.#subscriptions.size > 0;
      }
      shouldComputeDiffsForIndex(indexName) {
        for (const s3 of this.#subscriptions) {
          if (s3.hasIndexSubscription(indexName)) {
            return true;
          }
        }
        return false;
      }
    };
    __name(diffMatchesSubscription, "diffMatchesSubscription");
    __name(scanInfoMatchesDiff, "scanInfoMatchesDiff");
    __name(scanInfoMatchesKey, "scanInfoMatchesKey");
    __name(isKeyPastInclusiveLimit, "isKeyPastInclusiveLimit");
    __name(subscriptionsForDiffs, "subscriptionsForDiffs");
    __name(watcherMatchesDiff, "watcherMatchesDiff");
    __name(diffBinarySearch, "diffBinarySearch");
    __name(getNonCryptoRandomValues, "getNonCryptoRandomValues");
    sessionID = "";
    __name(getSessionID, "getSessionID");
    REQUEST_COUNTERS = /* @__PURE__ */ new Map();
    __name(newRequestID, "newRequestID");
    version3 = "15.2.1";
    MAX_REAUTH_TRIES = 8;
    PERSIST_IDLE_TIMEOUT_MS = 1e3;
    REFRESH_IDLE_TIMEOUT_MS = 1e3;
    PERSIST_THROTTLE_MS = 500;
    REFRESH_THROTTLE_MS = 500;
    LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT = 100 * 2 ** 20;
    RECOVER_MUTATIONS_INTERVAL_MS = 5 * 60 * 1e3;
    noop22 = /* @__PURE__ */ __name(() => {
    }, "noop2");
    updateNeededReasonNewClientGroup = {
      type: "NewClientGroup"
    };
    ReplicacheImpl = class {
      static {
        __name(this, "ReplicacheImpl");
      }
      /** The URL to use when doing a pull request. */
      pullURL;
      /** The URL to use when doing a push request. */
      pushURL;
      /** The authorization token used when doing a push request. */
      auth;
      /** The name of the Replicache database. Populated by {@link ReplicacheOptions#name}. */
      name;
      #subscriptions;
      #mutationRecovery;
      /**
       * Client groups gets disabled when the server does not know about it.
       * A disabled client group prevents the client from pushing and pulling.
       */
      isClientGroupDisabled = false;
      #kvStoreProvider;
      lastMutationID = 0;
      /**
       * This is the name Replicache uses for the IndexedDB database where data is
       * stored.
       */
      get idbName() {
        return makeIDBName(this.name, this.schemaVersion);
      }
      /** The schema version of the data understood by this application. */
      schemaVersion;
      get #idbDatabase() {
        return {
          name: this.idbName,
          replicacheName: this.name,
          replicacheFormatVersion: Latest,
          schemaVersion: this.schemaVersion
        };
      }
      #closed = false;
      #online = true;
      #clientID = makeClientID();
      #ready;
      #profileIDPromise;
      #clientGroupIDPromise;
      #mutatorRegistry = {};
      /**
       * The mutators that was registered in the constructor.
       */
      mutate;
      // Number of pushes/pulls at the moment.
      #pushCounter = 0;
      #pullCounter = 0;
      #pullConnectionLoop;
      #pushConnectionLoop;
      /**
       * The duration between each periodic {@link pull}. Setting this to `null`
       * disables periodic pull completely. Pull will still happen if you call
       * {@link pull} manually.
       */
      pullInterval;
      /**
       * The delay between when a change is made to Replicache and when Replicache
       * attempts to push that change.
       */
      pushDelay;
      #requestOptions;
      /**
       * The function to use to pull data from the server.
       */
      puller;
      /**
       * The function to use to push data to the server.
       */
      pusher;
      memdag;
      perdag;
      #idbDatabases;
      #lc;
      #zero;
      #closeAbortController = new AbortController();
      #persistLock = new Lock();
      #enableScheduledPersist;
      #enableScheduledRefresh;
      #enablePullAndPushInOpen;
      #persistScheduler = new ProcessScheduler(
        () => this.persist(),
        PERSIST_IDLE_TIMEOUT_MS,
        PERSIST_THROTTLE_MS,
        this.#closeAbortController.signal
      );
      #onPersist;
      #refreshScheduler = new ProcessScheduler(
        () => this.refresh(),
        REFRESH_IDLE_TIMEOUT_MS,
        REFRESH_THROTTLE_MS,
        this.#closeAbortController.signal
      );
      /**
       * The options used to control the {@link pull} and push request behavior. This
       * object is live so changes to it will affect the next pull or push call.
       */
      get requestOptions() {
        return this.#requestOptions;
      }
      /**
       * `onSync(true)` is called when Replicache transitions from no push or pull
       * happening to at least one happening. `onSync(false)` is called in the
       * opposite case: when Replicache transitions from at least one push or pull
       * happening to none happening.
       *
       * This can be used in a React like app by doing something like the following:
       *
       * ```js
       * const [syncing, setSyncing] = useState(false);
       * useEffect(() => {
       *   rep.onSync = setSyncing;
       * }, [rep]);
       * ```
       */
      onSync = null;
      /**
       * `onClientStateNotFound` is called when the persistent client has been
       * garbage collected. This can happen if the client has no pending mutations
       * and has not been used for a while.
       *
       * The default behavior is to reload the page (using `location.reload()`). Set
       * this to `null` or provide your own function to prevent the page from
       * reloading automatically.
       */
      onClientStateNotFound = reload;
      /**
       * `onUpdateNeeded` is called when a code update is needed.
       *
       * A code update can be needed because:
       * - the server no longer supports the {@link pushVersion},
       *   {@link pullVersion} or {@link schemaVersion} of the current code.
       * - a new Replicache client has created a new client group, because its code
       *   has different mutators, indexes, schema version and/or format version
       *   from this Replicache client. This is likely due to the new client having
       *   newer code. A code update is needed to be able to locally sync with this
       *   new Replicache client (i.e. to sync while offline, the clients can still
       *   sync with each other via the server).
       *
       * The default behavior is to reload the page (using `location.reload()`). Set
       * this to `null` or provide your own function to prevent the page from
       * reloading automatically. You may want to provide your own function to
       * display a toast to inform the end user there is a new version of your app
       * available and prompting them to refresh.
       */
      onUpdateNeeded = reload;
      /**
       * This gets called when we get an HTTP unauthorized (401) response from the
       * push or pull endpoint. Set this to a function that will ask your user to
       * reauthenticate.
       */
      getAuth = null;
      // These three are used for testing
      onPushInvoked = /* @__PURE__ */ __name(() => void 0, "onPushInvoked");
      onBeginPull = /* @__PURE__ */ __name(() => void 0, "onBeginPull");
      onRecoverMutations = /* @__PURE__ */ __name((r3) => r3, "onRecoverMutations");
      constructor(options2, implOptions = {}) {
        validateOptions(options2);
        const {
          name,
          logLevel = "info",
          logSinks = [consoleLogSink],
          pullURL = "",
          auth,
          pushDelay = 10,
          pushURL = "",
          schemaVersion = "",
          pullInterval = 6e4,
          mutators = {},
          requestOptions = {},
          puller,
          pusher,
          indexes = {},
          clientMaxAgeMs = CLIENT_MAX_INACTIVE_TIME
        } = options2;
        const {
          enableMutationRecovery = true,
          enableScheduledPersist = true,
          enableScheduledRefresh = true,
          enablePullAndPushInOpen = true,
          enableClientGroupForking = true,
          onClientsDeleted = /* @__PURE__ */ __name(() => {
          }, "onClientsDeleted")
        } = implOptions;
        this.#zero = implOptions.zero;
        this.auth = auth ?? "";
        this.pullURL = pullURL;
        this.pushURL = pushURL;
        this.name = name;
        this.schemaVersion = schemaVersion;
        this.pullInterval = pullInterval;
        this.pushDelay = pushDelay;
        this.puller = puller ?? getDefaultPuller(this);
        this.pusher = pusher ?? getDefaultPusher(this);
        this.#enableScheduledPersist = enableScheduledPersist;
        this.#enableScheduledRefresh = enableScheduledRefresh;
        this.#enablePullAndPushInOpen = enablePullAndPushInOpen;
        this.#lc = createLogContext(logLevel, logSinks, { name });
        this.#lc.debug?.("Constructing Replicache", {
          name,
          "replicache version": version3
        });
        this.#subscriptions = new SubscriptionsManagerImpl(
          this.#queryInternal,
          this.#lc,
          this.#closeAbortController.signal
        );
        const kvStoreProvider = getKVStoreProvider(this.#lc, options2.kvStore);
        this.#kvStoreProvider = kvStoreProvider;
        const perKVStore = kvStoreProvider.create(this.idbName);
        this.#idbDatabases = new IDBDatabasesStore(kvStoreProvider.create);
        this.perdag = new StoreImpl(perKVStore, newRandomHash, assertHash);
        this.memdag = new LazyStore(
          this.perdag,
          LAZY_STORE_SOURCE_CHUNK_CACHE_SIZE_LIMIT,
          newRandomHash,
          assertHash
        );
        const readyResolver = resolver();
        this.#ready = readyResolver.promise;
        const { minDelayMs = MIN_DELAY_MS, maxDelayMs = MAX_DELAY_MS } = requestOptions;
        this.#requestOptions = { maxDelayMs, minDelayMs };
        const visibilityWatcher = getDocumentVisibilityWatcher(
          getBrowserGlobal("document"),
          0,
          this.#closeAbortController.signal
        );
        this.#pullConnectionLoop = new ConnectionLoop(
          this.#lc.withContext("PULL"),
          new PullDelegate(this, () => this.#invokePull()),
          visibilityWatcher
        );
        this.#pushConnectionLoop = new ConnectionLoop(
          this.#lc.withContext("PUSH"),
          new PushDelegate(this, () => this.#invokePush())
        );
        this.mutate = this.#registerMutators(mutators);
        const profileIDResolver = resolver();
        this.#profileIDPromise = profileIDResolver.promise;
        const clientGroupIDResolver = resolver();
        this.#clientGroupIDPromise = clientGroupIDResolver.promise;
        if (false) {
          this.#mutationRecovery = new MutationRecovery({
            delegate: this,
            lc: this.#lc,
            enableMutationRecovery,
            wrapInOnlineCheck: this.#wrapInOnlineCheck.bind(this),
            wrapInReauthRetries: this.#wrapInReauthRetries.bind(this),
            isPullDisabled: this.#isPullDisabled.bind(this),
            isPushDisabled: this.#isPushDisabled.bind(this),
            clientGroupIDPromise: this.#clientGroupIDPromise
          });
        }
        this.#onPersist = initOnPersistChannel(
          this.name,
          this.#closeAbortController.signal,
          (persistInfo) => {
            void this.#handlePersist(persistInfo);
          }
        );
        void this.#open(
          indexes,
          enableClientGroupForking,
          enableMutationRecovery,
          clientMaxAgeMs,
          profileIDResolver.resolve,
          clientGroupIDResolver.resolve,
          readyResolver.resolve,
          onClientsDeleted
        );
      }
      async #open(indexes, enableClientGroupForking, enableMutationRecovery, clientMaxAgeMs, profileIDResolver, resolveClientGroupID, resolveReady, onClientsDeleted) {
        const { clientID } = this;
        await closingInstances.get(this.name);
        await this.#idbDatabases.getProfileID().then(profileIDResolver);
        await this.#idbDatabases.putDatabase(this.#idbDatabase);
        const [client2, headHash, , isNewClientGroup] = await initClientV6(
          clientID,
          this.#lc,
          this.perdag,
          Object.keys(this.#mutatorRegistry),
          indexes,
          Latest,
          enableClientGroupForking
        );
        resolveClientGroupID(client2.clientGroupID);
        await withWrite(
          this.memdag,
          (write) => write.setHead(DEFAULT_HEAD_NAME, headHash)
        );
        await this.#zero?.init(headHash, this.memdag);
        resolveReady();
        if (this.#enablePullAndPushInOpen) {
          this.pull().catch(noop22);
          this.push().catch(noop22);
        }
        const { signal } = this.#closeAbortController;
        startHeartbeats(
          clientID,
          this.perdag,
          () => {
            this.#clientStateNotFoundOnClient(clientID);
          },
          HEARTBEAT_INTERVAL,
          this.#lc,
          signal
        );
        initClientGC(
          clientID,
          this.perdag,
          clientMaxAgeMs,
          GC_INTERVAL,
          onClientsDeleted,
          this.#lc,
          signal
        );
        initCollectIDBDatabases(
          this.#idbDatabases,
          this.#kvStoreProvider.drop,
          COLLECT_IDB_INTERVAL,
          INITIAL_COLLECT_IDB_DELAY,
          2 * clientMaxAgeMs,
          enableMutationRecovery,
          onClientsDeleted,
          this.#lc,
          signal
        );
        initClientGroupGC(
          this.perdag,
          enableMutationRecovery,
          onClientsDeleted,
          this.#lc,
          signal
        );
        initNewClientChannel(
          this.name,
          this.idbName,
          signal,
          client2.clientGroupID,
          isNewClientGroup,
          () => {
            this.#fireOnUpdateNeeded(updateNeededReasonNewClientGroup);
          },
          this.perdag
        );
        setIntervalWithSignal(
          () => this.recoverMutations(),
          RECOVER_MUTATIONS_INTERVAL_MS,
          signal
        );
        void this.recoverMutations();
        getBrowserGlobal("document")?.addEventListener(
          "visibilitychange",
          this.#onVisibilityChange
        );
      }
      #onVisibilityChange = /* @__PURE__ */ __name(async () => {
        if (this.#closed) {
          return;
        }
        if (getBrowserGlobal("document")?.visibilityState !== "visible") {
          return;
        }
        await this.#checkForClientStateNotFoundAndCallHandler();
      }, "#onVisibilityChange");
      async #checkForClientStateNotFoundAndCallHandler() {
        const { clientID } = this;
        const hasClientState2 = await withRead(
          this.perdag,
          (read) => hasClientState(clientID, read)
        );
        if (!hasClientState2) {
          this.#clientStateNotFoundOnClient(clientID);
        }
        return !hasClientState2;
      }
      /**
       * The browser profile ID for this browser profile. Every instance of Replicache
       * browser-profile-wide shares the same profile ID.
       */
      get profileID() {
        return this.#profileIDPromise;
      }
      /**
       * The client ID for this instance of Replicache. Each instance of Replicache
       * gets a unique client ID.
       */
      get clientID() {
        return this.#clientID;
      }
      /**
       * The client group ID for this instance of Replicache. Instances of
       * Replicache will have the same client group ID if and only if they have
       * the same name, mutators, indexes, schema version, format version, and
       * browser profile.
       */
      get clientGroupID() {
        return this.#clientGroupIDPromise;
      }
      /**
       * `onOnlineChange` is called when the {@link online} property changes. See
       * {@link online} for more details.
       */
      onOnlineChange = null;
      /**
       * A rough heuristic for whether the client is currently online. Note that
       * there is no way to know for certain whether a client is online - the next
       * request can always fail. This property returns true if the last sync attempt succeeded,
       * and false otherwise.
       */
      get online() {
        return this.#online;
      }
      /**
       * Whether the Replicache database has been closed. Once Replicache has been
       * closed it no longer syncs and you can no longer read or write data out of
       * it. After it has been closed it is pretty much useless and should not be
       * used any more.
       */
      get closed() {
        return this.#closed;
      }
      /**
       * Closes this Replicache instance.
       *
       * When closed all subscriptions end and no more read or writes are allowed.
       */
      async close() {
        this.#closed = true;
        const { promise, resolve: resolve2 } = resolver();
        closingInstances.set(this.name, promise);
        this.#closeAbortController.abort();
        getBrowserGlobal("document")?.removeEventListener(
          "visibilitychange",
          this.#onVisibilityChange
        );
        await this.#ready;
        const closingPromises = [
          this.memdag.close(),
          this.perdag.close(),
          this.#idbDatabases.close()
        ];
        this.#pullConnectionLoop.close();
        this.#pushConnectionLoop.close();
        this.#subscriptions.clear();
        await Promise.all(closingPromises);
        closingInstances.delete(this.name);
        resolve2();
      }
      async maybeEndPull(syncHead, requestID) {
        for (; ; ) {
          if (this.#closed) {
            return;
          }
          await this.#ready;
          const { clientID } = this;
          const lc = this.#lc.withContext("maybeEndPull").withContext("requestID", requestID);
          const { replayMutations, diffs, oldMainHead, mainHead } = await maybeEndPull(
            this.memdag,
            lc,
            syncHead,
            clientID,
            this.#subscriptions,
            Latest
          );
          if (!replayMutations || replayMutations.length === 0) {
            this.#zero?.advance(oldMainHead, mainHead, diffs.get("") ?? []);
            await this.#subscriptions.fire(diffs);
            void this.#schedulePersist();
            return;
          }
          const zeroData2 = await this.#zero?.getTxData?.("rebase", syncHead);
          for (const mutation of replayMutations) {
            if (this.#subscriptions.hasPendingSubscriptionRuns) {
              await Promise.resolve();
            }
            const { meta } = mutation;
            syncHead = await withWriteNoImplicitCommit(
              this.memdag,
              (dagWrite) => rebaseMutationAndCommit(
                mutation,
                dagWrite,
                syncHead,
                SYNC_HEAD_NAME,
                this.#mutatorRegistry,
                lc,
                isLocalMetaDD31(meta) ? meta.clientID : clientID,
                Latest,
                zeroData2
              )
            );
          }
        }
      }
      #invokePull() {
        if (this.#isPullDisabled()) {
          return Promise.resolve(true);
        }
        return this.#wrapInOnlineCheck(async () => {
          try {
            this.#changeSyncCounters(0, 1);
            const { syncHead, requestID, ok: ok2 } = await this.beginPull();
            if (!ok2) {
              return false;
            }
            if (syncHead !== emptyHash) {
              await this.maybeEndPull(syncHead, requestID);
            }
          } catch (e3) {
            throw await this.#convertToClientStateNotFoundError(e3);
          } finally {
            this.#changeSyncCounters(0, -1);
          }
          return true;
        }, "Pull");
      }
      #isPullDisabled() {
        return this.isClientGroupDisabled || this.pullURL === "" && isDefaultPuller(this.puller);
      }
      async #wrapInOnlineCheck(f, name) {
        let online = true;
        try {
          return await f();
        } catch (e3) {
          if (e3 instanceof PushError || e3 instanceof PullError) {
            online = false;
            this.#lc.debug?.(`${name} threw:
`, e3, "\nwith cause:\n", e3.causedBy);
          } else if (e3 instanceof ReportError) {
            this.#lc.error?.(e3);
          } else {
            this.#lc.info?.(`${name} threw:
`, e3);
          }
          return false;
        } finally {
          if (this.#online !== online) {
            this.#online = online;
            this.onOnlineChange?.(online);
            if (online) {
              void this.recoverMutations();
            }
          }
        }
      }
      async #wrapInReauthRetries(f, verb, lc, preAuth = noop22, postAuth = noop22) {
        const { clientID } = this;
        let reauthAttempts = 0;
        let lastResult;
        lc = lc.withContext(verb);
        do {
          const requestID = newRequestID(clientID);
          const requestLc = lc.withContext("requestID", requestID);
          const { httpRequestInfo, result } = await f(requestID, requestLc);
          lastResult = result;
          if (!httpRequestInfo) {
            return {
              result,
              authFailure: false
            };
          }
          const { errorMessage, httpStatusCode } = httpRequestInfo;
          if (errorMessage || httpStatusCode !== 200) {
            requestLc.error?.(
              `Got a non 200 response doing ${verb}: ${httpStatusCode}` + (errorMessage ? `: ${errorMessage}` : "")
            );
          }
          if (httpStatusCode !== httpStatusUnauthorized) {
            return {
              result,
              authFailure: false
            };
          }
          if (!this.getAuth) {
            return {
              result,
              authFailure: true
            };
          }
          let auth;
          try {
            await preAuth();
            auth = await this.getAuth();
          } finally {
            await postAuth();
          }
          if (auth === null || auth === void 0) {
            return {
              result,
              authFailure: true
            };
          }
          this.auth = auth;
          reauthAttempts++;
        } while (reauthAttempts < MAX_REAUTH_TRIES);
        lc.info?.("Tried to reauthenticate too many times");
        return {
          result: lastResult,
          authFailure: true
        };
      }
      #isPushDisabled() {
        return this.isClientGroupDisabled || this.pushURL === "" && isDefaultPusher(this.pusher);
      }
      async #invokePush() {
        if (false) {
          this.onPushInvoked();
        }
        if (this.#isPushDisabled()) {
          return true;
        }
        await this.#ready;
        const profileID = await this.#profileIDPromise;
        const { clientID } = this;
        const clientGroupID = await this.#clientGroupIDPromise;
        return this.#wrapInOnlineCheck(async () => {
          const { result: pusherResult } = await this.#wrapInReauthRetries(
            async (requestID, requestLc) => {
              try {
                this.#changeSyncCounters(1, 0);
                const pusherResult2 = await push3(
                  requestID,
                  this.memdag,
                  requestLc,
                  profileID,
                  clientGroupID,
                  clientID,
                  this.pusher,
                  this.schemaVersion,
                  PUSH_VERSION_DD31
                );
                return {
                  result: pusherResult2,
                  httpRequestInfo: pusherResult2?.httpRequestInfo
                };
              } finally {
                this.#changeSyncCounters(-1, 0);
              }
            },
            "push",
            this.#lc
          );
          if (pusherResult === void 0) {
            return true;
          }
          const { response, httpRequestInfo } = pusherResult;
          if (isVersionNotSupportedResponse(response)) {
            this.#handleVersionNotSupportedResponse(response);
          } else if (isClientStateNotFoundResponse(response)) {
            await this.#clientStateNotFoundOnServer();
          }
          return httpRequestInfo.httpStatusCode === 200;
        }, "Push");
      }
      #handleVersionNotSupportedResponse(response) {
        const reason = {
          type: response.error
        };
        if (response.versionType) {
          reason.versionType = response.versionType;
        }
        this.#fireOnUpdateNeeded(reason);
      }
      /**
       * Push pushes pending changes to the {@link pushURL}.
       *
       * You do not usually need to manually call push. If {@link pushDelay} is
       * non-zero (which it is by default) pushes happen automatically shortly after
       * mutations.
       *
       * If the server endpoint fails push will be continuously retried with an
       * exponential backoff.
       *
       * @param [now=false] If true, push will happen immediately and ignore
       *   {@link pushDelay}, {@link RequestOptions.minDelayMs} as well as the
       *   exponential backoff in case of errors.
       * @returns A promise that resolves when the next push completes. In case of
       * errors the first error will reject the returned promise. Subsequent errors
       * will not be reflected in the promise.
       */
      push({ now = false } = {}) {
        return throwIfError(this.#pushConnectionLoop.send(now));
      }
      /**
       * Pull pulls changes from the {@link pullURL}. If there are any changes local
       * changes will get replayed on top of the new server state.
       *
       * If the server endpoint fails pull will be continuously retried with an
       * exponential backoff.
       *
       * @param [now=false] If true, pull will happen immediately and ignore
       *   {@link RequestOptions.minDelayMs} as well as the exponential backoff in
       *   case of errors.
       * @returns A promise that resolves when the next pull completes. In case of
       * errors the first error will reject the returned promise. Subsequent errors
       * will not be reflected in the promise.
       */
      pull({ now = false } = {}) {
        return throwIfError(this.#pullConnectionLoop.send(now));
      }
      /**
       * Applies an update from the server to Replicache.
       * Throws an error if cookie does not match. In that case the server thinks
       * this client has a different cookie than it does; the caller should disconnect
       * from the server and re-register, which transmits the cookie the client actually
       * has.
       *
       * @experimental This method is under development and its semantics will change.
       */
      async poke(poke) {
        await this.#ready;
        const { clientID } = this;
        const requestID = newRequestID(clientID);
        const lc = this.#lc.withContext("handlePullResponse").withContext("requestID", requestID);
        const { pullResponse } = poke;
        if (isVersionNotSupportedResponse(pullResponse)) {
          this.#handleVersionNotSupportedResponse(pullResponse);
          return;
        }
        if (isClientStateNotFoundResponse(pullResponse)) {
          await this.#clientStateNotFoundOnServer();
          return;
        }
        const result = await handlePullResponseV1(
          lc,
          this.memdag,
          deepFreeze(poke.baseCookie),
          pullResponse,
          clientID,
          Latest
        );
        switch (result.type) {
          case Applied:
            await this.maybeEndPull(result.syncHead, requestID);
            break;
          case CookieMismatch:
            throw new Error(
              "unexpected base cookie for poke: " + JSON.stringify(poke)
            );
          case NoOp:
            break;
        }
      }
      async beginPull() {
        if (false) {
          this.onBeginPull();
        }
        await this.#ready;
        const profileID = await this.profileID;
        const { clientID } = this;
        const clientGroupID = await this.#clientGroupIDPromise;
        const {
          result: { beginPullResponse, requestID }
        } = await this.#wrapInReauthRetries(
          async (requestID2, requestLc) => {
            const beginPullResponse2 = await beginPullV1(
              profileID,
              clientID,
              clientGroupID,
              this.schemaVersion,
              this.puller,
              requestID2,
              this.memdag,
              Latest,
              requestLc
            );
            return {
              result: { beginPullResponse: beginPullResponse2, requestID: requestID2 },
              httpRequestInfo: beginPullResponse2.httpRequestInfo
            };
          },
          "pull",
          this.#lc,
          () => this.#changeSyncCounters(0, -1),
          () => this.#changeSyncCounters(0, 1)
        );
        const { pullResponse } = beginPullResponse;
        if (isVersionNotSupportedResponse(pullResponse)) {
          this.#handleVersionNotSupportedResponse(pullResponse);
        } else if (isClientStateNotFoundResponse(beginPullResponse.pullResponse)) {
          await this.#clientStateNotFoundOnServer();
        }
        const { syncHead, httpRequestInfo } = beginPullResponse;
        return { requestID, syncHead, ok: httpRequestInfo.httpStatusCode === 200 };
      }
      persist() {
        return this.#persistLock.withLock(async () => {
          const { clientID } = this;
          await this.#ready;
          if (this.#closed) {
            return;
          }
          try {
            await persistDD31(
              this.#lc,
              clientID,
              this.memdag,
              this.perdag,
              this.#mutatorRegistry,
              () => this.#closed,
              Latest,
              this.#zero?.getTxData
            );
          } catch (e3) {
            if (e3 instanceof ClientStateNotFoundError) {
              this.#clientStateNotFoundOnClient(clientID);
            } else if (this.#closed) {
              this.#lc.debug?.("Exception persisting during close", e3);
            } else {
              throw e3;
            }
          }
          const clientGroupID = await this.#clientGroupIDPromise;
          assert3(clientGroupID);
          this.#onPersist({ clientID, clientGroupID });
        });
      }
      async refresh() {
        await this.#ready;
        const { clientID } = this;
        if (this.#closed) {
          return;
        }
        let refreshResult;
        try {
          refreshResult = await refresh(
            this.#lc,
            this.memdag,
            this.perdag,
            clientID,
            this.#mutatorRegistry,
            this.#subscriptions,
            () => this.closed,
            Latest,
            this.#zero
          );
        } catch (e3) {
          if (e3 instanceof ClientStateNotFoundError) {
            this.#clientStateNotFoundOnClient(clientID);
          } else if (this.#closed) {
            this.#lc.debug?.("Exception refreshing during close", e3);
          } else {
            throw e3;
          }
        }
        if (refreshResult !== void 0) {
          await this.#subscriptions.fire(refreshResult.diffs);
        }
      }
      #fireOnClientStateNotFound() {
        this.onClientStateNotFound?.();
      }
      #clientStateNotFoundOnClient(clientID) {
        this.#lc.error?.(`Client state not found on client, clientID: ${clientID}`);
        this.#fireOnClientStateNotFound();
      }
      async #clientStateNotFoundOnServer() {
        const clientGroupID = await this.#clientGroupIDPromise;
        this.#lc.error?.(
          `Client state not found on server, clientGroupID: ${clientGroupID}`
        );
        await this.disableClientGroup();
        this.#fireOnClientStateNotFound();
      }
      async disableClientGroup() {
        const clientGroupID = await this.#clientGroupIDPromise;
        assert3(clientGroupID);
        this.isClientGroupDisabled = true;
        await withWrite(
          this.perdag,
          (dagWrite) => disableClientGroup(clientGroupID, dagWrite)
        );
      }
      #fireOnUpdateNeeded(reason) {
        this.#lc.debug?.(`Update needed, reason: ${reason}`);
        this.onUpdateNeeded?.(reason);
      }
      async #schedulePersist() {
        if (!this.#enableScheduledPersist) {
          return;
        }
        await this.#schedule("persist", this.#persistScheduler);
      }
      async #handlePersist(persistInfo) {
        this.#lc.debug?.("Handling persist", persistInfo);
        const clientGroupID = await this.#clientGroupIDPromise;
        if (persistInfo.clientGroupID === clientGroupID) {
          void this.#scheduleRefresh();
        }
      }
      async #scheduleRefresh() {
        if (!this.#enableScheduledRefresh) {
          return;
        }
        await this.#schedule("refresh from storage", this.#refreshScheduler);
      }
      async #schedule(name, scheduler) {
        try {
          await scheduler.schedule();
        } catch (e3) {
          if (e3 instanceof AbortError) {
            this.#lc.debug?.(`Scheduled ${name} did not complete before close.`);
          } else {
            this.#lc.error?.(`Error during ${name}`, e3);
          }
        }
      }
      #changeSyncCounters(pushDelta, pullDelta) {
        this.#pushCounter += pushDelta;
        this.#pullCounter += pullDelta;
        const delta = pushDelta + pullDelta;
        const counter = this.#pushCounter + this.#pullCounter;
        if (delta === 1 && counter === 1 || counter === 0) {
          const syncing = counter > 0;
          Promise.resolve().then(() => this.onSync?.(syncing));
        }
      }
      /**
       * Subscribe to the result of a {@link query}. The `body` function is
       * evaluated once and its results are returned via `onData`.
       *
       * Thereafter, each time the the result of `body` changes, `onData` is fired
       * again with the new result.
       *
       * `subscribe()` goes to significant effort to avoid extraneous work
       * re-evaluating subscriptions:
       *
       * 1. subscribe tracks the keys that `body` accesses each time it runs. `body`
       *    is only re-evaluated when those keys change.
       * 2. subscribe only re-fires `onData` in the case that a result changes by
       *    way of the `isEqual` option which defaults to doing a deep JSON value
       *    equality check.
       *
       * Because of (1), `body` must be a pure function of the data in Replicache.
       * `body` must not access anything other than the `tx` parameter passed to it.
       *
       * Although subscribe is as efficient as it can be, it is somewhat constrained
       * by the goal of returning an arbitrary computation of the cache. For even
       * better performance (but worse dx), see {@link experimentalWatch}.
       *
       * If an error occurs in the `body` the `onError` function is called if
       * present. Otherwise, the error is logged at log level 'error'.
       *
       * To cancel the subscription, call the returned function.
       *
       * @param body The function to evaluate to get the value to pass into
       *    `onData`.
       * @param options Options is either a function or an object. If it is a
       *    function it is equivalent to passing it as the `onData` property of an
       *    object.
       */
      subscribe(body2, options2) {
        if (typeof options2 === "function") {
          options2 = { onData: options2 };
        }
        const { onData, onError, onDone, isEqual } = options2;
        return this.#subscriptions.add(
          new SubscriptionImpl(body2, onData, onError, onDone, isEqual)
        );
      }
      experimentalWatch(callback, options2) {
        return this.#subscriptions.add(
          new WatchSubscription(callback, options2)
        );
      }
      /**
       * Query is used for read transactions. It is recommended to use transactions
       * to ensure you get a consistent view across multiple calls to `get`, `has`
       * and `scan`.
       */
      query(body2) {
        return this.#queryInternal(body2);
      }
      get cookie() {
        return this.#ready.then(
          () => withRead(this.memdag, async (dagRead) => {
            const mainHeadHash = await dagRead.getHead(DEFAULT_HEAD_NAME);
            if (!mainHeadHash) {
              throw new Error("Internal no main head found");
            }
            const baseSnapshot = await baseSnapshotFromHash(mainHeadHash, dagRead);
            const baseSnapshotMeta = baseSnapshot.meta;
            const cookie = baseSnapshotMeta.cookieJSON;
            assertCookie(cookie);
            return cookie;
          })
        );
      }
      #queryInternal = /* @__PURE__ */ __name(async (body2) => {
        await this.#ready;
        const { clientID } = this;
        return withRead(this.memdag, async (dagRead) => {
          try {
            const dbRead = await readFromDefaultHead(dagRead, Latest);
            const tx = new ReadTransactionImpl(clientID, dbRead, this.#lc);
            return await body2(tx);
          } catch (ex) {
            throw await this.#convertToClientStateNotFoundError(ex);
          }
        });
      }, "#queryInternal");
      #register(name, mutatorImpl) {
        this.#mutatorRegistry[name] = mutatorImpl;
        return (args) => this.#mutate(name, mutatorImpl, args, performance.now());
      }
      #registerMutators(regs) {
        const rv = /* @__PURE__ */ Object.create(null);
        for (const k in regs) {
          rv[k] = this.#register(k, regs[k]);
        }
        return rv;
      }
      async #mutate(name, mutatorImpl, args, timestamp2) {
        const frozenArgs = deepFreeze(args ?? null);
        if (this.#subscriptions.hasPendingSubscriptionRuns) {
          await Promise.resolve();
        }
        await this.#ready;
        const { clientID } = this;
        return withWriteNoImplicitCommit(this.memdag, async (dagWrite) => {
          try {
            const headHash = await mustGetHeadHash(DEFAULT_HEAD_NAME, dagWrite);
            const originalHash = null;
            const dbWrite = await newWriteLocal(
              headHash,
              name,
              frozenArgs,
              originalHash,
              dagWrite,
              timestamp2,
              clientID,
              Latest
            );
            const tx = new WriteTransactionImpl(
              clientID,
              await dbWrite.getMutationID(),
              "initial",
              await this.#zero?.getTxData("initial", headHash, {
                openLazyRead: dagWrite
              }),
              dbWrite,
              this.#lc
            );
            const result = await mutatorImpl(tx, args);
            throwIfClosed(dbWrite);
            const lastMutationID = await dbWrite.getMutationID();
            const [newHead, diffs] = await dbWrite.commitWithDiffs(
              DEFAULT_HEAD_NAME,
              this.#subscriptions
            );
            this.lastMutationID = lastMutationID;
            this.#zero?.advance(headHash, newHead, diffs.get("") ?? []);
            this.#pushConnectionLoop.send(false).catch(() => void 0);
            await this.#subscriptions.fire(diffs);
            void this.#schedulePersist();
            return result;
          } catch (ex) {
            throw await this.#convertToClientStateNotFoundError(ex);
          }
        });
      }
      /**
       * In the case we get a ChunkNotFoundError we check if the client got garbage
       * collected and if so change the error to a ClientStateNotFoundError instead
       */
      async #convertToClientStateNotFoundError(ex) {
        if (ex instanceof ChunkNotFoundError && await this.#checkForClientStateNotFoundAndCallHandler()) {
          return new ClientStateNotFoundError(this.clientID);
        }
        return ex;
      }
      recoverMutations() {
        if (false) {
          const result = this.#mutationRecovery.recoverMutations(
            this.#ready,
            this.perdag,
            this.#idbDatabase,
            this.#idbDatabases,
            this.#kvStoreProvider.create
          );
          if (false) {
            void this.onRecoverMutations(result);
          }
          return result;
        }
      }
      /**
       * List of pending mutations. The order of this is from oldest to newest.
       *
       * Gives a list of local mutations that have `mutationID` >
       * `syncHead.mutationID` that exists on the main client group.
       *
       * @experimental This method is experimental and may change in the future.
       */
      experimentalPendingMutations() {
        return withRead(this.memdag, pendingMutationsForAPI);
      }
    };
    closingInstances = /* @__PURE__ */ new Map();
    __name(throwIfError, "throwIfError");
    __name(reload, "reload");
    __name(validateOptions, "validateOptions");
    httpStatusUnauthorized = 401;
    __name(makeIDBName, "makeIDBName");
    __name(makeIDBNameInternal, "makeIDBNameInternal");
    ReportError = class extends Error {
      static {
        __name(this, "ReportError");
      }
    };
    __name(createMemStore, "createMemStore");
    __name(getKVStoreProvider, "getKVStoreProvider");
    COLLECT_IDB_INTERVAL = 12 * 60 * 60 * 1e3;
    INITIAL_COLLECT_IDB_DELAY = 5 * 60 * 1e3;
    __name(initCollectIDBDatabases, "initCollectIDBDatabases");
    __name(collectIDBDatabases, "collectIDBDatabases");
    __name(dropDatabaseInternal, "dropDatabaseInternal");
    __name(dropDatabases, "dropDatabases");
    __name(defaultNewDagStore, "defaultNewDagStore");
    __name(gatherDatabaseInfoForCollect, "gatherDatabaseInfoForCollect");
    __name(dropDatabase, "dropDatabase");
    __name(canDatabaseBeCollectedAndGetDeletedClientIDs, "canDatabaseBeCollectedAndGetDeletedClientIDs");
    __name(relationships, "relationships");
    __name(many, "many");
    __name(one, "one");
    h64 = /* @__PURE__ */ __name((s3) => hash3(s3, 2), "h64");
    h128 = /* @__PURE__ */ __name((s3) => hash3(s3, 4), "h128");
    __name(hash3, "hash");
    __name(mapEntries, "mapEntries");
    __name(mapAllEntries, "mapAllEntries");
    valueTypeSchema = valita_exports.union(
      valita_exports.literal("string"),
      valita_exports.literal("number"),
      valita_exports.literal("boolean"),
      valita_exports.literal("null"),
      valita_exports.literal("json")
    );
    columnSchemaSchema = valita_exports.object({
      type: valueTypeSchema
    });
    tableSchemaSchema = valita_exports.object({
      columns: valita_exports.record(columnSchemaSchema)
    });
    clientSchemaSchema = valita_exports.object({
      tables: valita_exports.record(tableSchemaSchema)
    });
    keyCmp = /* @__PURE__ */ __name(([a], [b2]) => a < b2 ? -1 : a > b2 ? 1 : 0, "keyCmp");
    __name(normalizeClientSchema, "normalizeClientSchema");
    __name(table3, "table");
    __name(string8, "string8");
    __name(number4, "number4");
    __name(boolean3, "boolean3");
    TableBuilder = class _TableBuilder {
      static {
        __name(this, "_TableBuilder");
      }
      #schema;
      constructor(schema2) {
        this.#schema = schema2;
      }
      from(serverName) {
        return new _TableBuilder({
          ...this.#schema,
          serverName
        });
      }
      columns(columns) {
        const columnSchemas = Object.fromEntries(
          Object.entries(columns).map(([k, v2]) => [k, v2.schema])
        );
        return new TableBuilderWithColumns({
          ...this.#schema,
          columns: columnSchemas
        });
      }
    };
    TableBuilderWithColumns = class _TableBuilderWithColumns {
      static {
        __name(this, "_TableBuilderWithColumns");
      }
      #schema;
      constructor(schema2) {
        this.#schema = schema2;
      }
      primaryKey(...pkColumnNames) {
        return new _TableBuilderWithColumns({
          ...this.#schema,
          primaryKey: pkColumnNames
        });
      }
      get schema() {
        return this.#schema;
      }
      build() {
        if (this.#schema.primaryKey.length === 0) {
          throw new Error(`Table "${this.#schema.name}" is missing a primary key`);
        }
        const names = /* @__PURE__ */ new Set();
        for (const [col, { serverName }] of Object.entries(this.#schema.columns)) {
          const name = serverName ?? col;
          if (names.has(name)) {
            throw new Error(
              `Table "${this.#schema.name}" has multiple columns referencing "${name}"`
            );
          }
          names.add(name);
        }
        return this.#schema;
      }
    };
    ColumnBuilder2 = class _ColumnBuilder {
      static {
        __name(this, "_ColumnBuilder");
      }
      #schema;
      constructor(schema2) {
        this.#schema = schema2;
      }
      from(serverName) {
        return new _ColumnBuilder({
          ...this.#schema,
          serverName
        });
      }
      optional() {
        return new _ColumnBuilder({
          ...this.#schema,
          optional: true
        });
      }
      get schema() {
        return this.#schema;
      }
    };
    __name(createSchema, "createSchema");
    __name(checkRelationship, "checkRelationship");
    __name(clientSchemaFrom, "clientSchemaFrom");
    __name(defined, "defined");
    __name(areEqual, "areEqual");
    valueSchema = valita_exports.union(jsonSchema, valita_exports.undefined());
    rowSchema = readonlyRecord(valueSchema);
    selectorSchema = valita_exports.string();
    toStaticParam = Symbol();
    orderingElementSchema = readonly(
      valita_exports.tuple([selectorSchema, valita_exports.union(valita_exports.literal("asc"), valita_exports.literal("desc"))])
    );
    orderingSchema = readonlyArray(orderingElementSchema);
    primitiveSchema = valita_exports.union(
      valita_exports.string(),
      valita_exports.number(),
      valita_exports.boolean(),
      valita_exports.null()
    );
    equalityOpsSchema = valita_exports.union(
      valita_exports.literal("="),
      valita_exports.literal("!="),
      valita_exports.literal("IS"),
      valita_exports.literal("IS NOT")
    );
    orderOpsSchema = valita_exports.union(
      valita_exports.literal("<"),
      valita_exports.literal(">"),
      valita_exports.literal("<="),
      valita_exports.literal(">=")
    );
    likeOpsSchema = valita_exports.union(
      valita_exports.literal("LIKE"),
      valita_exports.literal("NOT LIKE"),
      valita_exports.literal("ILIKE"),
      valita_exports.literal("NOT ILIKE")
    );
    inOpsSchema = valita_exports.union(valita_exports.literal("IN"), valita_exports.literal("NOT IN"));
    simpleOperatorSchema = valita_exports.union(
      equalityOpsSchema,
      orderOpsSchema,
      likeOpsSchema,
      inOpsSchema
    );
    literalReferenceSchema = readonlyObject({
      type: valita_exports.literal("literal"),
      value: valita_exports.union(
        valita_exports.string(),
        valita_exports.number(),
        valita_exports.boolean(),
        valita_exports.null(),
        readonlyArray(valita_exports.union(valita_exports.string(), valita_exports.number(), valita_exports.boolean()))
      )
    });
    columnReferenceSchema = readonlyObject({
      type: valita_exports.literal("column"),
      name: valita_exports.string()
    });
    parameterReferenceSchema = readonlyObject({
      type: valita_exports.literal("static"),
      // The "namespace" of the injected parameter.
      // Write authorization will send the value of a row
      // prior to the mutation being run (preMutationRow).
      // Read and write authorization will both send the
      // current authentication data (authData).
      anchor: valita_exports.union(valita_exports.literal("authData"), valita_exports.literal("preMutationRow")),
      field: valita_exports.union(valita_exports.string(), valita_exports.array(valita_exports.string()))
    });
    conditionValueSchema = valita_exports.union(
      literalReferenceSchema,
      columnReferenceSchema,
      parameterReferenceSchema
    );
    simpleConditionSchema = readonlyObject({
      type: valita_exports.literal("simple"),
      op: simpleOperatorSchema,
      left: conditionValueSchema,
      right: valita_exports.union(parameterReferenceSchema, literalReferenceSchema)
    });
    correlatedSubqueryConditionOperatorSchema = valita_exports.union(valita_exports.literal("EXISTS"), valita_exports.literal("NOT EXISTS"));
    correlatedSubqueryConditionSchema = readonlyObject({
      type: valita_exports.literal("correlatedSubquery"),
      related: valita_exports.lazy(() => correlatedSubquerySchema),
      op: correlatedSubqueryConditionOperatorSchema
    });
    conditionSchema = valita_exports.union(
      simpleConditionSchema,
      valita_exports.lazy(() => conjunctionSchema),
      valita_exports.lazy(() => disjunctionSchema),
      correlatedSubqueryConditionSchema
    );
    conjunctionSchema = readonlyObject({
      type: valita_exports.literal("and"),
      conditions: readonlyArray(conditionSchema)
    });
    disjunctionSchema = readonlyObject({
      type: valita_exports.literal("or"),
      conditions: readonlyArray(conditionSchema)
    });
    __name(mustCompoundKey, "mustCompoundKey");
    compoundKeySchema = readonly(
      valita_exports.tuple([valita_exports.string()]).concat(valita_exports.array(valita_exports.string()))
    );
    correlationSchema = readonlyObject({
      parentField: compoundKeySchema,
      childField: compoundKeySchema
    });
    correlatedSubquerySchemaOmitSubquery = readonlyObject({
      correlation: correlationSchema,
      hidden: valita_exports.boolean().optional(),
      system: valita_exports.union(valita_exports.literal("permissions"), valita_exports.literal("client")).optional()
    });
    correlatedSubquerySchema = correlatedSubquerySchemaOmitSubquery.extend({
      subquery: valita_exports.lazy(() => astSchema)
    });
    astSchema = readonlyObject({
      schema: valita_exports.string().optional(),
      table: valita_exports.string(),
      alias: valita_exports.string().optional(),
      where: conditionSchema.optional(),
      related: readonlyArray(correlatedSubquerySchema).optional(),
      limit: valita_exports.number().optional(),
      orderBy: orderingSchema.optional(),
      start: valita_exports.object({
        row: rowSchema,
        exclusive: valita_exports.boolean()
      }).optional()
    });
    __name(transformAST, "transformAST");
    __name(transformWhere, "transformWhere");
    normalizeCache = /* @__PURE__ */ new WeakMap();
    NORMALIZE_TRANSFORM = {
      tableName: /* @__PURE__ */ __name((t22) => t22, "tableName"),
      columnName: /* @__PURE__ */ __name((_, c2) => c2, "columnName"),
      related: sortedRelated,
      where: flattened,
      conditions: /* @__PURE__ */ __name((c2) => c2.sort(cmpCondition), "conditions")
    };
    __name(normalizeAST, "normalizeAST");
    __name(mapAST, "mapAST");
    __name(mapCondition, "mapCondition");
    __name(sortedRelated, "sortedRelated");
    __name(cmpCondition, "cmpCondition");
    __name(compareValuePosition, "compareValuePosition");
    __name(cmpRelated, "cmpRelated");
    __name(flattened, "flattened");
    __name(compareUTF8MaybeNull, "compareUTF8MaybeNull");
    hashCache = /* @__PURE__ */ new WeakMap();
    __name(hashOfAST, "hashOfAST");
    __name(isOneHop, "isOneHop");
    __name(isTwoHop, "isTwoHop");
    throwOutput = {
      push(_change) {
        throw new Error("Output not set");
      }
    };
    __name(take, "take");
    __name(first, "first");
    Exists = class {
      static {
        __name(this, "Exists");
      }
      #input;
      #relationshipName;
      #storage;
      #not;
      #parentJoinKey;
      #noSizeReuse;
      #output = throwOutput;
      /**
       * This instance variable is `true` when this operator is processing a `push`,
       * and is used to disable reuse of cached sizes across rows with the
       * same parent join key value.
       * This is necessary because during a push relationships can be inconsistent
       * due to push communicating changes (which may change multiple Nodes) one
       * Node at a time.
       */
      #inPush = false;
      constructor(input, storage, relationshipName, parentJoinKey, type) {
        this.#input = input;
        this.#relationshipName = relationshipName;
        this.#input.setOutput(this);
        this.#storage = storage;
        assert3(
          this.#input.getSchema().relationships[relationshipName],
          `Input schema missing ${relationshipName}`
        );
        this.#not = type === "NOT EXISTS";
        this.#parentJoinKey = parentJoinKey;
        this.#noSizeReuse = areEqual(
          parentJoinKey,
          this.#input.getSchema().primaryKey
        );
      }
      setOutput(output) {
        this.#output = output;
      }
      destroy() {
        this.#input.destroy();
      }
      getSchema() {
        return this.#input.getSchema();
      }
      *fetch(req) {
        for (const node of this.#input.fetch(req)) {
          if (this.#filter(node)) {
            yield node;
          }
        }
      }
      *cleanup(req) {
        for (const node of this.#input.cleanup(req)) {
          if (this.#filter(node)) {
            yield node;
          } else {
            drainStreams(node);
          }
          this.#delSize(node);
        }
      }
      push(change) {
        this.#inPush = true;
        try {
          switch (change.type) {
            // add, remove and edit cannot change the size of the
            // this.#relationshipName relationship, so simply #pushWithFilter
            case "add":
            case "edit": {
              this.#pushWithFilter(change);
              return;
            }
            case "remove": {
              const size2 = this.#getSize(change.node);
              if (size2 === void 0) {
                return;
              }
              this.#pushWithFilter(change, size2);
              this.#delSize(change.node);
              return;
            }
            case "child":
              if (change.child.relationshipName !== this.#relationshipName || change.child.change.type === "edit" || change.child.change.type === "child") {
                this.#pushWithFilter(change);
                return;
              }
              switch (change.child.change.type) {
                case "add": {
                  let size2 = this.#getSize(change.node);
                  if (size2 !== void 0) {
                    size2++;
                    this.#setSize(change.node, size2);
                  } else {
                    size2 = this.#fetchSize(change.node);
                  }
                  if (size2 === 1) {
                    if (this.#not) {
                      this.#output.push({
                        type: "remove",
                        node: {
                          row: change.node.row,
                          relationships: {
                            ...change.node.relationships,
                            [this.#relationshipName]: () => []
                          }
                        }
                      });
                    } else {
                      this.#output.push({
                        type: "add",
                        node: change.node
                      });
                    }
                  } else {
                    this.#pushWithFilter(change, size2);
                  }
                  return;
                }
                case "remove": {
                  let size2 = this.#getSize(change.node);
                  if (size2 !== void 0) {
                    assert3(size2 > 0);
                    size2--;
                    this.#setSize(change.node, size2);
                  } else {
                    size2 = this.#fetchSize(change.node);
                  }
                  if (size2 === 0) {
                    if (this.#not) {
                      this.#output.push({
                        type: "add",
                        node: change.node
                      });
                    } else {
                      this.#output.push({
                        type: "remove",
                        node: {
                          row: change.node.row,
                          relationships: {
                            ...change.node.relationships,
                            [this.#relationshipName]: () => [
                              change.child.change.node
                            ]
                          }
                        }
                      });
                    }
                  } else {
                    this.#pushWithFilter(change, size2);
                  }
                  return;
                }
              }
              return;
            default:
              unreachable(change);
          }
        } finally {
          this.#inPush = false;
        }
      }
      /**
       * Returns whether or not the node's this.#relationshipName
       * relationship passes the exist/not exists filter condition.
       * If the optional `size` is passed it is used.
       * Otherwise, if there is a stored size for the row it is used.
       * Otherwise the size is computed by streaming the node's
       * relationship with this.#relationshipName (this computed size is also
       * stored).
       */
      #filter(node, size2) {
        const exists2 = (size2 ?? this.#getOrFetchSize(node)) > 0;
        return this.#not ? !exists2 : exists2;
      }
      /**
       * Pushes a change if this.#filter is true for its row.
       */
      #pushWithFilter(change, size2) {
        if (this.#filter(change.node, size2)) {
          this.#output.push(change);
        }
      }
      #getSize(node) {
        return this.#storage.get(this.#makeSizeStorageKey(node));
      }
      #setSize(node, size2) {
        this.#storage.set(this.#makeSizeStorageKey(node), size2);
      }
      #delSize(node) {
        this.#storage.del(this.#makeSizeStorageKey(node));
      }
      #getOrFetchSize(node) {
        const size2 = this.#getSize(node);
        if (size2 !== void 0) {
          return size2;
        }
        return this.#fetchSize(node);
      }
      #fetchSize(node) {
        if (!this.#noSizeReuse && !this.#inPush) {
          const cachedSizeEntry = first(
            this.#storage.scan({
              prefix: this.#makeSizeStorageKeyPrefix(node)
            })
          );
          if (cachedSizeEntry !== void 0) {
            this.#setSize(node, cachedSizeEntry[1]);
            return cachedSizeEntry[1];
          }
        }
        const relationship = node.relationships[this.#relationshipName];
        assert3(relationship);
        let size2 = 0;
        for (const _relatedNode of relationship()) {
          size2++;
        }
        this.#setSize(node, size2);
        return size2;
      }
      #makeSizeStorageKeyPrefix(node) {
        return `row/${this.#noSizeReuse ? "" : JSON.stringify(this.#getKeyValues(node, this.#parentJoinKey))}/`;
      }
      #makeSizeStorageKey(node) {
        return `${this.#makeSizeStorageKeyPrefix(node)}${JSON.stringify(
          this.#getKeyValues(node, this.#input.getSchema().primaryKey)
        )}`;
      }
      #getKeyValues(node, def) {
        const values2 = [];
        for (const key2 of def) {
          values2.push(normalizeUndefined(node.row[key2]));
        }
        return values2;
      }
    };
    FanIn = class {
      static {
        __name(this, "FanIn");
      }
      #inputs;
      #schema;
      #output = throwOutput;
      #accumulatedPushes;
      constructor(fanOut, inputs) {
        this.#inputs = inputs;
        this.#schema = fanOut.getSchema();
        for (const input of inputs) {
          input.setOutput(this);
          assert3(this.#schema === input.getSchema(), `Schema mismatch in fan-in`);
        }
        this.#accumulatedPushes = [];
      }
      setOutput(output) {
        this.#output = output;
      }
      destroy() {
        for (const input of this.#inputs) {
          input.destroy();
        }
      }
      getSchema() {
        return this.#schema;
      }
      fetch(req) {
        return this.#fetchOrCleanup((input) => input.fetch(req));
      }
      cleanup(req) {
        return this.#fetchOrCleanup((input) => input.cleanup(req));
      }
      *#fetchOrCleanup(streamProvider) {
        const iterables = this.#inputs.map((input) => streamProvider(input));
        yield* mergeIterables(
          iterables,
          (l, r3) => must(this.#schema).compareRows(l.row, r3.row),
          true
        );
      }
      push(change) {
        this.#accumulatedPushes.push(change);
      }
      fanOutDonePushingToAllBranches(fanOutChangeType) {
        if (this.#inputs.length === 0) {
          assert3(
            this.#accumulatedPushes.length === 0,
            "If there are no inputs then fan-in should not receive any pushes."
          );
          return;
        }
        if (this.#accumulatedPushes.length === 0) {
          return;
        }
        const candidatesToPush = /* @__PURE__ */ new Map();
        for (const change of this.#accumulatedPushes) {
          if (fanOutChangeType === "child" && change.type !== "child") {
            assert3(
              candidatesToPush.has(change.type) === false,
              () => `Fan-in:child expected at most one ${change.type} when fan-out is of type child`
            );
          }
          candidatesToPush.set(change.type, change);
        }
        this.#accumulatedPushes = [];
        const types4 = [...candidatesToPush.keys()];
        switch (fanOutChangeType) {
          case "remove":
            assert3(
              types4.length === 1 && types4[0] === "remove",
              "Fan-in:remove expected all removes"
            );
            this.#output.push(must(candidatesToPush.get("remove")));
            return;
          case "add":
            assert3(
              types4.length === 1 && types4[0] === "add",
              "Fan-in:add expected all adds"
            );
            this.#output.push(must(candidatesToPush.get("add")));
            return;
          case "edit": {
            assert3(
              types4.every(
                (type) => type === "add" || type === "remove" || type === "edit"
              ),
              "Fan-in:edit expected all adds, removes, or edits"
            );
            const addChange = candidatesToPush.get("add");
            const removeChange = candidatesToPush.get("remove");
            const editChange = candidatesToPush.get("edit");
            if (editChange) {
              this.#output.push(editChange);
              return;
            }
            if (addChange && removeChange) {
              this.#output.push({
                type: "edit",
                node: addChange.node,
                oldNode: removeChange.node
              });
              return;
            }
            this.#output.push(must(addChange ?? removeChange));
            return;
          }
          case "child": {
            assert3(
              types4.every(
                (type) => type === "add" || // exists can change child to add or remove
                type === "remove" || // exists can change child to add or remove
                type === "child"
                // other operators may preserve the child change
              ),
              "Fan-in:child expected all adds, removes, or children"
            );
            assert3(
              types4.length <= 2,
              "Fan-in:child expected at most 2 types on a child change from fan-out"
            );
            const childChange = candidatesToPush.get("child");
            if (childChange) {
              this.#output.push(childChange);
              return;
            }
            const addChange = candidatesToPush.get("add");
            const removeChange = candidatesToPush.get("remove");
            assert3(
              addChange === void 0 || removeChange === void 0,
              "Fan-in:child expected either add or remove, not both"
            );
            this.#output.push(must(addChange ?? removeChange));
            return;
          }
          default:
            fanOutChangeType;
        }
      }
    };
    FanOut = class {
      static {
        __name(this, "FanOut");
      }
      #input;
      #outputs = [];
      #fanIn;
      #destroyCount = 0;
      constructor(input) {
        this.#input = input;
        input.setOutput(this);
      }
      setFanIn(fanIn) {
        this.#fanIn = fanIn;
      }
      setOutput(output) {
        this.#outputs.push(output);
      }
      destroy() {
        if (this.#destroyCount < this.#outputs.length) {
          if (this.#destroyCount === 0) {
            this.#input.destroy();
          }
          ++this.#destroyCount;
        } else {
          throw new Error("FanOut already destroyed once for each output");
        }
      }
      getSchema() {
        return this.#input.getSchema();
      }
      fetch(req) {
        return this.#input.fetch(req);
      }
      cleanup(req) {
        return this.#input.cleanup(req);
      }
      push(change) {
        for (const out of this.#outputs) {
          out.push(change);
        }
        must(
          this.#fanIn,
          "fan-out must have a corresponding fan-in set!"
        ).fanOutDonePushingToAllBranches(change.type);
      }
    };
    __name(maybeSplitAndPushEditChange, "maybeSplitAndPushEditChange");
    __name(filterPush, "filterPush");
    Filter = class {
      static {
        __name(this, "Filter");
      }
      #input;
      #predicate;
      #output = throwOutput;
      constructor(input, predicate) {
        this.#input = input;
        this.#predicate = predicate;
        input.setOutput(this);
      }
      setOutput(output) {
        this.#output = output;
      }
      destroy() {
        this.#input.destroy();
      }
      getSchema() {
        return this.#input.getSchema();
      }
      *fetch(req) {
        for (const node of this.#input.fetch(req)) {
          if (this.#predicate(node.row)) {
            yield node;
          }
        }
      }
      *cleanup(req) {
        for (const node of this.#input.cleanup(req)) {
          if (this.#predicate(node.row)) {
            yield node;
          } else {
            drainStreams(node);
          }
        }
      }
      push(change) {
        filterPush(change, this.#output, this.#predicate);
      }
    };
    Join = class {
      static {
        __name(this, "Join");
      }
      #parent;
      #child;
      #storage;
      #parentKey;
      #childKey;
      #relationshipName;
      #schema;
      #output = throwOutput;
      #inprogressChildChange;
      constructor({
        parent,
        child,
        storage,
        parentKey,
        childKey,
        relationshipName,
        hidden,
        system
      }) {
        assert3(parent !== child, "Parent and child must be different operators");
        assert3(
          parentKey.length === childKey.length,
          "The parentKey and childKey keys must have same length"
        );
        this.#parent = parent;
        this.#child = child;
        this.#storage = storage;
        this.#parentKey = parentKey;
        this.#childKey = childKey;
        this.#relationshipName = relationshipName;
        const parentSchema = parent.getSchema();
        const childSchema = child.getSchema();
        this.#schema = {
          ...parentSchema,
          relationships: {
            ...parentSchema.relationships,
            [relationshipName]: {
              ...childSchema,
              isHidden: hidden,
              system
            }
          }
        };
        parent.setOutput({
          push: /* @__PURE__ */ __name((change) => this.#pushParent(change), "push")
        });
        child.setOutput({
          push: /* @__PURE__ */ __name((change) => this.#pushChild(change), "push")
        });
      }
      destroy() {
        this.#parent.destroy();
        this.#child.destroy();
      }
      setOutput(output) {
        this.#output = output;
      }
      getSchema() {
        return this.#schema;
      }
      *fetch(req) {
        for (const parentNode of this.#parent.fetch(req)) {
          yield this.#processParentNode(
            parentNode.row,
            parentNode.relationships,
            "fetch"
          );
        }
      }
      *cleanup(req) {
        for (const parentNode of this.#parent.cleanup(req)) {
          yield this.#processParentNode(
            parentNode.row,
            parentNode.relationships,
            "cleanup"
          );
        }
      }
      #pushParent(change) {
        switch (change.type) {
          case "add":
            this.#output.push({
              type: "add",
              node: this.#processParentNode(
                change.node.row,
                change.node.relationships,
                "fetch"
              )
            });
            break;
          case "remove":
            this.#output.push({
              type: "remove",
              node: this.#processParentNode(
                change.node.row,
                change.node.relationships,
                "cleanup"
              )
            });
            break;
          case "child":
            this.#output.push({
              type: "child",
              node: this.#processParentNode(
                change.node.row,
                change.node.relationships,
                "fetch"
              ),
              child: change.child
            });
            break;
          case "edit": {
            assert3(
              rowEqualsForCompoundKey(
                change.oldNode.row,
                change.node.row,
                this.#parentKey
              ),
              `Parent edit must not change relationship.`
            );
            this.#output.push({
              type: "edit",
              oldNode: this.#processParentNode(
                change.oldNode.row,
                change.oldNode.relationships,
                "cleanup"
              ),
              node: this.#processParentNode(
                change.node.row,
                change.node.relationships,
                "fetch"
              )
            });
            break;
          }
          default:
            unreachable(change);
        }
      }
      #pushChild(change) {
        const pushChildChange = /* @__PURE__ */ __name((childRow, change2) => {
          this.#inprogressChildChange = {
            change: change2,
            position: void 0
          };
          try {
            const parentNodes = this.#parent.fetch({
              constraint: Object.fromEntries(
                this.#parentKey.map((key2, i) => [key2, childRow[this.#childKey[i]]])
              )
            });
            for (const parentNode of parentNodes) {
              this.#inprogressChildChange.position = parentNode.row;
              const childChange = {
                type: "child",
                node: this.#processParentNode(
                  parentNode.row,
                  parentNode.relationships,
                  "fetch"
                ),
                child: {
                  relationshipName: this.#relationshipName,
                  change: change2
                }
              };
              this.#output.push(childChange);
            }
          } finally {
            this.#inprogressChildChange = void 0;
          }
        }, "pushChildChange");
        switch (change.type) {
          case "add":
          case "remove":
            pushChildChange(change.node.row, change);
            break;
          case "child":
            pushChildChange(change.node.row, change);
            break;
          case "edit": {
            const childRow = change.node.row;
            const oldChildRow = change.oldNode.row;
            assert3(
              rowEqualsForCompoundKey(oldChildRow, childRow, this.#childKey),
              "Child edit must not change relationship."
            );
            pushChildChange(childRow, change);
            break;
          }
          default:
            unreachable(change);
        }
      }
      *#generateChildStreamWithOverlay(stream, overlay) {
        let applied = false;
        let editOldApplied = false;
        let editNewApplied = false;
        for (const child of stream) {
          let yieldChild = true;
          if (!applied) {
            switch (overlay.type) {
              case "add": {
                if (this.#child.getSchema().compareRows(overlay.node.row, child.row) === 0) {
                  applied = true;
                  yieldChild = false;
                }
                break;
              }
              case "remove": {
                if (this.#child.getSchema().compareRows(overlay.node.row, child.row) < 0) {
                  applied = true;
                  yield overlay.node;
                }
                break;
              }
              case "edit": {
                if (this.#child.getSchema().compareRows(overlay.oldNode.row, child.row) < 0) {
                  editOldApplied = true;
                  if (editNewApplied) {
                    applied = true;
                  }
                  yield overlay.oldNode;
                }
                if (this.#child.getSchema().compareRows(overlay.node.row, child.row) === 0) {
                  editNewApplied = true;
                  if (editOldApplied) {
                    applied = true;
                  }
                  yieldChild = false;
                }
                break;
              }
              case "child": {
                if (this.#child.getSchema().compareRows(overlay.node.row, child.row) === 0) {
                  applied = true;
                  yield {
                    row: child.row,
                    relationships: {
                      ...child.relationships,
                      [overlay.child.relationshipName]: () => this.#generateChildStreamWithOverlay(
                        child.relationships[overlay.child.relationshipName](),
                        overlay.child.change
                      )
                    }
                  };
                  yieldChild = false;
                }
                break;
              }
            }
          }
          if (yieldChild) {
            yield child;
          }
        }
        if (!applied) {
          if (overlay.type === "remove") {
            applied = true;
            yield overlay.node;
          } else if (overlay.type === "edit") {
            assert3(editNewApplied);
            editOldApplied = true;
            applied = true;
            yield overlay.oldNode;
          }
        }
        assert3(applied);
      }
      #processParentNode(parentNodeRow, parentNodeRelations, mode) {
        let method = mode;
        let storageUpdated = false;
        const childStream = /* @__PURE__ */ __name(() => {
          if (!storageUpdated) {
            if (mode === "cleanup") {
              this.#storage.del(
                makeStorageKey(
                  this.#parentKey,
                  this.#parent.getSchema().primaryKey,
                  parentNodeRow
                )
              );
              const empty = [
                ...take(
                  this.#storage.scan({
                    prefix: makeStorageKeyPrefix(parentNodeRow, this.#parentKey)
                  }),
                  1
                )
              ].length === 0;
              method = empty ? "cleanup" : "fetch";
            }
            storageUpdated = true;
            if (mode === "fetch") {
              this.#storage.set(
                makeStorageKey(
                  this.#parentKey,
                  this.#parent.getSchema().primaryKey,
                  parentNodeRow
                ),
                true
              );
            }
          }
          const stream = this.#child[method]({
            constraint: Object.fromEntries(
              this.#childKey.map((key2, i) => [
                key2,
                parentNodeRow[this.#parentKey[i]]
              ])
            )
          });
          if (this.#inprogressChildChange && this.#isJoinMatch(
            parentNodeRow,
            this.#inprogressChildChange.change.node.row
          ) && this.#inprogressChildChange.position && this.#schema.compareRows(
            parentNodeRow,
            this.#inprogressChildChange.position
          ) > 0) {
            return this.#generateChildStreamWithOverlay(
              stream,
              this.#inprogressChildChange.change
            );
          }
          return stream;
        }, "childStream");
        return {
          row: parentNodeRow,
          relationships: {
            ...parentNodeRelations,
            [this.#relationshipName]: childStream
          }
        };
      }
      #isJoinMatch(parent, child) {
        for (let i = 0; i < this.#parentKey.length; i++) {
          if (!valuesEqual(parent[this.#parentKey[i]], child[this.#childKey[i]])) {
            return false;
          }
        }
        return true;
      }
    };
    __name(makeStorageKeyForValues, "makeStorageKeyForValues");
    __name(makeStorageKeyPrefix, "makeStorageKeyPrefix");
    __name(makeStorageKey, "makeStorageKey");
    __name(rowEqualsForCompoundKey, "rowEqualsForCompoundKey");
    Skip = class {
      static {
        __name(this, "Skip");
      }
      #input;
      #bound;
      #comparator;
      #output = throwOutput;
      constructor(input, bound) {
        this.#input = input;
        this.#bound = bound;
        this.#comparator = input.getSchema().compareRows;
        input.setOutput(this);
      }
      getSchema() {
        return this.#input.getSchema();
      }
      fetch(req) {
        return this.#fetchOrCleanup("fetch", req);
      }
      cleanup(req) {
        return this.#fetchOrCleanup("fetch", req);
      }
      *#fetchOrCleanup(method, req) {
        const start = this.#getStart(req);
        if (start === "empty") {
          return;
        }
        const nodes = this.#input[method]({ ...req, start });
        if (!req.reverse) {
          yield* nodes;
          return;
        }
        for (const node of nodes) {
          if (!this.#shouldBePresent(node.row)) {
            return;
          }
          yield node;
        }
      }
      setOutput(output) {
        this.#output = output;
      }
      destroy() {
        this.#input.destroy();
      }
      #shouldBePresent(row) {
        const cmp2 = this.#comparator(this.#bound.row, row);
        return cmp2 < 0 || cmp2 === 0 && !this.#bound.exclusive;
      }
      push(change) {
        const shouldBePresent = /* @__PURE__ */ __name((row) => this.#shouldBePresent(row), "shouldBePresent");
        if (change.type === "edit") {
          maybeSplitAndPushEditChange(change, shouldBePresent, this.#output);
          return;
        }
        change;
        if (shouldBePresent(change.node.row)) {
          this.#output.push(change);
        }
      }
      #getStart(req) {
        const boundStart = {
          row: this.#bound.row,
          basis: this.#bound.exclusive ? "after" : "at"
        };
        if (!req.start) {
          if (req.reverse) {
            return void 0;
          }
          return boundStart;
        }
        const cmp2 = this.#comparator(this.#bound.row, req.start.row);
        if (!req.reverse) {
          if (cmp2 > 0) {
            return boundStart;
          }
          if (cmp2 === 0) {
            if (this.#bound.exclusive || req.start.basis === "after") {
              return {
                row: this.#bound.row,
                basis: "after"
              };
            }
            return boundStart;
          }
          return req.start;
        }
        req.reverse;
        if (cmp2 > 0) {
          return "empty";
        }
        if (cmp2 === 0) {
          if (!this.#bound.exclusive && req.start.basis === "at") {
            return boundStart;
          }
          return "empty";
        }
        return req.start;
      }
    };
    MAX_BOUND_KEY = "maxBound";
    Take = class {
      static {
        __name(this, "Take");
      }
      #input;
      #storage;
      #limit;
      #partitionKey;
      #partitionKeyComparator;
      // Fetch overlay needed for some split push cases.
      #rowHiddenFromFetch;
      #output = throwOutput;
      constructor(input, storage, limit, partitionKey) {
        assert3(limit >= 0);
        assertOrderingIncludesPK(
          input.getSchema().sort,
          input.getSchema().primaryKey
        );
        input.setOutput(this);
        this.#input = input;
        this.#storage = storage;
        this.#limit = limit;
        this.#partitionKey = partitionKey;
        this.#partitionKeyComparator = partitionKey && makePartitionKeyComparator(partitionKey);
      }
      setOutput(output) {
        this.#output = output;
      }
      getSchema() {
        return this.#input.getSchema();
      }
      *fetch(req) {
        if (!this.#partitionKey || req.constraint && constraintMatchesPartitionKey(req.constraint, this.#partitionKey)) {
          const takeStateKey = getTakeStateKey(this.#partitionKey, req.constraint);
          const takeState = this.#storage.get(takeStateKey);
          if (!takeState) {
            yield* this.#initialFetch(req);
            return;
          }
          if (takeState.bound === void 0) {
            return;
          }
          for (const inputNode of this.#input.fetch(req)) {
            if (this.getSchema().compareRows(takeState.bound, inputNode.row) < 0) {
              return;
            }
            if (this.#rowHiddenFromFetch && this.getSchema().compareRows(
              this.#rowHiddenFromFetch,
              inputNode.row
            ) === 0) {
              continue;
            }
            yield inputNode;
          }
          return;
        }
        const maxBound = this.#storage.get(MAX_BOUND_KEY);
        if (maxBound === void 0) {
          return;
        }
        for (const inputNode of this.#input.fetch(req)) {
          if (this.getSchema().compareRows(inputNode.row, maxBound) > 0) {
            return;
          }
          const takeStateKey = getTakeStateKey(this.#partitionKey, inputNode.row);
          const takeState = this.#storage.get(takeStateKey);
          if (takeState?.bound !== void 0 && this.getSchema().compareRows(takeState.bound, inputNode.row) >= 0) {
            yield inputNode;
          }
        }
      }
      *#initialFetch(req) {
        assert3(req.start === void 0);
        assert3(!req.reverse);
        assert3(constraintMatchesPartitionKey(req.constraint, this.#partitionKey));
        if (this.#limit === 0) {
          return;
        }
        const takeStateKey = getTakeStateKey(this.#partitionKey, req.constraint);
        assert3(this.#storage.get(takeStateKey) === void 0);
        let size2 = 0;
        let bound;
        let downstreamEarlyReturn = true;
        let exceptionThrown = false;
        try {
          for (const inputNode of this.#input.fetch(req)) {
            yield inputNode;
            bound = inputNode.row;
            size2++;
            if (size2 === this.#limit) {
              break;
            }
          }
          downstreamEarlyReturn = false;
        } catch (e3) {
          exceptionThrown = true;
          throw e3;
        } finally {
          if (!exceptionThrown) {
            this.#setTakeState(
              takeStateKey,
              size2,
              bound,
              this.#storage.get(MAX_BOUND_KEY)
            );
            assert3(
              !downstreamEarlyReturn,
              "Unexpected early return prevented full hydration"
            );
          }
        }
      }
      *cleanup(req) {
        assert3(req.start === void 0);
        assert3(constraintMatchesPartitionKey(req.constraint, this.#partitionKey));
        const takeStateKey = getTakeStateKey(this.#partitionKey, req.constraint);
        this.#storage.del(takeStateKey);
        let size2 = 0;
        for (const inputNode of this.#input.cleanup(req)) {
          if (size2 === this.#limit) {
            return;
          }
          size2++;
          yield inputNode;
        }
      }
      #getStateAndConstraint(row) {
        const takeStateKey = getTakeStateKey(this.#partitionKey, row);
        const takeState = this.#storage.get(takeStateKey);
        let maxBound;
        let constraint;
        if (takeState) {
          maxBound = this.#storage.get(MAX_BOUND_KEY);
          constraint = this.#partitionKey && Object.fromEntries(
            this.#partitionKey.map((key2) => [key2, row[key2]])
          );
        }
        return { takeState, takeStateKey, maxBound, constraint };
      }
      push(change) {
        if (change.type === "edit") {
          this.#pushEditChange(change);
          return;
        }
        const { takeState, takeStateKey, maxBound, constraint } = this.#getStateAndConstraint(change.node.row);
        if (!takeState) {
          return;
        }
        const { compareRows } = this.getSchema();
        if (change.type === "add") {
          if (takeState.size < this.#limit) {
            this.#setTakeState(
              takeStateKey,
              takeState.size + 1,
              takeState.bound === void 0 || compareRows(takeState.bound, change.node.row) < 0 ? change.node.row : takeState.bound,
              maxBound
            );
            this.#output.push(change);
            return;
          }
          if (takeState.bound === void 0 || compareRows(change.node.row, takeState.bound) >= 0) {
            return;
          }
          let beforeBoundNode;
          let boundNode;
          if (this.#limit === 1) {
            boundNode = must(
              first(
                this.#input.fetch({
                  start: {
                    row: takeState.bound,
                    basis: "at"
                  },
                  constraint
                })
              )
            );
          } else {
            [boundNode, beforeBoundNode] = take(
              this.#input.fetch({
                start: {
                  row: takeState.bound,
                  basis: "at"
                },
                constraint,
                reverse: true
              }),
              2
            );
          }
          const removeChange = {
            type: "remove",
            node: boundNode
          };
          this.#setTakeState(
            takeStateKey,
            takeState.size,
            beforeBoundNode === void 0 || compareRows(change.node.row, beforeBoundNode.row) > 0 ? change.node.row : beforeBoundNode.row,
            maxBound
          );
          this.#withRowHiddenFromFetch(change.node.row, () => {
            this.#output.push(removeChange);
          });
          this.#output.push(change);
        } else if (change.type === "remove") {
          if (takeState.bound === void 0) {
            return;
          }
          const compToBound = compareRows(change.node.row, takeState.bound);
          if (compToBound > 0) {
            return;
          }
          const [beforeBoundNode] = take(
            this.#input.fetch({
              start: {
                row: takeState.bound,
                basis: "after"
              },
              constraint,
              reverse: true
            }),
            1
          );
          let newBound;
          if (beforeBoundNode) {
            const push22 = compareRows(beforeBoundNode.row, takeState.bound) > 0;
            newBound = {
              node: beforeBoundNode,
              push: push22
            };
          }
          if (!newBound?.push) {
            for (const node of this.#input.fetch({
              start: {
                row: takeState.bound,
                basis: "at"
              },
              constraint
            })) {
              const push22 = compareRows(node.row, takeState.bound) > 0;
              newBound = {
                node,
                push: push22
              };
              if (push22) {
                break;
              }
            }
          }
          if (newBound?.push) {
            this.#output.push(change);
            this.#setTakeState(
              takeStateKey,
              takeState.size,
              newBound.node.row,
              maxBound
            );
            this.#output.push({
              type: "add",
              node: newBound.node
            });
            return;
          }
          this.#setTakeState(
            takeStateKey,
            takeState.size - 1,
            newBound?.node.row,
            maxBound
          );
          this.#output.push(change);
        } else if (change.type === "child") {
          if (takeState.bound && compareRows(change.node.row, takeState.bound) <= 0) {
            this.#output.push(change);
          }
        }
      }
      #pushEditChange(change) {
        assert3(
          !this.#partitionKeyComparator || this.#partitionKeyComparator(change.oldNode.row, change.node.row) === 0,
          "Unexpected change of partition key"
        );
        const { takeState, takeStateKey, maxBound, constraint } = this.#getStateAndConstraint(change.oldNode.row);
        if (!takeState) {
          return;
        }
        assert3(takeState.bound, "Bound should be set");
        const { compareRows } = this.getSchema();
        const oldCmp = compareRows(change.oldNode.row, takeState.bound);
        const newCmp = compareRows(change.node.row, takeState.bound);
        const replaceBoundAndForwardChange = /* @__PURE__ */ __name(() => {
          this.#setTakeState(
            takeStateKey,
            takeState.size,
            change.node.row,
            maxBound
          );
          this.#output.push(change);
        }, "replaceBoundAndForwardChange");
        if (oldCmp === 0) {
          if (newCmp === 0) {
            this.#output.push(change);
            return;
          }
          if (newCmp < 0) {
            if (this.#limit === 1) {
              replaceBoundAndForwardChange();
              return;
            }
            const beforeBoundNode = must(
              first(
                this.#input.fetch({
                  start: {
                    row: takeState.bound,
                    basis: "after"
                  },
                  constraint,
                  reverse: true
                })
              )
            );
            this.#setTakeState(
              takeStateKey,
              takeState.size,
              beforeBoundNode.row,
              maxBound
            );
            this.#output.push(change);
            return;
          }
          assert3(newCmp > 0);
          const newBoundNode = must(
            first(
              this.#input.fetch({
                start: {
                  row: takeState.bound,
                  basis: "at"
                },
                constraint
              })
            )
          );
          if (compareRows(newBoundNode.row, change.node.row) === 0) {
            replaceBoundAndForwardChange();
            return;
          }
          this.#setTakeState(
            takeStateKey,
            takeState.size,
            newBoundNode.row,
            maxBound
          );
          this.#output.push({
            type: "add",
            node: newBoundNode
          });
          return;
        }
        if (oldCmp > 0) {
          assert3(newCmp !== 0, "Invalid state. Row has duplicate primary key");
          if (newCmp > 0) {
            return;
          }
          assert3(newCmp < 0);
          const [oldBoundNode, newBoundNode] = take(
            this.#input.fetch({
              start: {
                row: takeState.bound,
                basis: "at"
              },
              constraint,
              reverse: true
            }),
            2
          );
          this.#setTakeState(
            takeStateKey,
            takeState.size,
            newBoundNode.row,
            maxBound
          );
          this.#withRowHiddenFromFetch(change.node.row, () => {
            this.#output.push({
              type: "remove",
              node: oldBoundNode
            });
          });
          this.#output.push({
            type: "add",
            node: change.node
          });
          return;
        }
        if (oldCmp < 0) {
          assert3(newCmp !== 0, "Invalid state. Row has duplicate primary key");
          if (newCmp < 0) {
            this.#output.push(change);
            return;
          }
          assert3(newCmp > 0);
          const afterBoundNode = must(
            first(
              this.#input.fetch({
                start: {
                  row: takeState.bound,
                  basis: "after"
                },
                constraint
              })
            )
          );
          if (compareRows(afterBoundNode.row, change.node.row) === 0) {
            replaceBoundAndForwardChange();
            return;
          }
          this.#output.push({
            type: "remove",
            node: change.oldNode
          });
          this.#setTakeState(
            takeStateKey,
            takeState.size,
            afterBoundNode.row,
            maxBound
          );
          this.#output.push({
            type: "add",
            node: afterBoundNode
          });
          return;
        }
        unreachable();
      }
      #withRowHiddenFromFetch(row, fn) {
        this.#rowHiddenFromFetch = row;
        try {
          fn();
        } finally {
          this.#rowHiddenFromFetch = void 0;
        }
      }
      #setTakeState(takeStateKey, size2, bound, maxBound) {
        this.#storage.set(takeStateKey, {
          size: size2,
          bound
        });
        if (bound !== void 0 && (maxBound === void 0 || this.getSchema().compareRows(bound, maxBound) > 0)) {
          this.#storage.set(MAX_BOUND_KEY, bound);
        }
      }
      destroy() {
        this.#input.destroy();
      }
    };
    __name(getTakeStateKey, "getTakeStateKey");
    __name(constraintMatchesPartitionKey, "constraintMatchesPartitionKey");
    __name(makePartitionKeyComparator, "makePartitionKeyComparator");
    __name(getLikePredicate, "getLikePredicate");
    __name(getLikeOp, "getLikeOp");
    specialCharsRe = /[$()*+.?[\]\\^{|}]/;
    __name(patternToRegExp, "patternToRegExp");
    __name(createPredicate, "createPredicate");
    __name(createIsPredicate, "createIsPredicate");
    __name(createPredicateImpl, "createPredicateImpl");
    __name(not2, "not");
    __name(transformFilters, "transformFilters");
    __name(buildPipeline, "buildPipeline");
    __name(buildPipelineInternal, "buildPipelineInternal");
    __name(applyWhere, "applyWhere");
    __name(applyAnd, "applyAnd");
    __name(applyOr, "applyOr");
    __name(groupSubqueryConditions, "groupSubqueryConditions");
    __name(isNotAndDoesNotContainSubquery, "isNotAndDoesNotContainSubquery");
    __name(applySimpleCondition, "applySimpleCondition");
    __name(applyCorrelatedSubQuery, "applyCorrelatedSubQuery");
    __name(applyCorrelatedSubqueryCondition, "applyCorrelatedSubqueryCondition");
    __name(gatherCorrelatedSubqueryQueriesFromCondition, "gatherCorrelatedSubqueryQueriesFromCondition");
    EXISTS_LIMIT = 3;
    PERMISSIONS_EXISTS_LIMIT = 1;
    __name(assertOrderingIncludesPK, "assertOrderingIncludesPK");
    __name(uniquifyCorrelatedSubqueryConditionAliases, "uniquifyCorrelatedSubqueryConditionAliases");
    ArrayView = class {
      static {
        __name(this, "ArrayView");
      }
      #input;
      #listeners = /* @__PURE__ */ new Set();
      #schema;
      #format;
      // Synthetic "root" entry that has a single "" relationship, so that we can
      // treat all changes, including the root change, generically.
      #root;
      onDestroy;
      #dirty = false;
      #complete = false;
      constructor(input, format2 = { singular: false, relationships: {} }, queryComplete = true) {
        this.#input = input;
        this.#schema = input.getSchema();
        this.#format = format2;
        this.#root = { "": format2.singular ? void 0 : [] };
        input.setOutput(this);
        if (queryComplete === true) {
          this.#complete = true;
        } else {
          void queryComplete.then(() => {
            this.#complete = true;
            this.#fireListeners();
          });
        }
        this.#hydrate();
      }
      get data() {
        return this.#root[""];
      }
      addListener(listener) {
        assert3(!this.#listeners.has(listener), "Listener already registered");
        this.#listeners.add(listener);
        this.#fireListener(listener);
        return () => {
          this.#listeners.delete(listener);
        };
      }
      #fireListeners() {
        for (const listener of this.#listeners) {
          this.#fireListener(listener);
        }
      }
      #fireListener(listener) {
        listener(
          this.data,
          this.#complete ? "complete" : "unknown"
        );
      }
      destroy() {
        this.onDestroy?.();
      }
      #hydrate() {
        this.#dirty = true;
        for (const node of this.#input.fetch({})) {
          applyChange(
            this.#root,
            { type: "add", node },
            this.#schema,
            "",
            this.#format
          );
        }
        this.flush();
      }
      push(change) {
        this.#dirty = true;
        applyChange(this.#root, change, this.#schema, "", this.#format);
      }
      flush() {
        if (!this.#dirty) {
          return;
        }
        this.#dirty = false;
        this.#fireListeners();
      }
    };
    ExpressionBuilder = class {
      static {
        __name(this, "ExpressionBuilder");
      }
      #exists;
      constructor(exists2) {
        this.#exists = exists2;
        this.exists = this.exists.bind(this);
      }
      get eb() {
        return this;
      }
      cmp(field, opOrValue, value) {
        return cmp(field, opOrValue, value);
      }
      cmpLit(left, op, right) {
        return {
          type: "simple",
          left: isParameterReference(left) ? left[toStaticParam]() : { type: "literal", value: left },
          right: isParameterReference(right) ? right[toStaticParam]() : { type: "literal", value: right },
          op
        };
      }
      and = and2;
      or = or2;
      not = not22;
      exists(relationship, cb) {
        return this.#exists(relationship, cb);
      }
    };
    __name(and2, "and");
    __name(or2, "or");
    __name(not22, "not2");
    __name(cmp, "cmp");
    __name(isParameterReference, "isParameterReference");
    TRUE = {
      type: "and",
      conditions: []
    };
    FALSE = {
      type: "or",
      conditions: []
    };
    __name(isAlwaysTrue, "isAlwaysTrue");
    __name(isAlwaysFalse, "isAlwaysFalse");
    __name(flatten, "flatten");
    negateSimpleOperatorMap = {
      ["="]: "!=",
      ["!="]: "=",
      ["<"]: ">=",
      [">"]: "<=",
      [">="]: "<",
      ["<="]: ">",
      ["IN"]: "NOT IN",
      ["NOT IN"]: "IN",
      ["LIKE"]: "NOT LIKE",
      ["NOT LIKE"]: "LIKE",
      ["ILIKE"]: "NOT ILIKE",
      ["NOT ILIKE"]: "ILIKE",
      ["IS"]: "IS NOT",
      ["IS NOT"]: "IS"
    };
    negateOperatorMap = {
      ...negateSimpleOperatorMap,
      ["EXISTS"]: "NOT EXISTS",
      ["NOT EXISTS"]: "EXISTS"
    };
    __name(negateOperator, "negateOperator");
    __name(filterUndefined, "filterUndefined");
    __name(filterTrue, "filterTrue");
    __name(filterFalse, "filterFalse");
    __name(dnf, "dnf");
    __name(dnfInner, "dnfInner");
    __name(distributeAnd, "distributeAnd");
    __name(unwrap, "unwrap");
    astForTestingSymbol = Symbol();
    __name(newQuery, "newQuery");
    __name(newQueryWithDetails, "newQueryWithDetails");
    __name(staticParam, "staticParam");
    SUBQ_PREFIX = "zsubq_";
    AbstractQuery = class {
      static {
        __name(this, "AbstractQuery");
      }
      #schema;
      #tableName;
      #ast;
      #format;
      #hash = "";
      constructor(schema2, tableName, ast = { table: tableName }, format2) {
        this.#schema = schema2;
        this.#tableName = tableName;
        this.#ast = ast;
        this.#format = format2 ?? { singular: false, relationships: {} };
      }
      get format() {
        return this.#format;
      }
      // Not part of Query or QueryInternal interface
      get [astForTestingSymbol]() {
        return this.#ast;
      }
      hash() {
        if (!this.#hash) {
          this.#hash = hashOfAST(this._completeAst());
        }
        return this.#hash;
      }
      one() {
        return this._newQuery(
          this.#schema,
          this.#tableName,
          {
            ...this.#ast,
            limit: 1
          },
          {
            ...this.#format,
            singular: true
          }
        );
      }
      whereExists(relationship, cb) {
        return this.where(({ exists: exists2 }) => exists2(relationship, cb));
      }
      related(relationship, cb) {
        if (relationship.startsWith(SUBQ_PREFIX)) {
          throw new Error(
            `Relationship names may not start with "${SUBQ_PREFIX}". That is a reserved prefix.`
          );
        }
        cb = cb ?? ((q) => q);
        const related = this.#schema.relationships[this.#tableName][relationship];
        assert3(related, "Invalid relationship");
        if (isOneHop(related)) {
          const { destSchema, destField, sourceField, cardinality } = related[0];
          const sq = cb(
            this._newQuery(
              this.#schema,
              destSchema,
              {
                table: destSchema,
                alias: relationship
              },
              {
                relationships: {},
                singular: cardinality === "one"
              }
            )
          );
          assert3(
            isCompoundKey(sourceField),
            "The source of a relationship must specify at last 1 field"
          );
          assert3(
            isCompoundKey(destField),
            "The destination of a relationship must specify at last 1 field"
          );
          assert3(
            sourceField.length === destField.length,
            "The source and destination of a relationship must have the same number of fields"
          );
          return this._newQuery(
            this.#schema,
            this.#tableName,
            {
              ...this.#ast,
              related: [
                ...this.#ast.related ?? [],
                {
                  system: this._system,
                  correlation: {
                    parentField: sourceField,
                    childField: destField
                  },
                  subquery: addPrimaryKeysToAst(
                    this.#schema.tables[destSchema],
                    sq.#ast
                  )
                }
              ]
            },
            {
              ...this.#format,
              relationships: {
                ...this.#format.relationships,
                [relationship]: sq.#format
              }
            }
          );
        }
        if (isTwoHop(related)) {
          assert3(related.length === 2, "Invalid relationship");
          const [firstRelation, secondRelation] = related;
          const { destSchema } = secondRelation;
          const junctionSchema = firstRelation.destSchema;
          const sq = cb(
            this._newQuery(
              this.#schema,
              destSchema,
              {
                table: destSchema,
                alias: relationship
              },
              {
                relationships: {},
                singular: secondRelation.cardinality === "one"
              }
            )
          );
          assert3(isCompoundKey(firstRelation.sourceField), "Invalid relationship");
          assert3(isCompoundKey(firstRelation.destField), "Invalid relationship");
          assert3(isCompoundKey(secondRelation.sourceField), "Invalid relationship");
          assert3(isCompoundKey(secondRelation.destField), "Invalid relationship");
          return this._newQuery(
            this.#schema,
            this.#tableName,
            {
              ...this.#ast,
              related: [
                ...this.#ast.related ?? [],
                {
                  system: this._system,
                  correlation: {
                    parentField: firstRelation.sourceField,
                    childField: firstRelation.destField
                  },
                  hidden: true,
                  subquery: {
                    table: junctionSchema,
                    alias: relationship,
                    orderBy: addPrimaryKeys(
                      this.#schema.tables[junctionSchema],
                      void 0
                    ),
                    related: [
                      {
                        system: this._system,
                        correlation: {
                          parentField: secondRelation.sourceField,
                          childField: secondRelation.destField
                        },
                        subquery: addPrimaryKeysToAst(
                          this.#schema.tables[destSchema],
                          sq.#ast
                        )
                      }
                    ]
                  }
                }
              ]
            },
            {
              ...this.#format,
              relationships: {
                ...this.#format.relationships,
                [relationship]: sq.#format
              }
            }
          );
        }
        throw new Error(`Invalid relationship ${relationship}`);
      }
      where(fieldOrExpressionFactory, opOrValue, value) {
        let cond;
        if (typeof fieldOrExpressionFactory === "function") {
          cond = fieldOrExpressionFactory(
            new ExpressionBuilder(this._exists)
          );
        } else {
          assert3(opOrValue !== void 0, "Invalid condition");
          cond = cmp(fieldOrExpressionFactory, opOrValue, value);
        }
        const existingWhere = this.#ast.where;
        if (existingWhere) {
          cond = and2(existingWhere, cond);
        }
        return this._newQuery(
          this.#schema,
          this.#tableName,
          {
            ...this.#ast,
            where: dnf(cond)
          },
          this.#format
        );
      }
      start(row, opts) {
        return this._newQuery(
          this.#schema,
          this.#tableName,
          {
            ...this.#ast,
            start: {
              row,
              exclusive: !opts?.inclusive
            }
          },
          this.#format
        );
      }
      limit(limit) {
        if (limit < 0) {
          throw new Error("Limit must be non-negative");
        }
        if ((limit | 0) !== limit) {
          throw new Error("Limit must be an integer");
        }
        return this._newQuery(
          this.#schema,
          this.#tableName,
          {
            ...this.#ast,
            limit
          },
          this.#format
        );
      }
      orderBy(field, direction) {
        return this._newQuery(
          this.#schema,
          this.#tableName,
          {
            ...this.#ast,
            orderBy: [...this.#ast.orderBy ?? [], [field, direction]]
          },
          this.#format
        );
      }
      _exists = /* @__PURE__ */ __name((relationship, cb = (q) => q) => {
        const related = this.#schema.relationships[this.#tableName][relationship];
        assert3(related, "Invalid relationship");
        if (isOneHop(related)) {
          const { destSchema, sourceField, destField } = related[0];
          assert3(isCompoundKey(sourceField), "Invalid relationship");
          assert3(isCompoundKey(destField), "Invalid relationship");
          const sq = cb(
            this._newQuery(
              this.#schema,
              destSchema,
              {
                table: destSchema,
                alias: `${SUBQ_PREFIX}${relationship}`
              },
              void 0
            )
          );
          return {
            type: "correlatedSubquery",
            related: {
              system: this._system,
              correlation: {
                parentField: sourceField,
                childField: destField
              },
              subquery: addPrimaryKeysToAst(
                this.#schema.tables[destSchema],
                sq.#ast
              )
            },
            op: "EXISTS"
          };
        }
        if (isTwoHop(related)) {
          assert3(related.length === 2, "Invalid relationship");
          const [firstRelation, secondRelation] = related;
          assert3(isCompoundKey(firstRelation.sourceField), "Invalid relationship");
          assert3(isCompoundKey(firstRelation.destField), "Invalid relationship");
          assert3(isCompoundKey(secondRelation.sourceField), "Invalid relationship");
          assert3(isCompoundKey(secondRelation.destField), "Invalid relationship");
          const { destSchema } = secondRelation;
          const junctionSchema = firstRelation.destSchema;
          const queryToDest = cb(
            this._newQuery(
              this.#schema,
              destSchema,
              {
                table: destSchema,
                alias: `${SUBQ_PREFIX}${relationship}`
              },
              void 0
            )
          );
          return {
            type: "correlatedSubquery",
            related: {
              system: this._system,
              correlation: {
                parentField: firstRelation.sourceField,
                childField: firstRelation.destField
              },
              subquery: {
                table: junctionSchema,
                alias: `${SUBQ_PREFIX}${relationship}`,
                orderBy: addPrimaryKeys(
                  this.#schema.tables[junctionSchema],
                  void 0
                ),
                where: {
                  type: "correlatedSubquery",
                  related: {
                    system: this._system,
                    correlation: {
                      parentField: secondRelation.sourceField,
                      childField: secondRelation.destField
                    },
                    subquery: addPrimaryKeysToAst(
                      this.#schema.tables[destSchema],
                      queryToDest.#ast
                    )
                  },
                  op: "EXISTS"
                }
              }
            },
            op: "EXISTS"
          };
        }
        throw new Error(`Invalid relationship ${relationship}`);
      }, "_exists");
      #completedAST;
      _completeAst() {
        if (!this.#completedAST) {
          const finalOrderBy = addPrimaryKeys(
            this.#schema.tables[this.#tableName],
            this.#ast.orderBy
          );
          if (this.#ast.start) {
            const { row } = this.#ast.start;
            const narrowedRow = {};
            for (const [field] of finalOrderBy) {
              narrowedRow[field] = row[field];
            }
            this.#completedAST = {
              ...this.#ast,
              start: {
                ...this.#ast.start,
                row: narrowedRow
              },
              orderBy: finalOrderBy
            };
          } else {
            this.#completedAST = {
              ...this.#ast,
              orderBy: addPrimaryKeys(
                this.#schema.tables[this.#tableName],
                this.#ast.orderBy
              )
            };
          }
        }
        return this.#completedAST;
      }
    };
    completedAstSymbol = Symbol();
    QueryImpl = class extends AbstractQuery {
      static {
        __name(this, "QueryImpl");
      }
      #delegate;
      constructor(delegate, schema2, tableName, ast, format2) {
        super(schema2, tableName, ast, format2);
        this.#delegate = delegate;
      }
      _system = "client";
      get [completedAstSymbol]() {
        return this._completeAst();
      }
      _newQuery(schema2, tableName, ast, format2) {
        return newQueryWithDetails(this.#delegate, schema2, tableName, ast, format2);
      }
      materialize(factoryOrTTL, ttl = DEFAULT_TTL) {
        const t0 = Date.now();
        let factory;
        if (typeof factoryOrTTL === "function") {
          factory = factoryOrTTL;
        } else {
          ttl = factoryOrTTL ?? DEFAULT_TTL;
        }
        const ast = this._completeAst();
        const queryCompleteResolver = resolver();
        let queryGot = false;
        const removeServerQuery = this.#delegate.addServerQuery(ast, ttl, (got) => {
          if (got) {
            const t1 = Date.now();
            this.#delegate.onQueryMaterialized(this.hash(), ast, t1 - t0);
            queryGot = true;
            queryCompleteResolver.resolve(true);
          }
        });
        const input = buildPipeline(ast, this.#delegate);
        let removeCommitObserver;
        const onDestroy = /* @__PURE__ */ __name(() => {
          input.destroy();
          removeCommitObserver?.();
          removeServerQuery();
        }, "onDestroy");
        const view = this.#delegate.batchViewUpdates(
          () => (factory ?? arrayViewFactory)(
            this,
            input,
            this.format,
            onDestroy,
            (cb) => {
              removeCommitObserver = this.#delegate.onTransactionCommit(cb);
            },
            queryGot || queryCompleteResolver.promise
          )
        );
        return view;
      }
      updateTTL(ttl) {
        this.#delegate.updateServerQuery(this._completeAst(), ttl);
      }
      run() {
        const v2 = this.materialize();
        const ret = v2.data;
        v2.destroy();
        return Promise.resolve(ret);
      }
      preload(options2) {
        const { resolve: resolve2, promise: complete } = resolver();
        const ast = this._completeAst();
        const unsub = this.#delegate.addServerQuery(
          ast,
          options2?.ttl ?? DEFAULT_TTL,
          (got) => {
            if (got) {
              resolve2();
            }
          }
        );
        return {
          cleanup: unsub,
          complete
        };
      }
    };
    __name(addPrimaryKeys, "addPrimaryKeys");
    __name(addPrimaryKeysToAst, "addPrimaryKeysToAst");
    __name(arrayViewFactory, "arrayViewFactory");
    __name(isCompoundKey, "isCompoundKey");
    StaticQuery = class _StaticQuery extends AbstractQuery {
      static {
        __name(this, "_StaticQuery");
      }
      expressionBuilder() {
        return new ExpressionBuilder(this._exists);
      }
      _system = "permissions";
      _newQuery(schema2, tableName, ast, format2) {
        return new _StaticQuery(schema2, tableName, ast, format2);
      }
      get ast() {
        return this._completeAst();
      }
      materialize() {
        throw new Error("StaticQuery cannot be materialized");
      }
      run() {
        return Promise.reject(new Error("StaticQuery cannot be run"));
      }
      preload() {
        throw new Error("StaticQuery cannot be preloaded");
      }
      updateTTL(_ttl) {
        throw new Error("StaticQuery cannot have a TTL");
      }
    };
    __name(clientToServer, "clientToServer");
    __name(serverToClient, "serverToClient");
    __name(createMapperFrom, "createMapperFrom");
    NameMapper = class {
      static {
        __name(this, "NameMapper");
      }
      #tables = /* @__PURE__ */ new Map();
      constructor(tables) {
        this.#tables = tables;
      }
      #getTable(src, ctx) {
        const table22 = this.#tables.get(src);
        if (!table22) {
          throw new Error(
            `unknown table "${src}" ${!ctx ? "" : `in ${JSON.stringify(ctx)}`}`
          );
        }
        return table22;
      }
      tableName(src, context3) {
        return this.#getTable(src, context3).tableName;
      }
      columnName(table22, src, ctx) {
        const dst = this.#getTable(table22, ctx).columns[src];
        if (!dst) {
          throw new Error(
            `unknown column "${src}" of "${table22}" table ${!ctx ? "" : `in ${JSON.stringify(ctx)}`}`
          );
        }
        return dst;
      }
      row(table22, row) {
        const dest = this.#getTable(table22);
        const { allColumnsSame, columns } = dest;
        if (allColumnsSame) {
          return row;
        }
        const clientRow = {};
        for (const col in row) {
          clientRow[columns[col] ?? col] = row[col];
        }
        return clientRow;
      }
      columns(table22, cols) {
        const dest = this.#getTable(table22);
        const { allColumnsSame, columns } = dest;
        return cols === void 0 || allColumnsSame ? cols : cols.map((col) => columns[col] ?? col);
      }
    };
    ANYONE_CAN = [
      (_, eb) => eb.and()
    ];
    __name(definePermissions, "definePermissions");
    __name(compilePermissions, "compilePermissions");
    __name(compileRowConfig, "compileRowConfig");
    __name(compileRules, "compileRules");
    __name(compileCellConfig, "compileCellConfig");
    CallTracker = class _CallTracker {
      static {
        __name(this, "_CallTracker");
      }
      #anchor;
      #path;
      constructor(anchor, path2) {
        this.#anchor = anchor;
        this.#path = path2;
      }
      get(target, prop) {
        if (prop === toStaticParam) {
          return target[toStaticParam];
        }
        assert3(typeof prop === "string");
        const path2 = [...this.#path, prop];
        return new Proxy(
          {
            [toStaticParam]: () => staticParam(this.#anchor, path2)
          },
          new _CallTracker(this.#anchor, path2)
        );
      }
    };
    __name(baseTracker, "baseTracker");
    authDataRef = baseTracker("authData");
    preMutationRowRef = baseTracker("preMutationRow");
    deleteClientsBodySchema = valita_exports.union(
      readonlyObject({
        clientIDs: readonlyArray(valita_exports.string()).optional(),
        clientGroupIDs: readonlyArray(valita_exports.string()).optional()
      })
    );
    deleteClientsMessageSchema = valita_exports.tuple([
      valita_exports.literal("deleteClients"),
      deleteClientsBodySchema
    ]);
    putOpSchema = valita_exports.object({
      op: valita_exports.literal("put"),
      hash: valita_exports.string(),
      ast: astSchema,
      ttl: valita_exports.number().optional()
    });
    delOpSchema = valita_exports.object({
      op: valita_exports.literal("del"),
      hash: valita_exports.string()
    });
    clearOpSchema = valita_exports.object({
      op: valita_exports.literal("clear")
    });
    patchOpSchema = valita_exports.union(putOpSchema, delOpSchema, clearOpSchema);
    queriesPatchSchema = valita_exports.array(patchOpSchema);
    connectedBodySchema = valita_exports.object({
      wsid: valita_exports.string(),
      timestamp: valita_exports.number().optional()
    });
    connectedMessageSchema = valita_exports.tuple([
      valita_exports.literal("connected"),
      connectedBodySchema
    ]);
    initConnectionBodySchema = valita_exports.object({
      desiredQueriesPatch: queriesPatchSchema,
      clientSchema: clientSchemaSchema.optional(),
      deleted: deleteClientsBodySchema.optional()
    });
    initConnectionMessageSchema = valita_exports.tuple([
      valita_exports.literal("initConnection"),
      initConnectionBodySchema
    ]);
    __name(encodeSecProtocols, "encodeSecProtocols");
    AuthInvalidated = "AuthInvalidated";
    ClientNotFound = "ClientNotFound";
    InvalidConnectionRequest = "InvalidConnectionRequest";
    InvalidConnectionRequestBaseCookie = "InvalidConnectionRequestBaseCookie";
    InvalidConnectionRequestLastMutationID = "InvalidConnectionRequestLastMutationID";
    InvalidConnectionRequestClientDeleted = "InvalidConnectionRequestClientDeleted";
    InvalidMessage = "InvalidMessage";
    InvalidPush = "InvalidPush";
    MutationFailed = "MutationFailed";
    MutationRateLimited = "MutationRateLimited";
    Rebalance = "Rebalance";
    Rehome = "Rehome";
    Unauthorized = "Unauthorized";
    VersionNotSupported = "VersionNotSupported";
    SchemaVersionNotSupported = "SchemaVersionNotSupported";
    ServerOverloaded = "ServerOverloaded";
    Internal = "Internal";
    basicErrorKindSchema = valita_exports.union(
      valita_exports.literal(AuthInvalidated),
      valita_exports.literal(ClientNotFound),
      valita_exports.literal(InvalidConnectionRequest),
      valita_exports.literal(InvalidConnectionRequestBaseCookie),
      valita_exports.literal(InvalidConnectionRequestLastMutationID),
      valita_exports.literal(InvalidConnectionRequestClientDeleted),
      valita_exports.literal(InvalidMessage),
      valita_exports.literal(InvalidPush),
      valita_exports.literal(MutationRateLimited),
      valita_exports.literal(MutationFailed),
      valita_exports.literal(Unauthorized),
      valita_exports.literal(VersionNotSupported),
      valita_exports.literal(SchemaVersionNotSupported),
      valita_exports.literal(Internal)
    );
    basicErrorBodySchema = valita_exports.object({
      kind: basicErrorKindSchema,
      message: valita_exports.string()
    });
    backoffErrorKindSchema = valita_exports.union(
      valita_exports.literal(Rebalance),
      valita_exports.literal(Rehome),
      valita_exports.literal(ServerOverloaded)
    );
    backoffBodySchema = valita_exports.object({
      kind: backoffErrorKindSchema,
      message: valita_exports.string(),
      minBackoffMs: valita_exports.number().optional(),
      maxBackoffMs: valita_exports.number().optional(),
      // Query parameters to send in the next reconnect. In the event of
      // a conflict, these will be overridden by the parameters used by
      // the client; it is the responsibility of the server to avoid
      // parameter name conflicts.
      //
      // The parameters will only be added to the immediately following
      // reconnect, and not after that.
      reconnectParams: valita_exports.record(valita_exports.string()).optional()
    });
    errorBodySchema = valita_exports.union(basicErrorBodySchema, backoffBodySchema);
    errorMessageSchema = valita_exports.tuple([
      valita_exports.literal("error"),
      errorBodySchema
    ]);
    primaryKeySchema = readonly(
      valita_exports.tuple([valita_exports.string()]).concat(valita_exports.array(valita_exports.string()))
    );
    primaryKeyValueSchema = valita_exports.union(
      valita_exports.string(),
      valita_exports.number(),
      valita_exports.boolean()
    );
    primaryKeyValueRecordSchema = readonlyRecord(
      primaryKeyValueSchema
    );
    putOpSchema2 = valita_exports.object({
      op: valita_exports.literal("put"),
      tableName: valita_exports.string(),
      value: rowSchema
    });
    updateOpSchema = valita_exports.object({
      op: valita_exports.literal("update"),
      tableName: valita_exports.string(),
      id: primaryKeyValueRecordSchema,
      merge: jsonObjectSchema.optional(),
      constrain: valita_exports.array(valita_exports.string()).optional()
    });
    delOpSchema2 = valita_exports.object({
      op: valita_exports.literal("del"),
      tableName: valita_exports.string(),
      id: primaryKeyValueRecordSchema
    });
    clearOpSchema2 = valita_exports.object({
      op: valita_exports.literal("clear")
    });
    rowPatchOpSchema = valita_exports.union(
      putOpSchema2,
      updateOpSchema,
      delOpSchema2,
      clearOpSchema2
    );
    rowsPatchSchema = valita_exports.array(rowPatchOpSchema);
    versionSchema = valita_exports.string();
    nullableVersionSchema = valita_exports.union(versionSchema, valita_exports.null());
    pokeStartBodySchema = valita_exports.object({
      pokeID: valita_exports.string(),
      // We always specify a Version as our cookie, but Replicache starts clients
      // with initial cookie `null`, before the first request. So we have to be
      // able to send a base cookie with value `null` to match that state.
      baseCookie: nullableVersionSchema,
      // Deprecated: Replaced by pokeEnd.cookie.
      cookie: versionSchema.optional(),
      /**
       * This field is always set if the poke contains a `rowsPatch`.
       * It may be absent for patches that only update clients and queries.
       */
      schemaVersions: valita_exports.object({
        minSupportedVersion: valita_exports.number(),
        maxSupportedVersion: valita_exports.number()
      }).optional(),
      timestamp: valita_exports.number().optional()
    });
    pokePartBodySchema = valita_exports.object({
      pokeID: valita_exports.string(),
      // Changes to last mutation id by client id.
      lastMutationIDChanges: valita_exports.record(valita_exports.number()).optional(),
      // Patches to the desired query sets by client id.
      desiredQueriesPatches: valita_exports.record(queriesPatchSchema).optional(),
      // Patches to the set of queries for which entities are sync'd in
      // rowsPatch.
      gotQueriesPatch: queriesPatchSchema.optional(),
      // Patches to the rows set.
      rowsPatch: rowsPatchSchema.optional()
    });
    pokeEndBodySchema = valita_exports.object({
      pokeID: valita_exports.string(),
      // Note: This should be ignored (and may be empty) if cancel === `true`.
      cookie: versionSchema,
      // If `true`, the poke with id `pokeID` should be discarded without
      // applying it.
      cancel: valita_exports.boolean().optional()
    });
    pokeStartMessageSchema = valita_exports.tuple([
      valita_exports.literal("pokeStart"),
      pokeStartBodySchema
    ]);
    pokePartMessageSchema = valita_exports.tuple([
      valita_exports.literal("pokePart"),
      pokePartBodySchema
    ]);
    pokeEndMessageSchema = valita_exports.tuple([
      valita_exports.literal("pokeEnd"),
      pokeEndBodySchema
    ]);
    pongBodySchema = valita_exports.object({});
    pongMessageSchema = valita_exports.tuple([valita_exports.literal("pong"), pongBodySchema]);
    pullRequestBodySchema = valita_exports.object({
      clientGroupID: valita_exports.string(),
      cookie: nullableVersionSchema,
      requestID: valita_exports.string()
    });
    pullResponseBodySchema = valita_exports.object({
      cookie: versionSchema,
      // Matches pullRequestBodySchema requestID that initiated this response
      requestID: valita_exports.string(),
      lastMutationIDChanges: valita_exports.record(valita_exports.number())
      // Pull is currently only used for mutation recovery which does not use
      // the patch so we save work by not computing the patch.
    });
    pullRequestMessageSchema = valita_exports.tuple([
      valita_exports.literal("pull"),
      pullRequestBodySchema
    ]);
    pullResponseMessageSchema = valita_exports.tuple([
      valita_exports.literal("pull"),
      pullResponseBodySchema
    ]);
    warmBodySchema = valita_exports.object({
      payload: valita_exports.string()
    });
    warmMessageSchema = valita_exports.tuple([valita_exports.literal("warm"), warmBodySchema]);
    downstreamSchema = valita_exports.union(
      connectedMessageSchema,
      warmMessageSchema,
      errorMessageSchema,
      pongMessageSchema,
      pokeStartMessageSchema,
      pokePartMessageSchema,
      pokeEndMessageSchema,
      pullResponseMessageSchema,
      deleteClientsMessageSchema
    );
    CRUD = "crud";
    Custom = "custom";
    PROTOCOL_VERSION = 7;
    MIN_SERVER_SUPPORTED_SYNC_PROTOCOL = 2;
    assert3(MIN_SERVER_SUPPORTED_SYNC_PROTOCOL < PROTOCOL_VERSION);
    MIN_SERVER_SUPPORTED_PERMISSIONS_PROTOCOL = 4;
    assert3(MIN_SERVER_SUPPORTED_PERMISSIONS_PROTOCOL < PROTOCOL_VERSION);
    CRUD_MUTATION_NAME = "_zero_crud";
    insertOpSchema = valita_exports.object({
      op: valita_exports.literal("insert"),
      tableName: valita_exports.string(),
      primaryKey: primaryKeySchema,
      value: rowSchema
    });
    upsertOpSchema = valita_exports.object({
      op: valita_exports.literal("upsert"),
      tableName: valita_exports.string(),
      primaryKey: primaryKeySchema,
      value: rowSchema
    });
    updateOpSchema2 = valita_exports.object({
      op: valita_exports.literal("update"),
      tableName: valita_exports.string(),
      primaryKey: primaryKeySchema,
      // Partial value with at least the primary key fields
      value: rowSchema
    });
    deleteOpSchema = valita_exports.object({
      op: valita_exports.literal("delete"),
      tableName: valita_exports.string(),
      primaryKey: primaryKeySchema,
      // Partial value representing the primary key
      value: primaryKeyValueRecordSchema
    });
    crudOpSchema = valita_exports.union(
      insertOpSchema,
      upsertOpSchema,
      updateOpSchema2,
      deleteOpSchema
    );
    crudArgSchema = valita_exports.object({
      ops: valita_exports.array(crudOpSchema)
    });
    crudArgsSchema = valita_exports.tuple([crudArgSchema]);
    crudMutationSchema = valita_exports.object({
      type: valita_exports.literal(CRUD),
      id: valita_exports.number(),
      clientID: valita_exports.string(),
      name: valita_exports.literal(CRUD_MUTATION_NAME),
      args: crudArgsSchema,
      timestamp: valita_exports.number()
    });
    customMutationSchema = valita_exports.object({
      type: valita_exports.literal(Custom),
      id: valita_exports.number(),
      clientID: valita_exports.string(),
      name: valita_exports.string(),
      args: valita_exports.array(jsonSchema),
      timestamp: valita_exports.number()
    });
    mutationSchema = valita_exports.union(crudMutationSchema, customMutationSchema);
    pushBodySchema = valita_exports.object({
      clientGroupID: valita_exports.string(),
      mutations: valita_exports.array(mutationSchema),
      pushVersion: valita_exports.number(),
      // For legacy (CRUD) mutations, the schema is tied to the client group /
      // sync connection. For custom mutations, schema versioning is delegated
      // to the custom protocol / api-server.
      schemaVersion: valita_exports.number().optional(),
      timestamp: valita_exports.number(),
      requestID: valita_exports.string()
    });
    pushMessageSchema = valita_exports.tuple([valita_exports.literal("push"), pushBodySchema]);
    mutationIDSchema = valita_exports.object({
      id: valita_exports.number(),
      clientID: valita_exports.string()
    });
    appErrorSchema = valita_exports.object({
      error: valita_exports.literal("app"),
      details: valita_exports.string()
    });
    zeroErrorSchema = valita_exports.object({
      error: valita_exports.literal("ooo-mutation")
    });
    mutationOkSchema = valita_exports.object({});
    mutationErrorSchema = valita_exports.union(appErrorSchema, zeroErrorSchema);
    mutationResultSchema = valita_exports.union(mutationOkSchema, mutationErrorSchema);
    mutationResponseSchema = valita_exports.object({
      id: mutationIDSchema,
      result: mutationResultSchema
    });
    pushOkSchema = valita_exports.object({
      mutations: valita_exports.array(mutationResponseSchema)
    });
    unsupportedPushVersionSchema = valita_exports.object({
      error: valita_exports.literal("unsupported-push-version")
    });
    unsupportedSchemaVersionSchema = valita_exports.object({
      error: valita_exports.literal("unsupported-schema-version")
    });
    pushErrorSchema = valita_exports.union(
      unsupportedPushVersionSchema,
      unsupportedSchemaVersionSchema
    );
    pushResponseSchema = valita_exports.union(pushOkSchema, pushErrorSchema);
    __name(mapCRUD, "mapCRUD");
    __name(customMutatorKey, "customMutatorKey");
    __name(nanoid, "nanoid");
    __name(send2, "send");
    Disconnected = 0;
    Connecting = 1;
    Connected = 2;
    MAX_NODE_SIZE = 32;
    BTreeSet = class _BTreeSet {
      static {
        __name(this, "_BTreeSet");
      }
      #root = emptyLeaf;
      size = 0;
      comparator;
      constructor(comparator2, entries) {
        this.comparator = comparator2;
        if (entries) {
          for (const key2 of entries) {
            this.add(key2);
          }
        }
      }
      /** Releases the tree so that its size is 0. */
      clear() {
        this.#root = emptyLeaf;
        this.size = 0;
      }
      clone() {
        this.#root.isShared = true;
        const ret = new _BTreeSet(this.comparator);
        ret.#root = this.#root;
        ret.size = this.size;
        return ret;
      }
      get(key2) {
        return this.#root.get(key2, this);
      }
      add(key2) {
        if (this.#root.isShared) this.#root = this.#root.clone();
        const result = this.#root.set(key2, this);
        if (result === null) return this;
        this.#root = new BNodeInternal([this.#root, result]);
        return this;
      }
      /**
       * Returns true if the key exists in the B+ tree, false if not.
       * Use get() for best performance; use has() if you need to
       * distinguish between "undefined value" and "key not present".
       * @param key Key to detect
       * @description Computational complexity: O(log size)
       */
      has(key2) {
        return this.#root.has(key2, this);
      }
      /**
       * Removes a single key-value pair from the B+ tree.
       * @param key Key to find
       * @returns true if a pair was found and removed, false otherwise.
       * @description Computational complexity: O(log size)
       */
      delete(key2) {
        return this.#delete(key2);
      }
      #delete(key2) {
        let root2 = this.#root;
        if (root2.isShared) {
          this.#root = root2 = root2.clone();
        }
        try {
          return root2.delete(key2, this);
        } finally {
          let isShared;
          while (root2.keys.length <= 1 && root2.isInternal()) {
            isShared ||= root2.isShared;
            this.#root = root2 = root2.keys.length === 0 ? emptyLeaf : root2.children[0];
          }
          if (isShared) {
            root2.isShared = true;
          }
        }
      }
      keys() {
        return valuesFrom(this.#root, this.comparator, void 0, true);
      }
      values() {
        return valuesFrom(this.#root, this.comparator, void 0, true);
      }
      valuesFrom(lowestKey, inclusive = true) {
        return valuesFrom(this.#root, this.comparator, lowestKey, inclusive);
      }
      valuesReversed() {
        return valuesFromReversed(
          this.#maxKey(),
          this.#root,
          this.comparator,
          void 0,
          true
        );
      }
      valuesFromReversed(highestKey, inclusive = true) {
        return valuesFromReversed(
          this.#maxKey(),
          this.#root,
          this.comparator,
          highestKey,
          inclusive
        );
      }
      /** Gets the highest key in the tree. Complexity: O(1) */
      #maxKey() {
        return this.#root.maxKey();
      }
      [Symbol.iterator]() {
        return this.keys();
      }
    };
    __name(valuesFrom, "valuesFrom");
    __name(valuesFromReversed, "valuesFromReversed");
    __name(findPath, "findPath");
    __name(iterator, "iterator");
    BNode = class _BNode {
      static {
        __name(this, "_BNode");
      }
      // If this is an internal node, _keys[i] is the highest key in children[i].
      keys;
      // True if this node might be within multiple `BTree`s (or have multiple parents).
      // If so, it must be cloned before being mutated to avoid changing an unrelated tree.
      // This is transitive: if it's true, children are also shared even if `isShared!=true`
      // in those children. (Certain operations will propagate isShared=true to children.)
      isShared;
      constructor(keys) {
        this.keys = keys;
        this.isShared = void 0;
      }
      isInternal() {
        return false;
      }
      maxKey() {
        return this.keys[this.keys.length - 1];
      }
      minKey() {
        return this.keys[0];
      }
      clone() {
        return new _BNode(this.keys.slice(0));
      }
      get(key2, tree) {
        const i = indexOf(key2, this.keys, -1, tree.comparator);
        return i < 0 ? void 0 : this.keys[i];
      }
      has(key2, tree) {
        const i = indexOf(key2, this.keys, -1, tree.comparator);
        return i >= 0 && i < this.keys.length;
      }
      set(key2, tree) {
        let i = indexOf(key2, this.keys, -1, tree.comparator);
        if (i < 0) {
          i = ~i;
          tree.size++;
          if (this.keys.length < MAX_NODE_SIZE) {
            this.keys.splice(i, 0, key2);
            return null;
          }
          const newRightSibling = this.splitOffRightSide();
          let target = this;
          if (i > this.keys.length) {
            i -= this.keys.length;
            target = newRightSibling;
          }
          target.keys.splice(i, 0, key2);
          return newRightSibling;
        }
        this.keys[i] = key2;
        return null;
      }
      takeFromRight(rhs) {
        this.keys.push(rhs.keys.shift());
      }
      takeFromLeft(lhs) {
        this.keys.unshift(lhs.keys.pop());
      }
      splitOffRightSide() {
        const half = this.keys.length >> 1;
        const keys = this.keys.splice(half);
        return new _BNode(keys);
      }
      delete(key2, tree) {
        const cmp2 = tree.comparator;
        const iLow = indexOf(key2, this.keys, -1, cmp2);
        const iHigh = iLow + 1;
        if (iLow < 0) {
          return false;
        }
        const { keys } = this;
        for (let i = iLow; i < iHigh; i++) {
          const key22 = keys[i];
          if (key22 !== keys[i] || this.isShared === true) {
            throw new Error("BTree illegally changed or cloned in delete");
          }
          this.keys.splice(i, 1);
          tree.size--;
          return true;
        }
        return false;
      }
      mergeSibling(rhs, _) {
        this.keys.push(...rhs.keys);
      }
    };
    BNodeInternal = class _BNodeInternal extends BNode {
      static {
        __name(this, "_BNodeInternal");
      }
      // Note: conventionally B+ trees have one fewer key than the number of
      // children, but I find it easier to keep the array lengths equal: each
      // keys[i] caches the value of children[i].maxKey().
      children;
      /**
       * This does not mark `children` as shared, so it is the responsibility of the caller
       * to ensure children are either marked shared, or aren't included in another tree.
       */
      constructor(children, keys) {
        if (!keys) {
          keys = [];
          for (let i = 0; i < children.length; i++) {
            keys[i] = children[i].maxKey();
          }
        }
        super(keys);
        this.children = children;
      }
      isInternal() {
        return true;
      }
      clone() {
        const children = this.children.slice(0);
        for (let i = 0; i < children.length; i++) {
          children[i].isShared = true;
        }
        return new _BNodeInternal(children, this.keys.slice(0));
      }
      minKey() {
        return this.children[0].minKey();
      }
      get(key2, tree) {
        const i = indexOf(key2, this.keys, 0, tree.comparator);
        const { children } = this;
        return i < children.length ? children[i].get(key2, tree) : void 0;
      }
      has(key2, tree) {
        const i = indexOf(key2, this.keys, 0, tree.comparator);
        const { children } = this;
        return i < children.length ? children[i].has(key2, tree) : false;
      }
      set(key2, tree) {
        const c2 = this.children;
        const cmp2 = tree.comparator;
        let i = Math.min(indexOf(key2, this.keys, 0, cmp2), c2.length - 1);
        let child = c2[i];
        if (child.isShared) {
          c2[i] = child = child.clone();
        }
        if (child.keys.length >= MAX_NODE_SIZE) {
          let other;
          if (i > 0 && (other = c2[i - 1]).keys.length < MAX_NODE_SIZE && cmp2(child.keys[0], key2) < 0) {
            if (other.isShared) {
              c2[i - 1] = other = other.clone();
            }
            other.takeFromRight(child);
            this.keys[i - 1] = other.maxKey();
          } else if ((other = c2[i + 1]) !== void 0 && other.keys.length < MAX_NODE_SIZE && cmp2(child.maxKey(), key2) < 0) {
            if (other.isShared) c2[i + 1] = other = other.clone();
            other.takeFromLeft(child);
            this.keys[i] = c2[i].maxKey();
          }
        }
        const result = child.set(key2, tree);
        this.keys[i] = child.maxKey();
        if (result === null) return null;
        if (this.keys.length < MAX_NODE_SIZE) {
          this.insert(i + 1, result);
          return null;
        }
        const newRightSibling = this.splitOffRightSide();
        let target = this;
        if (cmp2(result.maxKey(), this.maxKey()) > 0) {
          target = newRightSibling;
          i -= this.keys.length;
        }
        target.insert(i + 1, result);
        return newRightSibling;
      }
      /**
       * Inserts `child` at index `i`.
       * This does not mark `child` as shared, so it is the responsibility of the caller
       * to ensure that either child is marked shared, or it is not included in another tree.
       */
      insert(i, child) {
        this.children.splice(i, 0, child);
        this.keys.splice(i, 0, child.maxKey());
      }
      /**
       * Split this node.
       * Modifies this to remove the second half of the items, returning a separate node containing them.
       */
      splitOffRightSide() {
        const half = this.children.length >> 1;
        return new _BNodeInternal(
          this.children.splice(half),
          this.keys.splice(half)
        );
      }
      takeFromRight(rhs) {
        this.keys.push(rhs.keys.shift());
        this.children.push(rhs.children.shift());
      }
      takeFromLeft(lhs) {
        this.keys.unshift(lhs.keys.pop());
        this.children.unshift(lhs.children.pop());
      }
      delete(key2, tree) {
        const cmp2 = tree.comparator;
        const { keys } = this;
        const { children } = this;
        let iLow = indexOf(key2, this.keys, 0, cmp2);
        let i = iLow;
        const iHigh = Math.min(iLow, keys.length - 1);
        if (i <= iHigh) {
          try {
            if (children[i].isShared) {
              children[i] = children[i].clone();
            }
            const result = children[i].delete(key2, tree);
            keys[i] = children[i].maxKey();
            return result;
          } finally {
            const half = MAX_NODE_SIZE >> 1;
            if (iLow > 0) iLow--;
            for (i = iHigh; i >= iLow; i--) {
              if (children[i].keys.length <= half) {
                if (children[i].keys.length !== 0) {
                  this.tryMerge(i, MAX_NODE_SIZE);
                } else {
                  keys.splice(i, 1);
                  children.splice(i, 1);
                }
              }
            }
          }
        }
        return false;
      }
      /** Merges child i with child i+1 if their combined size is not too large */
      tryMerge(i, maxSize) {
        const { children } = this;
        if (i >= 0 && i + 1 < children.length) {
          if (children[i].keys.length + children[i + 1].keys.length <= maxSize) {
            if (children[i].isShared)
              children[i] = children[i].clone();
            children[i].mergeSibling(children[i + 1], maxSize);
            children.splice(i + 1, 1);
            this.keys.splice(i + 1, 1);
            this.keys[i] = children[i].maxKey();
            return true;
          }
        }
        return false;
      }
      /**
       * Move children from `rhs` into this.
       * `rhs` must be part of this tree, and be removed from it after this call
       * (otherwise isShared for its children could be incorrect).
       */
      mergeSibling(rhs, maxNodeSize) {
        const oldLength = this.keys.length;
        this.keys.push(...rhs.keys);
        const rhsChildren = rhs.children;
        this.children.push(...rhsChildren);
        if (rhs.isShared && !this.isShared) {
          for (let i = 0; i < rhsChildren.length; i++) {
            rhsChildren[i].isShared = true;
          }
        }
        this.tryMerge(oldLength - 1, maxNodeSize);
      }
    };
    __name(indexOf, "indexOf");
    emptyLeaf = new BNode([]);
    emptyLeaf.isShared = true;
    __name(comparator, "comparator");
    MemoryStorage = class {
      static {
        __name(this, "MemoryStorage");
      }
      #data = new BTreeSet(comparator);
      set(key2, value) {
        this.#data.add([key2, value]);
      }
      get(key2, def) {
        const r3 = this.#data.get([key2, null]);
        if (r3 !== void 0) {
          return r3[1];
        }
        return def;
      }
      del(key2) {
        this.#data.delete([key2, null]);
      }
      *scan(options2) {
        for (const entry of this.#data.valuesFrom(
          options2 && [options2.prefix, null]
        )) {
          if (options2 && !entry[0].startsWith(options2.prefix)) {
            return;
          }
          yield entry;
        }
      }
      cloneData() {
        return structuredClone(Object.fromEntries(this.#data.values()));
      }
    };
    __name(constraintMatchesRow, "constraintMatchesRow");
    __name(constraintMatchesPrimaryKey, "constraintMatchesPrimaryKey");
    MemorySource = class _MemorySource {
      static {
        __name(this, "_MemorySource");
      }
      #tableName;
      #columns;
      #primaryKey;
      #primaryIndexSort;
      #indexes = /* @__PURE__ */ new Map();
      #connections = [];
      #overlay;
      #splitEditOverlay;
      constructor(tableName, columns, primaryKey, primaryIndexData) {
        this.#tableName = tableName;
        this.#columns = columns;
        this.#primaryKey = primaryKey;
        this.#primaryIndexSort = primaryKey.map((k) => [k, "asc"]);
        const comparator2 = makeBoundComparator(this.#primaryIndexSort);
        this.#indexes.set(JSON.stringify(this.#primaryIndexSort), {
          comparator: comparator2,
          data: primaryIndexData ?? new BTreeSet(comparator2),
          usedBy: /* @__PURE__ */ new Set()
        });
        assertOrderingIncludesPK(this.#primaryIndexSort, this.#primaryKey);
      }
      // Mainly for tests.
      getSchemaInfo() {
        return {
          tableName: this.#tableName,
          columns: this.#columns,
          primaryKey: this.#primaryKey
        };
      }
      fork() {
        const primaryIndex = this.#getPrimaryIndex();
        return new _MemorySource(
          this.#tableName,
          this.#columns,
          this.#primaryKey,
          primaryIndex.data.clone()
        );
      }
      #getSchema(connection2) {
        return {
          tableName: this.#tableName,
          columns: this.#columns,
          primaryKey: this.#primaryKey,
          sort: connection2.sort,
          system: "client",
          relationships: {},
          isHidden: false,
          compareRows: connection2.compareRows
        };
      }
      connect(sort, filters, splitEditKeys) {
        const transformedFilters = transformFilters(filters);
        const input = {
          getSchema: /* @__PURE__ */ __name(() => schema2, "getSchema"),
          fetch: /* @__PURE__ */ __name((req) => this.#fetch(req, connection2), "fetch"),
          cleanup: /* @__PURE__ */ __name((req) => this.#cleanup(req, connection2), "cleanup"),
          setOutput: /* @__PURE__ */ __name((output) => {
            connection2.output = output;
          }, "setOutput"),
          destroy: /* @__PURE__ */ __name(() => {
            this.#disconnect(input);
          }, "destroy"),
          fullyAppliedFilters: !transformedFilters.conditionsRemoved
        };
        const connection2 = {
          input,
          output: void 0,
          sort,
          splitEditKeys,
          compareRows: makeComparator(sort),
          filters: transformedFilters.filters ? {
            condition: transformedFilters.filters,
            predicate: createPredicate(transformedFilters.filters)
          } : void 0
        };
        const schema2 = this.#getSchema(connection2);
        assertOrderingIncludesPK(sort, this.#primaryKey);
        this.#connections.push(connection2);
        return input;
      }
      #disconnect(input) {
        const idx = this.#connections.findIndex((c2) => c2.input === input);
        assert3(idx !== -1, "Connection not found");
        const connection2 = this.#connections[idx];
        this.#connections.splice(idx, 1);
        const primaryIndexKey = JSON.stringify(this.#primaryIndexSort);
        for (const [key2, index10] of this.#indexes) {
          if (key2 === primaryIndexKey) {
            continue;
          }
          index10.usedBy.delete(connection2);
          if (index10.usedBy.size === 0) {
            this.#indexes.delete(key2);
          }
        }
      }
      #getPrimaryIndex() {
        const index10 = this.#indexes.get(JSON.stringify(this.#primaryIndexSort));
        assert3(index10, "Primary index not found");
        return index10;
      }
      #getOrCreateIndex(sort, usedBy) {
        const key2 = JSON.stringify(sort);
        const index10 = this.#indexes.get(key2);
        if (index10) {
          index10.usedBy.add(usedBy);
          return index10;
        }
        const comparator2 = makeBoundComparator(sort);
        const data = new BTreeSet(comparator2);
        for (const row of this.#getPrimaryIndex().data) {
          data.add(row);
        }
        const newIndex = { comparator: comparator2, data, usedBy: /* @__PURE__ */ new Set([usedBy]) };
        this.#indexes.set(key2, newIndex);
        return newIndex;
      }
      // For unit testing that we correctly clean up indexes.
      getIndexKeys() {
        return [...this.#indexes.keys()];
      }
      *#fetch(req, from) {
        const callingConnectionIndex = this.#connections.indexOf(from);
        assert3(callingConnectionIndex !== -1, "Output not found");
        const conn = this.#connections[callingConnectionIndex];
        const { sort: requestedSort } = conn;
        const indexSort = [];
        if (req.constraint) {
          for (const key2 of Object.keys(req.constraint)) {
            indexSort.push([key2, "asc"]);
          }
        }
        if (this.#primaryKey.length > 1 || !req.constraint || !constraintMatchesPrimaryKey(req.constraint, this.#primaryKey)) {
          indexSort.push(...requestedSort);
        }
        const index10 = this.#getOrCreateIndex(indexSort, from);
        const { data, comparator: compare } = index10;
        const comparator2 = /* @__PURE__ */ __name((r1, r22) => compare(r1, r22) * (req.reverse ? -1 : 1), "comparator2");
        const startAt = req.start?.row;
        let scanStart;
        if (req.constraint) {
          scanStart = {};
          for (const [key2, dir3] of indexSort) {
            if (hasOwn(req.constraint, key2)) {
              scanStart[key2] = req.constraint[key2];
            } else {
              if (req.reverse) {
                scanStart[key2] = dir3 === "asc" ? maxValue : minValue;
              } else {
                scanStart[key2] = dir3 === "asc" ? minValue : maxValue;
              }
            }
          }
        } else {
          scanStart = startAt;
        }
        const withOverlay = generateWithOverlay(
          startAt,
          generateRows(data, scanStart, req.reverse),
          req.constraint,
          this.#overlay,
          this.#splitEditOverlay,
          callingConnectionIndex,
          comparator2,
          conn.filters?.predicate
        );
        const withConstraint = generateWithConstraint(
          generateWithStart(withOverlay, req.start, comparator2),
          req.constraint
        );
        yield* conn.filters ? generateWithFilter(withConstraint, conn.filters.predicate) : withConstraint;
      }
      #cleanup(req, connection2) {
        return this.#fetch(req, connection2);
      }
      push(change) {
        for (const _ of this.genPush(change)) {
        }
      }
      *genPush(change) {
        const primaryIndex = this.#getPrimaryIndex();
        const { data } = primaryIndex;
        const exists2 = /* @__PURE__ */ __name((row) => data.has(row), "exists");
        const setOverlay = /* @__PURE__ */ __name((o2) => this.#overlay = o2, "setOverlay");
        const setSplitEditOverlay = /* @__PURE__ */ __name((o2) => this.#splitEditOverlay = o2, "setSplitEditOverlay");
        if (change.type === "set") {
          const existing = data.get(change.row);
          if (existing !== void 0) {
            change = {
              type: "edit",
              row: change.row,
              oldRow: existing
            };
          } else {
            change = {
              type: "add",
              row: change.row
            };
          }
        }
        for (const x of genPush(
          change,
          exists2,
          this.#connections.entries(),
          setOverlay,
          setSplitEditOverlay
        )) {
          yield x;
        }
        for (const { data: data2 } of this.#indexes.values()) {
          switch (change.type) {
            case "add": {
              const added = data2.add(change.row);
              assert3(added);
              break;
            }
            case "remove": {
              const removed = data2.delete(change.row);
              assert3(removed);
              break;
            }
            case "edit": {
              const removed = data2.delete(change.oldRow);
              assert3(removed);
              data2.add(change.row);
              break;
            }
            default:
              unreachable(change);
          }
        }
      }
    };
    __name(generateWithConstraint, "generateWithConstraint");
    __name(generateWithFilter, "generateWithFilter");
    __name(genPush, "genPush");
    __name(generateWithStart, "generateWithStart");
    __name(generateWithOverlay, "generateWithOverlay");
    __name(computeOverlays, "computeOverlays");
    __name(overlaysForStartAt, "overlaysForStartAt");
    __name(overlaysForConstraint, "overlaysForConstraint");
    __name(overlaysForFilterPredicate, "overlaysForFilterPredicate");
    __name(generateWithOverlayInner, "generateWithOverlayInner");
    minValue = Symbol("min-value");
    maxValue = Symbol("max-value");
    __name(makeBoundComparator, "makeBoundComparator");
    __name(compareBounds, "compareBounds");
    __name(generateRows, "generateRows");
    __name(stringify3, "stringify");
    DESIRED_QUERIES_KEY_PREFIX = "d/";
    GOT_QUERIES_KEY_PREFIX = "g/";
    ENTITIES_KEY_PREFIX = "e/";
    __name(toDesiredQueriesKey, "toDesiredQueriesKey");
    __name(desiredQueriesPrefixForClient, "desiredQueriesPrefixForClient");
    __name(toGotQueriesKey, "toGotQueriesKey");
    __name(toPrimaryKeyString, "toPrimaryKeyString");
    __name(sourceNameFromKey, "sourceNameFromKey");
    IVMSourceBranch = class _IVMSourceBranch {
      static {
        __name(this, "_IVMSourceBranch");
      }
      #sources;
      #tables;
      hash;
      constructor(tables, hash22, sources = /* @__PURE__ */ new Map()) {
        this.#tables = tables;
        this.#sources = sources;
        this.hash = hash22;
      }
      getSource(name) {
        if (this.#sources.has(name)) {
          return this.#sources.get(name);
        }
        const schema2 = this.#tables[name];
        const source2 = schema2 ? new MemorySource(name, schema2.columns, schema2.primaryKey) : void 0;
        this.#sources.set(name, source2);
        return source2;
      }
      clear() {
        this.#sources.clear();
      }
      /**
       * Mutates the current branch, advancing it to the new head
       * by applying the given diffs.
       */
      advance(expectedHead, newHead, diffs) {
        assert3(
          this.hash === expectedHead,
          () => `Expected head must match the main head. Got: ${this.hash}, expected: ${expectedHead}`
        );
        applyDiffs(diffs, this);
        this.hash = newHead;
      }
      /**
       * Fork the branch and patch it up to match the desired head.
       */
      async forkToHead(reason, store, desiredHead, readOptions) {
        if (reason === "initial") {
          assert3(
            this.hash === desiredHead,
            "main branch must be at desired head for `initial`"
          );
          return this;
        }
        const fork = this.fork();
        if (fork.hash === desiredHead) {
          return fork;
        }
        await patchBranch(desiredHead, store, fork, readOptions);
        fork.hash = desiredHead;
        return fork;
      }
      /**
       * Creates a new IVMSourceBranch that is a copy of the current one.
       * This is a cheap operation since the b-trees are shared until a write is performed
       * and then only the modified nodes are copied.
       *
       * IVM branches are forked when we need to rebase mutations.
       * The mutations modify the fork rather than original branch.
       */
      fork() {
        return new _IVMSourceBranch(
          this.#tables,
          this.hash,
          new Map(
            wrapIterable(this.#sources.entries()).map(([name, source2]) => [
              name,
              source2?.fork()
            ])
          )
        );
      }
    };
    __name(patchBranch, "patchBranch");
    __name(computeDiffs, "computeDiffs");
    __name(applyDiffs, "applyDiffs");
    ZeroContext = class {
      static {
        __name(this, "ZeroContext");
      }
      // It is a bummer to have to maintain separate MemorySources here and copy the
      // data in from the Replicache db. But we want the data to be accessible via
      // pipelines *synchronously* and the core Replicache infra is all async. So
      // that needs to be fixed.
      #mainSources;
      #addQuery;
      #updateQuery;
      #batchViewUpdates;
      #commitListeners = /* @__PURE__ */ new Set();
      slowMaterializeThreshold;
      lc;
      staticQueryParameters = void 0;
      constructor(lc, mainSources, addQuery, updateQuery, batchViewUpdates, slowMaterializeThreshold) {
        this.#mainSources = mainSources;
        this.#addQuery = addQuery;
        this.#updateQuery = updateQuery;
        this.#batchViewUpdates = batchViewUpdates;
        this.lc = lc;
        this.slowMaterializeThreshold = slowMaterializeThreshold;
      }
      getSource(name) {
        return this.#mainSources.getSource(name);
      }
      addServerQuery(ast, ttl, gotCallback) {
        return this.#addQuery(ast, ttl, gotCallback);
      }
      updateServerQuery(ast, ttl) {
        this.#updateQuery(ast, ttl);
      }
      onQueryMaterialized(hash22, ast, duration) {
        if (this.slowMaterializeThreshold !== void 0 && duration > this.slowMaterializeThreshold) {
          this.lc.warn?.(
            "Slow query materialization (including server/network)",
            hash22,
            ast,
            duration
          );
        } else {
          this.lc.debug?.(
            "Materialized query (including server/network)",
            hash22,
            ast,
            duration
          );
        }
      }
      createStorage() {
        return new MemoryStorage();
      }
      decorateInput(input) {
        return input;
      }
      onTransactionCommit(cb) {
        this.#commitListeners.add(cb);
        return () => {
          this.#commitListeners.delete(cb);
        };
      }
      batchViewUpdates(applyViewUpdates) {
        let result;
        let viewChangesPerformed = false;
        this.#batchViewUpdates(() => {
          result = applyViewUpdates();
          viewChangesPerformed = true;
        });
        assert3(
          viewChangesPerformed,
          "batchViewUpdates must call applyViewUpdates synchronously."
        );
        return result;
      }
      processChanges(expectedHead, newHead, changes) {
        this.batchViewUpdates(() => {
          try {
            this.#mainSources.advance(expectedHead, newHead, changes);
          } finally {
            this.#endTransaction();
          }
        });
      }
      #endTransaction() {
        for (const listener of this.#commitListeners) {
          try {
            listener();
          } catch (e3) {
            this.lc.error?.("Failed notifying a commit listener of IVM updates", e3);
          }
        }
      }
    };
    __name(makeCRUDMutate, "makeCRUDMutate");
    __name(makeEntityCRUDMutate, "makeEntityCRUDMutate");
    __name(makeBatchCRUDMutate, "makeBatchCRUDMutate");
    __name(makeCRUDMutator, "makeCRUDMutator");
    __name(defaultOptionalFieldsToNull, "defaultOptionalFieldsToNull");
    __name(insertImpl, "insertImpl");
    __name(upsertImpl, "upsertImpl");
    __name(updateImpl, "updateImpl");
    __name(deleteImpl, "deleteImpl");
    TransactionImpl = class {
      static {
        __name(this, "TransactionImpl");
      }
      constructor(lc, repTx, schema2, slowMaterializeThreshold) {
        const castedRepTx = repTx;
        must(repTx.reason === "initial" || repTx.reason === "rebase");
        this.clientID = repTx.clientID;
        this.mutationID = repTx.mutationID;
        this.reason = repTx.reason === "initial" ? "optimistic" : "rebase";
        this.mutate = makeSchemaCRUD(
          schema2,
          repTx,
          // CRUD operators should not mutate the IVM store directly
          // for `initial`. The IVM store will be updated via calls to `advance`
          // after the transaction has been committed to the Replicache b-tree.
          // Mutating the IVM store in the mutator would cause us to synchronously
          // notify listeners of IVM while we're inside of the Replicache DB transaction.
          repTx.reason === "initial" ? void 0 : must(
            castedRepTx[zeroData],
            "zero was not set on replicache internal options!"
          )
        );
        this.query = makeSchemaQuery(
          lc,
          schema2,
          must(
            castedRepTx[zeroData],
            "zero was not set on replicache internal options!"
          ),
          slowMaterializeThreshold
        );
      }
      clientID;
      mutationID;
      reason;
      location = "client";
      mutate;
      query;
    };
    __name(makeReplicacheMutator, "makeReplicacheMutator");
    __name(makeSchemaCRUD, "makeSchemaCRUD");
    __name(makeSchemaQuery, "makeSchemaQuery");
    __name(makeTableCRUD, "makeTableCRUD");
    DeleteClientsManager = class {
      static {
        __name(this, "DeleteClientsManager");
      }
      #send;
      #lc;
      #dagStore;
      constructor(send22, dagStore, lc) {
        this.#send = send22;
        this.#dagStore = dagStore;
        this.#lc = lc;
      }
      /**
       * This gets called by Replicache when it deletes clients from the persistent
       * storage.
       */
      onClientsDeleted(clientIDs, clientGroupIDs) {
        this.#lc.debug?.("DeletedClientsManager, send:", clientIDs);
        this.#send(["deleteClients", { clientIDs, clientGroupIDs }]);
      }
      /**
       * Zero calls this after it connects to ensure that the server knows about all
       * the clients that might have been deleted locally since the last connection.
       */
      async sendDeletedClientsToServer() {
        const deleted = await withRead(
          this.#dagStore,
          (dagRead) => getDeletedClients(dagRead)
        );
        if (deleted.clientIDs.length > 0 || deleted.clientGroupIDs.length > 0) {
          this.#send(["deleteClients", deleted]);
          this.#lc.debug?.("DeletedClientsManager, send:", deleted);
        }
      }
      /**
       * This is called as a response to the server telling us which clients it
       * actually deleted.
       */
      clientsDeletedOnServer(deletedClients) {
        const { clientIDs = [], clientGroupIDs = [] } = deletedClients;
        if (clientIDs.length > 0 || clientGroupIDs.length > 0) {
          return withWrite(this.#dagStore, async (dagWrite) => {
            this.#lc.debug?.("clientsDeletedOnServer:", clientIDs, clientGroupIDs);
            await removeDeletedClients(dagWrite, clientIDs, clientGroupIDs);
          });
        }
        return promiseVoid;
      }
      getDeletedClients() {
        return withRead(this.#dagStore, getDeletedClients);
      }
    };
    IPV4_ADDRESS_REGEX = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    IPV6_ADDRESS_HOSTNAME_REGEX = /^\[[a-fA-F0-9:]*:[a-fA-F0-9:]*\]$/;
    IP_ADDRESS_HOSTNAME_REGEX = new RegExp(
      `(${IPV4_ADDRESS_REGEX.source}|${IPV6_ADDRESS_HOSTNAME_REGEX.source})`
    );
    __name(shouldEnableAnalytics, "shouldEnableAnalytics");
    __name(toWSString, "toWSString");
    __name(appendPath, "appendPath");
    DD_BASE_URL = new URL(
      "https://http-intake.logs.datadoghq.com/api/v2/logs"
    );
    MAX_LOG_ENTRIES_PER_FLUSH = 1e3;
    FORCE_FLUSH_THRESHOLD = 250;
    MAX_ENTRY_BYTES = 5 * 1024 * 1024;
    MAX_MESSAGE_RETRIES = 2;
    MAX_ENTRY_CHARS = MAX_ENTRY_BYTES / 4;
    DatadogLogSink = class {
      static {
        __name(this, "DatadogLogSink");
      }
      #messages = [];
      #apiKey;
      #source;
      #service;
      #host;
      #version;
      #interval;
      #baseURL;
      #timerID = 0;
      #flushLock = new Lock();
      constructor(options2) {
        const {
          apiKey,
          source: source2,
          service,
          host,
          version: version32,
          interval: interval2 = 5e3,
          baseURL: baseUrl = DD_BASE_URL
        } = options2;
        this.#apiKey = apiKey;
        this.#source = source2;
        this.#service = service;
        this.#host = host;
        this.#version = version32;
        this.#interval = interval2;
        this.#baseURL = baseUrl.toString();
      }
      log(level, context3, ...args) {
        this.#messages.push(makeMessage(args, context3, level));
        if (level === "error" || this.#messages.length === FORCE_FLUSH_THRESHOLD) {
          void this.flush();
        } else {
          this.#startTimer();
        }
      }
      #startTimer() {
        if (this.#timerID) {
          return;
        }
        this.#timerID = setTimeout(() => {
          this.#timerID = 0;
          void this.flush();
        }, this.#interval);
      }
      flush() {
        return this.#flushLock.withLock(async () => {
          const { length } = this.#messages;
          if (length === 0) {
            return;
          }
          do {
            const flushTime = Date.now();
            const stringified2 = [];
            let totalBytes = 0;
            for (const m of this.#messages) {
              m.flushDelayMs = flushTime - m.date;
              let str = JSON.stringify(m);
              if (str.length > MAX_ENTRY_CHARS) {
                m.message = `[Dropped message of length ${str.length}]`;
                str = JSON.stringify(m);
              }
              if (str.length + totalBytes + stringified2.length > MAX_ENTRY_CHARS) {
                break;
              }
              totalBytes += str.length;
              stringified2.push(str);
              if (stringified2.length === MAX_LOG_ENTRIES_PER_FLUSH) {
                break;
              }
            }
            const body2 = stringified2.join("\n");
            const url = new URL(this.#baseURL);
            if (this.#apiKey !== void 0) {
              url.searchParams.set("dd-api-key", this.#apiKey);
            }
            if (this.#source) {
              url.searchParams.set("ddsource", this.#source);
              url.searchParams.set("dd-evp-origin", this.#source);
            }
            if (this.#service) {
              url.searchParams.set("service", this.#service);
            }
            if (this.#host) {
              url.searchParams.set("host", this.#host);
            }
            if (this.#version) {
              url.searchParams.set("ddtags", `version:${this.#version}`);
            }
            let ok2 = false;
            try {
              const response = await fetch(url.toString(), {
                method: "POST",
                body: body2,
                keepalive: true
              });
              ok2 = response.ok;
              if (!ok2) {
                console.error(
                  "response",
                  response.status,
                  response.statusText,
                  await response.text
                );
              }
            } catch (e3) {
              console.error("Log flush to datadog failed", e3);
            }
            if (ok2) {
              this.#messages.splice(0, stringified2.length);
            } else {
              let numWithTooManyRetries = 0;
              for (let i = 0; i < stringified2.length; i++) {
                const m = this.#messages[i];
                m.flushRetryCount = (m.flushRetryCount ?? 0) + 1;
                if (m.flushRetryCount > MAX_MESSAGE_RETRIES) {
                  numWithTooManyRetries++;
                }
              }
              if (numWithTooManyRetries > 0) {
                console.error(
                  `Dropping ${numWithTooManyRetries} datadog log messages which failed to send ${MAX_MESSAGE_RETRIES + 1} times.`
                );
                this.#messages.splice(0, numWithTooManyRetries);
              }
            }
          } while (this.#messages.length >= FORCE_FLUSH_THRESHOLD);
          if (this.#messages.length) {
            this.#startTimer();
          }
        });
      }
    };
    __name(flattenMessage, "flattenMessage");
    __name(convertError, "convertError");
    __name(convertErrors, "convertErrors");
    LOG_SINK_FLUSH_RETRY_COUNT = "flushRetryCount";
    LOG_SINK_FLUSH_DELAY_ATTRIBUTE = "flushDelayMs";
    RESERVED_KEY_PREFIX = "@DATADOG_RESERVED_";
    RESERVED_KEYS = [
      "host",
      "source",
      "status",
      "service",
      "version",
      "trace_id",
      "message",
      "msg",
      // alias for message
      "date",
      // The following are attributes reserved by the DataDogLogSink
      // itself (as opposed to DataDog), to report on its own behavior.
      LOG_SINK_FLUSH_DELAY_ATTRIBUTE,
      LOG_SINK_FLUSH_RETRY_COUNT
    ];
    __name(makeMessage, "makeMessage");
    version22 = "0.17.2025032801";
    LevelFilterLogSink = class {
      static {
        __name(this, "LevelFilterLogSink");
      }
      #wrappedLogSink;
      #level;
      constructor(wrappedLogSink, level) {
        this.#wrappedLogSink = wrappedLogSink;
        this.#level = level;
      }
      log(level, context3, ...args) {
        if (this.#level === "error" && level !== "error") {
          return;
        }
        if (this.#level === "info" && level === "debug") {
          return;
        }
        this.#wrappedLogSink.log(level, context3, ...args);
      }
      async flush() {
        await consoleLogSink.flush?.();
      }
    };
    DATADOG_LOG_LEVEL = "info";
    ZERO_SASS_DOMAIN = ".reflect-server.net";
    __name(createLogOptions, "createLogOptions");
    TimeToConnectMs = "time_to_connect_ms";
    LastConnectError = "last_connect_error";
    TimeToConnectMsV2 = "time_to_connect_ms_v2";
    LastConnectErrorV2 = "last_connect_error_v2";
    TotalTimeToConnectMs = "total_time_to_connect_ms";
    NotConnected = "not_connected";
    DID_NOT_CONNECT_VALUE = 100 * 1e3;
    REPORT_INTERVAL_MS = 5e3;
    __name(getLastConnectErrorValue, "getLastConnectErrorValue");
    __name(camelToSnake, "camelToSnake");
    MetricManager = class {
      static {
        __name(this, "MetricManager");
      }
      #reportIntervalMs;
      #host;
      #reporter;
      #lc;
      #timerID;
      constructor(opts) {
        this.#reportIntervalMs = opts.reportIntervalMs;
        this.#host = opts.host;
        this.#reporter = opts.reporter;
        this.#lc = opts.lc;
        this.tags.push(`source:${opts.source}`);
        this.timeToConnectMs.set(DID_NOT_CONNECT_VALUE);
        this.#setNotConnectedReason("init");
        this.#timerID = setInterval(() => {
          void this.flush();
        }, this.#reportIntervalMs);
      }
      #metrics = [];
      // timeToConnectMs measures the time from the call to connect() to receiving
      // the 'connected' ws message. We record the DID_NOT_CONNECT_VALUE if the previous
      // connection attempt failed for any reason.
      //
      // We set the gauge using #connectStart as follows:
      // - #connectStart is undefined if we are disconnected or connected; it is
      //   defined only in the Connecting state, as a number representing the timestamp
      //   at which we started connecting.
      // - #connectStart is set to the current time when connect() is called.
      // - When we receive the 'connected' message we record the time to connect and
      //   set #connectStart to undefined.
      // - If disconnect() is called with a defined #connectStart then we record
      //   DID_NOT_CONNECT_VALUE and set #connectStart to undefined.
      //
      // TODO It's clear after playing with the connection code we should encapsulate
      // the ConnectionState along with its state transitions and possibly behavior.
      // In that world the metric gauge(s) and bookkeeping like #connectStart would
      // be encapsulated with the ConnectionState. This will probably happen as part
      // of https://github.com/rocicorp/reflect-server/issues/255.
      timeToConnectMs = this.#register(
        new Gauge(TimeToConnectMs)
      );
      // lastConnectError records the last error that occurred when connecting,
      // if any. It is cleared when connecting successfully or when reported, so this
      // state only gets reported if there was a failure during the reporting period and
      // we are still not connected.
      lastConnectError = this.#register(
        new State(
          LastConnectError,
          true
          // clearOnFlush
        )
      );
      // notConnected records the reason why the client is not currently connected.
      // It is cleared when the client successfully connects.
      #notConnected = this.#register(new State(NotConnected));
      // The time from the call to connect() to receiving the 'connected' ws message
      // for the current connection.  Cleared when the client is not connected.
      // TODO: Not actually currently cleared on disconnect untill there is a
      // connect error, or client reports disconnected and waiting for visible.
      // Should have a value iff _notConnected has no value.
      #timeToConnectMsV2 = this.#register(
        new Gauge(TimeToConnectMsV2)
      );
      // lastConnectErrorV2 records the last error that occurred when connecting,
      // if any. It is cleared when the client successfully connects or
      // stops trying to connect due to being hidden.
      // Should have a value iff notConnected state is NotConnectedReason.Error.
      #lastConnectErrorV2 = this.#register(
        new State(LastConnectErrorV2)
      );
      // The total time it took to connect across retries for the current
      // connection.  Cleared when the client is not connected.
      // TODO: Not actually currently cleared on disconnect until there is a
      // connect error, or client reports disconnected and waiting for visible.
      // See Zero.#totalToConnectStart for details of how this total is computed.
      // Should have a value iff _notConnected has no value.
      #totalTimeToConnectMs = this.#register(
        new Gauge(TotalTimeToConnectMs)
      );
      #setNotConnectedReason(reason) {
        this.#notConnected.set(reason);
      }
      setConnected(timeToConnectMs, totalTimeToConnectMs) {
        this.#notConnected.clear();
        this.#lastConnectErrorV2.clear();
        this.#timeToConnectMsV2.set(timeToConnectMs);
        this.#totalTimeToConnectMs.set(totalTimeToConnectMs);
      }
      setDisconnectedWaitingForVisible() {
        this.#timeToConnectMsV2.clear();
        this.#totalTimeToConnectMs.clear();
        this.#lastConnectErrorV2.clear();
        let notConnectedReason;
        switch (this.#notConnected.get()) {
          case "init":
            notConnectedReason = "hidden_was_init";
            break;
          case "error":
            notConnectedReason = "hidden_was_error";
            break;
          default:
            notConnectedReason = "hidden";
            break;
        }
        this.#setNotConnectedReason(notConnectedReason);
      }
      setConnectError(reason) {
        this.#timeToConnectMsV2.clear();
        this.#totalTimeToConnectMs.clear();
        this.#setNotConnectedReason("error");
        this.#lastConnectErrorV2.set(getLastConnectErrorValue(reason));
      }
      /**
       * Tags to include in all metrics.
       */
      tags = [];
      // Flushes all metrics to an array of time series (plural), one Series
      // per metric.
      async flush() {
        const lc = this.#lc;
        if (this.#timerID === null) {
          lc.error?.("MetricManager.flush() called but already stopped");
          return;
        }
        const allSeries = [];
        for (const metric of this.#metrics) {
          const series = metric.flush();
          if (series !== void 0) {
            allSeries.push({
              ...series,
              host: this.#host,
              tags: this.tags
            });
          }
        }
        if (allSeries.length === 0) {
          lc?.debug?.("No metrics to report");
          return;
        }
        try {
          await this.#reporter(allSeries);
        } catch (e3) {
          lc?.error?.(`Error reporting metrics: ${e3}`);
        }
      }
      stop() {
        if (this.#timerID === null) {
          this.#lc.error?.("MetricManager.stop() called but already stopped");
          return;
        }
        clearInterval(this.#timerID);
        this.#timerID = null;
      }
      #register(metric) {
        this.#metrics.push(metric);
        return metric;
      }
    };
    __name(makePoint, "makePoint");
    Gauge = class {
      static {
        __name(this, "Gauge");
      }
      #name;
      #value = void 0;
      constructor(name) {
        this.#name = name;
      }
      set(value) {
        this.#value = value;
      }
      get() {
        return this.#value;
      }
      clear() {
        this.#value = void 0;
      }
      flush() {
        if (this.#value === void 0) {
          return void 0;
        }
        const points = [makePoint(t(), this.#value)];
        return { metric: this.#name, points };
      }
    };
    __name(t, "t");
    State = class {
      static {
        __name(this, "State");
      }
      #prefix;
      #clearOnFlush;
      #current = void 0;
      constructor(prefix, clearOnFlush = false) {
        this.#prefix = prefix;
        this.#clearOnFlush = clearOnFlush;
      }
      set(state2) {
        this.#current = state2;
      }
      get() {
        return this.#current;
      }
      clear() {
        this.#current = void 0;
      }
      flush() {
        if (this.#current === void 0) {
          return void 0;
        }
        const gauge = new Gauge([this.#prefix, this.#current].join("_"));
        gauge.set(1);
        const series = gauge.flush();
        if (this.#clearOnFlush) {
          this.clear();
        }
        return series;
      }
    };
    TimedOut = 0;
    Success = 1;
    QueryManager = class {
      static {
        __name(this, "QueryManager");
      }
      #clientID;
      #clientToServer;
      #send;
      #queries = /* @__PURE__ */ new Map();
      #recentQueriesMaxSize;
      #recentQueries = /* @__PURE__ */ new Set();
      #gotQueries = /* @__PURE__ */ new Set();
      constructor(clientID, tables, send22, experimentalWatch, recentQueriesMaxSize) {
        this.#clientID = clientID;
        this.#clientToServer = clientToServer(tables);
        this.#recentQueriesMaxSize = recentQueriesMaxSize;
        this.#send = send22;
        experimentalWatch(
          (diff3) => {
            for (const diffOp of diff3) {
              const queryHash = diffOp.key.substring(GOT_QUERIES_KEY_PREFIX.length);
              switch (diffOp.op) {
                case "add":
                  this.#gotQueries.add(queryHash);
                  this.#fireGotCallbacks(queryHash, true);
                  break;
                case "del":
                  this.#gotQueries.delete(queryHash);
                  this.#fireGotCallbacks(queryHash, false);
                  break;
              }
            }
          },
          {
            prefix: GOT_QUERIES_KEY_PREFIX,
            initialValuesInFirstDiff: true
          }
        );
      }
      #fireGotCallbacks(queryHash, got) {
        const gotCallbacks = this.#queries.get(queryHash)?.gotCallbacks ?? [];
        for (const gotCallback of gotCallbacks) {
          gotCallback(got);
        }
      }
      /**
       * Get the queries that need to be registered with the server.
       *
       * An optional `lastPatch` can be provided. This is the last patch that was
       * sent to the server and may not yet have been acked. If `lastPatch` is provided,
       * this method will return a patch that does not include any events sent in `lastPatch`.
       *
       * This diffing of last patch and current patch is needed since we send
       * a set of queries to the server when we first connect inside of the `sec-protocol` as
       * the `initConnectionMessage`.
       *
       * While we're waiting for the `connected` response to come back from the server,
       * the client may have registered more queries. We need to diff the `initConnectionMessage`
       * queries with the current set of queries to understand what those were.
       */
      async getQueriesPatch(tx, lastPatch) {
        const existingQueryHashes = /* @__PURE__ */ new Set();
        const prefix = desiredQueriesPrefixForClient(this.#clientID);
        for await (const key2 of tx.scan({ prefix }).keys()) {
          existingQueryHashes.add(key2.substring(prefix.length, key2.length));
        }
        const patch = /* @__PURE__ */ new Map();
        for (const hash22 of existingQueryHashes) {
          if (!this.#queries.has(hash22)) {
            patch.set(hash22, { op: "del", hash: hash22 });
          }
        }
        for (const [hash22, { normalized, ttl }] of this.#queries) {
          if (!existingQueryHashes.has(hash22)) {
            patch.set(hash22, { op: "put", hash: hash22, ast: normalized, ttl: parseTTL(ttl) });
          }
        }
        if (lastPatch) {
          for (const [hash22, { op }] of lastPatch) {
            if (op === "put" && !patch.has(hash22)) {
              patch.set(hash22, { op: "del", hash: hash22 });
            }
          }
          for (const [hash22, { op }] of patch) {
            const lastPatchOp = lastPatch.get(hash22);
            if (lastPatchOp && lastPatchOp.op === op) {
              patch.delete(hash22);
            }
          }
        }
        return patch;
      }
      add(ast, ttl, gotCallback) {
        const normalized = normalizeAST(ast);
        const astHash = hashOfAST(normalized);
        let entry = this.#queries.get(astHash);
        this.#recentQueries.delete(astHash);
        if (!entry) {
          const serverAST = mapAST(normalized, this.#clientToServer);
          entry = {
            normalized: serverAST,
            count: 1,
            gotCallbacks: gotCallback ? [gotCallback] : [],
            ttl
          };
          this.#queries.set(astHash, entry);
          this.#send([
            "changeDesiredQueries",
            {
              desiredQueriesPatch: [
                { op: "put", hash: astHash, ast: serverAST, ttl: parseTTL(ttl) }
              ]
            }
          ]);
        } else {
          ++entry.count;
          this.#updateEntry(entry, astHash, ttl);
          if (gotCallback) {
            entry.gotCallbacks.push(gotCallback);
          }
        }
        if (gotCallback) {
          gotCallback(this.#gotQueries.has(astHash));
        }
        let removed = false;
        return () => {
          if (removed) {
            return;
          }
          removed = true;
          this.#remove(entry, astHash, gotCallback);
        };
      }
      update(ast, ttl) {
        const normalized = normalizeAST(ast);
        const astHash = hashOfAST(normalized);
        const entry = must(this.#queries.get(astHash));
        this.#updateEntry(entry, astHash, ttl);
      }
      #updateEntry(entry, hash22, ttl) {
        if (compareTTL(ttl, entry.ttl) > 0) {
          entry.ttl = ttl;
          this.#send([
            "changeDesiredQueries",
            {
              desiredQueriesPatch: [
                {
                  op: "put",
                  hash: hash22,
                  ast: entry.normalized,
                  ttl: parseTTL(ttl)
                }
              ]
            }
          ]);
        }
      }
      #remove(entry, astHash, gotCallback) {
        if (gotCallback) {
          const index10 = entry.gotCallbacks.indexOf(gotCallback);
          entry.gotCallbacks.splice(index10, 1);
        }
        --entry.count;
        if (entry.count === 0) {
          this.#recentQueries.add(astHash);
          if (this.#recentQueries.size > this.#recentQueriesMaxSize) {
            const lruAstHash = this.#recentQueries.values().next().value;
            assert3(lruAstHash);
            this.#queries.delete(lruAstHash);
            this.#recentQueries.delete(lruAstHash);
            this.#send([
              "changeDesiredQueries",
              {
                desiredQueriesPatch: [{ op: "del", hash: lruAstHash }]
              }
            ]);
          }
        }
      }
    };
    RELOAD_REASON_STORAGE_KEY = "_zeroReloadReason";
    RELOAD_BACKOFF_STATE_KEY = "_zeroReloadBackoffState";
    backoffStateSchema = valita_exports.object({
      lastReloadTime: valita_exports.number().default(0),
      nextIntervalMs: valita_exports.number().default(0)
    });
    MIN_RELOAD_INTERVAL_MS = 500;
    MAX_RELOAD_INTERVAL_MS = 6e4;
    FALLBACK_RELOAD_INTERVAL_MS = 1e4;
    reloadTimer = null;
    __name(reloadWithReason, "reloadWithReason");
    __name(reportReloadReason, "reportReloadReason");
    __name(reloadScheduled, "reloadScheduled");
    __name(resetBackoff, "resetBackoff");
    __name(nextBackoff, "nextBackoff");
    ServerError = class extends Error {
      static {
        __name(this, "ServerError");
      }
      name = "ServerError";
      errorBody;
      get kind() {
        return this.errorBody.kind;
      }
      constructor(errorBody) {
        super(errorBody.kind + ": " + errorBody.message);
        this.errorBody = errorBody;
      }
    };
    __name(isServerError, "isServerError");
    __name(isAuthError, "isAuthError");
    __name(isAuthErrorKind, "isAuthErrorKind");
    __name(isBackoffError, "isBackoffError");
    __name(validateServerParam, "validateServerParam");
    __name(getServer, "getServer");
    PokeHandler = class {
      static {
        __name(this, "PokeHandler");
      }
      #replicachePoke;
      #onPokeError;
      #clientID;
      #lc;
      #receivingPoke = void 0;
      #pokeBuffer = [];
      #pokePlaybackLoopRunning = false;
      #lastRafPerfTimestamp = 0;
      // Serializes calls to this.#replicachePoke otherwise we can cause out of
      // order poke errors.
      #pokeLock = new Lock();
      #schema;
      #serverToClient;
      #raf = getBrowserGlobalMethod("requestAnimationFrame") ?? rafFallback;
      constructor(replicachePoke, onPokeError, clientID, schema2, lc) {
        this.#replicachePoke = replicachePoke;
        this.#onPokeError = onPokeError;
        this.#clientID = clientID;
        this.#schema = schema2;
        this.#serverToClient = serverToClient(schema2.tables);
        this.#lc = lc.withContext("PokeHandler");
      }
      handlePokeStart(pokeStart) {
        if (this.#receivingPoke) {
          this.#handlePokeError(
            `pokeStart ${JSON.stringify(
              pokeStart
            )} while still receiving  ${JSON.stringify(
              this.#receivingPoke.pokeStart
            )} `
          );
          return;
        }
        this.#receivingPoke = {
          pokeStart,
          parts: []
        };
      }
      handlePokePart(pokePart) {
        if (pokePart.pokeID !== this.#receivingPoke?.pokeStart.pokeID) {
          this.#handlePokeError(
            `pokePart for ${pokePart.pokeID}, when receiving ${this.#receivingPoke?.pokeStart.pokeID}`
          );
          return;
        }
        this.#receivingPoke.parts.push(pokePart);
        return pokePart.lastMutationIDChanges?.[this.#clientID];
      }
      handlePokeEnd(pokeEnd) {
        if (pokeEnd.pokeID !== this.#receivingPoke?.pokeStart.pokeID) {
          this.#handlePokeError(
            `pokeEnd for ${pokeEnd.pokeID}, when receiving ${this.#receivingPoke?.pokeStart.pokeID}`
          );
          return;
        }
        if (pokeEnd.cancel) {
          this.#receivingPoke = void 0;
          return;
        }
        this.#pokeBuffer.push({ ...this.#receivingPoke, pokeEnd });
        this.#receivingPoke = void 0;
        if (!this.#pokePlaybackLoopRunning) {
          this.#startPlaybackLoop();
        }
      }
      handleDisconnect() {
        this.#lc.debug?.("clearing due to disconnect");
        this.#clear();
      }
      #startPlaybackLoop() {
        this.#lc.debug?.("starting playback loop");
        this.#pokePlaybackLoopRunning = true;
        this.#raf(this.#rafCallback);
      }
      #rafCallback = /* @__PURE__ */ __name(async () => {
        const rafLC = this.#lc.withContext("rafAt", Math.floor(performance.now()));
        if (this.#pokeBuffer.length === 0) {
          rafLC.debug?.("stopping playback loop");
          this.#pokePlaybackLoopRunning = false;
          return;
        }
        this.#raf(this.#rafCallback);
        const start = performance.now();
        rafLC.debug?.(
          "raf fired, processing pokes.  Since last raf",
          start - this.#lastRafPerfTimestamp
        );
        this.#lastRafPerfTimestamp = start;
        await this.#processPokesForFrame(rafLC);
        rafLC.debug?.("processing pokes took", performance.now() - start);
      }, "#rafCallback");
      #processPokesForFrame(lc) {
        return this.#pokeLock.withLock(async () => {
          const now = Date.now();
          lc.debug?.("got poke lock at", now);
          lc.debug?.("merging", this.#pokeBuffer.length);
          try {
            const merged = mergePokes(
              this.#pokeBuffer,
              this.#schema,
              this.#serverToClient
            );
            this.#pokeBuffer.length = 0;
            if (merged === void 0) {
              lc.debug?.("frame is empty");
              return;
            }
            const start = performance.now();
            lc.debug?.("poking replicache");
            await this.#replicachePoke(merged);
            lc.debug?.("poking replicache took", performance.now() - start);
          } catch (e3) {
            this.#handlePokeError(e3);
          }
        });
      }
      #handlePokeError(e3) {
        if (String(e3).includes("unexpected base cookie for poke")) {
          this.#lc.debug?.("clearing due to", e3);
        } else {
          this.#lc.error?.("clearing due to unexpected poke error", e3);
        }
        this.#clear();
        this.#onPokeError();
      }
      #clear() {
        this.#receivingPoke = void 0;
        this.#pokeBuffer.length = 0;
      }
    };
    __name(mergePokes, "mergePokes");
    __name(queryPatchOpToReplicachePatchOp, "queryPatchOpToReplicachePatchOp");
    __name(rowsPatchOpToReplicachePatchOp, "rowsPatchOpToReplicachePatchOp");
    __name(rafFallback, "rafFallback");
    ZeroRep = class {
      static {
        __name(this, "ZeroRep");
      }
      #context;
      #ivmMain;
      #customMutatorsEnabled;
      #store;
      constructor(context3, ivmMain, customMutatorsEnabled) {
        this.#context = context3;
        this.#ivmMain = ivmMain;
        this.#customMutatorsEnabled = customMutatorsEnabled;
      }
      async init(hash22, store) {
        const diffs = [];
        await withRead(store, async (dagRead) => {
          const read = await readFromHash(hash22, dagRead, Latest);
          for await (const entry of read.map.scan(ENTITIES_KEY_PREFIX)) {
            if (!entry[0].startsWith(ENTITIES_KEY_PREFIX)) {
              break;
            }
            diffs.push({
              op: "add",
              key: entry[0],
              newValue: entry[1]
            });
          }
        });
        this.#store = store;
        this.#context.processChanges(void 0, hash22, diffs);
      }
      getTxData = /* @__PURE__ */ __name((reason, desiredHead, readOptions) => {
        if (!this.#customMutatorsEnabled) {
          return;
        }
        return this.#ivmMain.forkToHead(
          reason,
          must(this.#store),
          desiredHead,
          readOptions
        );
      }, "getTxData");
      advance = /* @__PURE__ */ __name((expectedHash, newHash, diffs) => {
        this.#context.processChanges(expectedHash, newHash, diffs);
      }, "advance");
    };
    onSetConnectionStateSymbol = Symbol();
    exposedToTestingSymbol = Symbol();
    createLogOptionsSymbol = Symbol();
    RUN_LOOP_INTERVAL_MS = 5e3;
    PING_INTERVAL_MS = 5e3;
    PING_TIMEOUT_MS = 5e3;
    PULL_TIMEOUT_MS = 5e3;
    DEFAULT_DISCONNECT_HIDDEN_DELAY_MS = 5e3;
    CONNECT_TIMEOUT_MS = 1e4;
    CHECK_CONNECTIVITY_ON_ERROR_FREQUENCY = 6;
    NULL_LAST_MUTATION_ID_SENT = { clientID: "", id: -1 };
    __name(convertOnUpdateNeededReason, "convertOnUpdateNeededReason");
    __name(updateNeededReloadReason, "updateNeededReloadReason");
    __name(serverAheadReloadReason, "serverAheadReloadReason");
    __name(onClientStateNotFoundServerReason, "onClientStateNotFoundServerReason");
    ON_CLIENT_STATE_NOT_FOUND_REASON_CLIENT = "The local persistent state needed to synchronize this client has been garbage collected.";
    CLOSE_CODE_NORMAL = 1e3;
    Zero = class {
      static {
        __name(this, "Zero");
      }
      version = version22;
      #rep;
      #server;
      userID;
      storageKey;
      #lc;
      #logOptions;
      #enableAnalytics;
      #clientSchema;
      #pokeHandler;
      #queryManager;
      #ivmMain;
      #clientToServer;
      #deleteClientsManager;
      /**
       * The queries we sent when inside the sec-protocol header when establishing a connection.
       * More queries could be registered while we're waiting for the 'connected' message
       * to come back from the server. To understand what queries we need to send
       * to the server, we diff the `initConnectionQueries` with the current set of desired queries.
       *
       * If this is set to `undefined` that means no queries were sent inside the `sec-protocol` header
       * and an `initConnection` message must be sent to the server after receiving the `connected` message.
       */
      #initConnectionQueries;
      /**
       * We try to send the deleted clients and (client groups) as part of the
       * sec-protocol header. If we can't because the header would get too large we
       * keep track of the deleted clients and send them after the connection is
       * established.
       */
      #deletedClients;
      #lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;
      #onPong = /* @__PURE__ */ __name(() => void 0, "#onPong");
      #online = false;
      #onOnlineChange;
      #onUpdateNeeded;
      #onClientStateNotFound;
      // Last cookie used to initiate a connection
      #connectCookie = null;
      // Total number of sockets successfully connected by this client
      #connectedCount = 0;
      // Number of messages received over currently connected socket.  Reset
      // on disconnect.
      #messageCount = 0;
      #connectedAt = 0;
      // Reset on successful connection.
      #connectErrorCount = 0;
      #abortPingTimeout = /* @__PURE__ */ __name(() => {
      }, "#abortPingTimeout");
      #zeroContext;
      #connectResolver = resolver();
      #pendingPullsByRequestID = /* @__PURE__ */ new Map();
      #lastMutationIDReceived = 0;
      #socket = void 0;
      #socketResolver = resolver();
      #connectionStateChangeResolver = resolver();
      /**
       * This resolver is only used for rejections. It is awaited in the connected
       * state (including when waiting for a pong). It is rejected when we get an
       * invalid message or an 'error' message.
       */
      #rejectMessageError = void 0;
      #closeAbortController = new AbortController();
      #visibilityWatcher;
      // We use an accessor pair to allow the subclass to override the setter.
      #connectionState = Disconnected;
      #setConnectionState(state2) {
        if (state2 === this.#connectionState) {
          return;
        }
        this.#connectionState = state2;
        this.#connectionStateChangeResolver.resolve(state2);
        this.#connectionStateChangeResolver = resolver();
        if (false) {
          asTestZero(this)[onSetConnectionStateSymbol]?.(state2);
        }
      }
      #connectStart = void 0;
      // Set on connect attempt if currently undefined.
      // Reset to undefined when
      // 1. client stops trying to connect because it is hidden
      // 2. client encounters a connect error and canary request indicates
      //    the client is offline
      // 2. client successfully connects
      #totalToConnectStart = void 0;
      #options;
      query;
      // TODO: Metrics needs to be rethought entirely as we're not going to
      // send metrics to customer server.
      #metrics;
      // Store as field to allow test subclass to override. Web API doesn't allow
      // overwriting location fields for security reasons.
      #reload = /* @__PURE__ */ __name(() => getBrowserGlobal("location")?.reload(), "#reload");
      /**
       * Constructs a new Zero client.
       */
      constructor(options2) {
        const {
          userID,
          storageKey,
          onOnlineChange,
          onUpdateNeeded,
          onClientStateNotFound,
          hiddenTabDisconnectDelay = DEFAULT_DISCONNECT_HIDDEN_DELAY_MS,
          schema: schema2,
          batchViewUpdates = /* @__PURE__ */ __name((applyViewUpdates) => applyViewUpdates(), "batchViewUpdates"),
          maxRecentQueries = 0,
          slowMaterializeThreshold = 5e3
        } = options2;
        if (!userID) {
          throw new Error("ZeroOptions.userID must not be empty.");
        }
        const server2 = getServer(options2.server);
        this.#enableAnalytics = shouldEnableAnalytics(
          server2,
          false
          // Reenable analytics
        );
        let { kvStore = "idb" } = options2;
        if (kvStore === "idb") {
          if (!getBrowserGlobal("indexedDB")) {
            console.warn(
              "IndexedDB is not supported in this environment. Falling back to memory storage."
            );
            kvStore = "mem";
          }
        }
        if (hiddenTabDisconnectDelay < 0) {
          throw new Error(
            "ZeroOptions.hiddenTabDisconnectDelay must not be negative."
          );
        }
        this.#onOnlineChange = onOnlineChange;
        this.#options = options2;
        this.#logOptions = this.#createLogOptions({
          consoleLogLevel: options2.logLevel ?? "error",
          server: null,
          //server, // Reenable remote logging
          enableAnalytics: this.#enableAnalytics
        });
        const logOptions = this.#logOptions;
        const replicacheMutators = {
          [CRUD_MUTATION_NAME]: makeCRUDMutator(schema2)
        };
        this.#ivmMain = new IVMSourceBranch(schema2.tables);
        const lc = new LogContext(logOptions.logLevel, {}, logOptions.logSink);
        for (const [namespace, mutatorsForNamespace] of Object.entries(
          options2.mutators ?? {}
        )) {
          for (const [name, mutator] of Object.entries(
            mutatorsForNamespace
          )) {
            replicacheMutators[customMutatorKey(namespace, name)] = makeReplicacheMutator(
              lc,
              mutator,
              schema2,
              slowMaterializeThreshold
            );
          }
        }
        this.storageKey = storageKey ?? "";
        const { clientSchema: clientSchema2, hash: hash22 } = clientSchemaFrom(schema2);
        this.#clientSchema = clientSchema2;
        const replicacheOptions = {
          // The schema stored in IDB is dependent upon both the ClientSchema
          // and the AST schema (i.e. PROTOCOL_VERSION).
          schemaVersion: `${PROTOCOL_VERSION}.${hash22}`,
          logLevel: logOptions.logLevel,
          logSinks: [logOptions.logSink],
          mutators: replicacheMutators,
          name: `zero-${userID}-${this.storageKey}`,
          pusher: /* @__PURE__ */ __name((req, reqID) => this.#pusher(req, reqID), "pusher"),
          puller: /* @__PURE__ */ __name((req, reqID) => this.#puller(req, reqID), "puller"),
          pushDelay: 0,
          requestOptions: {
            maxDelayMs: 0,
            minDelayMs: 0
          },
          licenseKey: "zero-client-static-key",
          kvStore
        };
        this.#zeroContext = new ZeroContext(
          lc,
          this.#ivmMain,
          (ast, ttl, gotCallback) => this.#queryManager.add(ast, ttl, gotCallback),
          (ast, ttl) => this.#queryManager.update(ast, ttl),
          batchViewUpdates,
          slowMaterializeThreshold
        );
        const replicacheImplOptions = {
          enableClientGroupForking: false,
          enableMutationRecovery: false,
          onClientsDeleted: /* @__PURE__ */ __name((clientIDs, clientGroupIDs) => this.#deleteClientsManager.onClientsDeleted(clientIDs, clientGroupIDs), "onClientsDeleted"),
          zero: new ZeroRep(
            this.#zeroContext,
            this.#ivmMain,
            options2.mutators !== void 0
          )
        };
        const rep = new ReplicacheImpl(replicacheOptions, replicacheImplOptions);
        this.#rep = rep;
        if (false) {
          internalReplicacheImplMap.set(this, rep);
        }
        this.#server = server2;
        this.userID = userID;
        this.#lc = lc.withContext("clientID", rep.clientID);
        const onUpdateNeededCallback = onUpdateNeeded ?? ((reason, serverErrorMsg) => {
          reloadWithReason(
            this.#lc,
            this.#reload,
            updateNeededReloadReason(reason, serverErrorMsg)
          );
        });
        this.#onUpdateNeeded = onUpdateNeededCallback;
        this.#rep.onUpdateNeeded = (reason) => {
          onUpdateNeededCallback(convertOnUpdateNeededReason(reason));
        };
        const onClientStateNotFoundCallback = onClientStateNotFound ?? ((reason) => {
          reloadWithReason(
            this.#lc,
            this.#reload,
            reason ?? ON_CLIENT_STATE_NOT_FOUND_REASON_CLIENT
          );
        });
        this.#onClientStateNotFound = onClientStateNotFoundCallback;
        this.#rep.onClientStateNotFound = onClientStateNotFoundCallback;
        let { mutate, mutateBatch } = makeCRUDMutate(schema2, rep.mutate);
        if (options2.mutators) {
          mutate = {};
          mutateBatch = void 0;
        }
        for (const [namespace, mutatorsForNamespace] of Object.entries(
          options2.mutators ?? {}
        )) {
          let existing = mutate[namespace];
          if (existing === void 0) {
            existing = {};
            mutate[namespace] = existing;
          }
          for (const name of Object.keys(
            mutatorsForNamespace
          )) {
            existing[name] = must(rep.mutate[customMutatorKey(namespace, name)]);
          }
        }
        this.mutate = mutate;
        this.mutateBatch = mutateBatch;
        this.#queryManager = new QueryManager(
          rep.clientID,
          schema2.tables,
          (msg) => this.#sendChangeDesiredQueries(msg),
          rep.experimentalWatch.bind(rep),
          maxRecentQueries
        );
        this.#clientToServer = clientToServer(schema2.tables);
        this.#deleteClientsManager = new DeleteClientsManager(
          (msg) => this.#send(msg),
          rep.perdag,
          this.#lc
        );
        this.query = this.#registerQueries(schema2);
        reportReloadReason(this.#lc);
        this.#metrics = new MetricManager({
          reportIntervalMs: REPORT_INTERVAL_MS,
          host: getBrowserGlobal("location")?.host ?? "",
          source: "client",
          reporter: this.#enableAnalytics ? (allSeries) => this.#reportMetrics(allSeries) : () => Promise.resolve(),
          lc: this.#lc
        });
        this.#metrics.tags.push(`version:${this.version}`);
        this.#pokeHandler = new PokeHandler(
          (poke) => this.#rep.poke(poke),
          () => this.#onPokeError(),
          rep.clientID,
          schema2,
          this.#lc
        );
        this.#visibilityWatcher = getDocumentVisibilityWatcher(
          getBrowserGlobal("document"),
          hiddenTabDisconnectDelay,
          this.#closeAbortController.signal
        );
        void this.#runLoop();
        if (false) {
          asTestZero(this)[exposedToTestingSymbol] = {
            puller: this.#puller,
            pusher: this.#pusher,
            setReload: /* @__PURE__ */ __name((r3) => {
              this.#reload = r3;
            }, "setReload"),
            logOptions: this.#logOptions,
            connectStart: /* @__PURE__ */ __name(() => this.#connectStart, "connectStart"),
            socketResolver: /* @__PURE__ */ __name(() => this.#socketResolver, "socketResolver"),
            connectionState: /* @__PURE__ */ __name(() => this.#connectionState, "connectionState")
          };
        }
      }
      #sendChangeDesiredQueries(msg) {
        this.#send(msg);
      }
      #send(msg) {
        if (this.#socket && this.#connectionState === Connected) {
          send2(this.#socket, msg);
        }
      }
      #createLogOptions(options2) {
        if (false) {
          const testZero = asTestZero(this);
          if (testZero[createLogOptionsSymbol]) {
            return testZero[createLogOptionsSymbol](options2);
          }
        }
        return createLogOptions(options2);
      }
      /**
       * The server URL that this Zero instance is configured with.
       */
      get server() {
        return this.#server;
      }
      /**
       * The name of the IndexedDB database in which the data of this
       * instance of Zero is stored.
       */
      get idbName() {
        return this.#rep.idbName;
      }
      /**
       * The schema version of the data understood by this application.
       * See [[ZeroOptions.schemaVersion]].
       */
      get schemaVersion() {
        return this.#rep.schemaVersion;
      }
      /**
       * The client ID for this instance of Zero. Each instance
       * gets a unique client ID.
       */
      get clientID() {
        return this.#rep.clientID;
      }
      get clientGroupID() {
        return this.#rep.clientGroupID;
      }
      /**
       * Provides simple "CRUD" mutations for the tables in the schema.
       *
       * Each table has `create`, `set`, `update`, and `delete` methods.
       *
       * ```ts
       * await zero.mutate.issue.create({id: '1', title: 'First issue', priority: 'high'});
       * await zero.mutate.comment.create({id: '1', text: 'First comment', issueID: '1'});
       * ```
       *
       * The `update` methods support partials. Unspecified or `undefined` fields
       * are left unchanged:
       *
       * ```ts
       * // Priority left unchanged.
       * await zero.mutate.issue.update({id: '1', title: 'Updated title'});
       * ```
       */
      mutate;
      /**
       * Provides a way to batch multiple CRUD mutations together:
       *
       * ```ts
       * await zero.mutateBatch(m => {
       *   await m.issue.create({id: '1', title: 'First issue'});
       *   await m.comment.create({id: '1', text: 'First comment', issueID: '1'});
       * });
       * ```
       *
       * Batch sends all mutations in a single transaction. If one fails, all are
       * rolled back together. Batch can also be more efficient than making many
       * individual mutations.
       *
       * `mutateBatch` is not allowed inside another `mutateBatch` call. Doing so
       * will throw an error.
       */
      mutateBatch;
      /**
       * Whether this Zero instance has been closed.
       *
       * Once a Zero instance has been closed it no longer syncs, you can no
       * longer query or mutate data with it, and its query views stop updating.
       */
      get closed() {
        return this.#rep.closed;
      }
      /**
       * Closes this Zero instance.
       *
       * Once a Zero instance has been closed it no longer syncs, you can no
       * longer query or mutate data with it, and its query views stop updating.
       */
      close() {
        const lc = this.#lc.withContext("close");
        lc.debug?.("Closing Zero instance. Stack:", new Error().stack);
        if (this.#connectionState !== Disconnected) {
          let closeReason = JSON.stringify([
            "closeConnection",
            []
          ]);
          if (closeReason.length > 123) {
            lc.warn?.("Close reason is too long. Removing it.");
            closeReason = "";
          }
          this.#disconnect(
            lc,
            {
              client: "ClientClosed"
            },
            CLOSE_CODE_NORMAL,
            closeReason
          );
        }
        lc.debug?.("Aborting closeAbortController due to close()");
        this.#closeAbortController.abort();
        this.#metrics.stop();
        return this.#rep.close();
      }
      #onPageHide = /* @__PURE__ */ __name((e3) => {
        if (e3.persisted) {
          this.#lc.debug?.("Ignoring pagehide event because it was persisted");
        } else {
          this.#lc.debug?.("Closing client because we got a clean close");
          this.close().catch(() => {
          });
        }
      }, "#onPageHide");
      #onMessage = /* @__PURE__ */ __name((e3) => {
        const lc = this.#lc;
        lc.debug?.("received message", e3.data);
        if (this.closed) {
          lc.debug?.("ignoring message because already closed");
          return;
        }
        const rejectInvalidMessage = /* @__PURE__ */ __name((e22) => this.#rejectMessageError?.reject(
          new Error(
            `Invalid message received from server: ${e22 instanceof Error ? e22.message + ". " : ""}${data}`
          )
        ), "rejectInvalidMessage");
        let downMessage;
        const { data } = e3;
        try {
          downMessage = parse4(JSON.parse(data), downstreamSchema);
        } catch (e22) {
          rejectInvalidMessage(e22);
          return;
        }
        this.#messageCount++;
        const msgType = downMessage[0];
        switch (msgType) {
          case "connected":
            return this.#handleConnectedMessage(lc, downMessage);
          case "error":
            return this.#handleErrorMessage(lc, downMessage);
          case "pong":
            resetBackoff();
            return this.#onPong();
          case "pokeStart":
            return this.#handlePokeStart(lc, downMessage);
          case "pokePart":
            if (downMessage[1].rowsPatch) {
              resetBackoff();
            }
            return this.#handlePokePart(lc, downMessage);
          case "pokeEnd":
            return this.#handlePokeEnd(lc, downMessage);
          case "pull":
            return this.#handlePullResponse(lc, downMessage);
          case "warm":
            break;
          case "deleteClients":
            return this.#deleteClientsManager.clientsDeletedOnServer(
              downMessage[1]
            );
          default:
            msgType;
            rejectInvalidMessage();
        }
      }, "#onMessage");
      #onOpen = /* @__PURE__ */ __name(() => {
        const l = addWebSocketIDFromSocketToLogContext(this.#socket, this.#lc);
        if (this.#connectStart === void 0) {
          l.error?.(
            "Got open event but connect start time is undefined. This should not happen."
          );
        } else {
          const now = Date.now();
          const timeToOpenMs = now - this.#connectStart;
          l.info?.("Got socket open event", {
            navigatorOnline: localNavigator?.onLine,
            timeToOpenMs
          });
        }
      }, "#onOpen");
      #onClose = /* @__PURE__ */ __name((e3) => {
        const l = addWebSocketIDFromSocketToLogContext(this.#socket, this.#lc);
        const { code, reason, wasClean } = e3;
        const log4 = code <= 1001 ? "info" : "error";
        l[log4]?.("Got socket close event", { code, reason, wasClean });
        const closeKind = wasClean ? "CleanClose" : "AbruptClose";
        this.#connectResolver.reject(new CloseError(closeKind));
        this.#disconnect(l, { client: closeKind });
      }, "#onClose");
      // An error on the connection is fatal for the connection.
      async #handleErrorMessage(lc, downMessage) {
        const [, { kind, message }] = downMessage;
        if (kind === MutationRateLimited) {
          this.#lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;
          lc.error?.("Mutation rate limited", { message });
          return;
        }
        lc.info?.(`${kind}: ${message}}`);
        const error3 = new ServerError(downMessage[1]);
        this.#rejectMessageError?.reject(error3);
        lc.debug?.("Rejecting connect resolver due to error", error3);
        this.#connectResolver.reject(error3);
        this.#disconnect(lc, { server: kind });
        if (kind === VersionNotSupported) {
          this.#onUpdateNeeded?.({ type: kind }, message);
        } else if (kind === SchemaVersionNotSupported) {
          await this.#rep.disableClientGroup();
          this.#onUpdateNeeded?.({ type: "SchemaVersionNotSupported" }, message);
        } else if (kind === ClientNotFound) {
          await this.#rep.disableClientGroup();
          this.#onClientStateNotFound?.(onClientStateNotFoundServerReason(message));
        } else if (kind === InvalidConnectionRequestLastMutationID || kind === InvalidConnectionRequestBaseCookie) {
          await dropDatabase(this.#rep.idbName);
          reloadWithReason(lc, this.#reload, serverAheadReloadReason(kind));
        }
      }
      async #handleConnectedMessage(lc, connectedMessage) {
        const now = Date.now();
        const [, connectBody] = connectedMessage;
        lc = addWebSocketIDToLogContext(connectBody.wsid, lc);
        if (this.#connectedCount === 0) {
          this.#checkConnectivity("firstConnect");
        } else if (this.#connectErrorCount > 0) {
          this.#checkConnectivity("connectAfterError");
        }
        this.#connectedCount++;
        this.#connectedAt = now;
        this.#metrics.lastConnectError.clear();
        const proceedingConnectErrorCount = this.#connectErrorCount;
        this.#connectErrorCount = 0;
        let timeToConnectMs;
        let connectMsgLatencyMs;
        if (this.#connectStart === void 0) {
          lc.error?.(
            "Got connected message but connect start time is undefined. This should not happen."
          );
        } else {
          timeToConnectMs = now - this.#connectStart;
          this.#metrics.timeToConnectMs.set(timeToConnectMs);
          connectMsgLatencyMs = connectBody.timestamp !== void 0 ? now - connectBody.timestamp : void 0;
          this.#connectStart = void 0;
        }
        let totalTimeToConnectMs;
        if (this.#totalToConnectStart === void 0) {
          lc.error?.(
            "Got connected message but total to connect start time is undefined. This should not happen."
          );
        } else {
          totalTimeToConnectMs = now - this.#totalToConnectStart;
          this.#totalToConnectStart = void 0;
        }
        this.#metrics.setConnected(timeToConnectMs ?? 0, totalTimeToConnectMs ?? 0);
        lc.info?.("Connected", {
          navigatorOnline: localNavigator?.onLine,
          timeToConnectMs,
          totalTimeToConnectMs,
          connectMsgLatencyMs,
          connectedCount: this.#connectedCount,
          proceedingConnectErrorCount
        });
        this.#lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;
        lc.debug?.("Resolving connect resolver");
        const socket = must(this.#socket);
        const queriesPatch = await this.#rep.query(
          (tx) => this.#queryManager.getQueriesPatch(tx, this.#initConnectionQueries)
        );
        const hasDeletedClients = /* @__PURE__ */ __name(() => skipEmptyArray(this.#deletedClients?.clientIDs) || skipEmptyArray(this.#deletedClients?.clientGroupIDs), "hasDeletedClients");
        const maybeSendDeletedClients = /* @__PURE__ */ __name(() => {
          if (hasDeletedClients()) {
            send2(socket, ["deleteClients", this.#deletedClients]);
            this.#deletedClients = void 0;
          }
        }, "maybeSendDeletedClients");
        if (queriesPatch.size > 0 && this.#initConnectionQueries !== void 0) {
          maybeSendDeletedClients();
          send2(socket, [
            "changeDesiredQueries",
            {
              desiredQueriesPatch: [...queriesPatch.values()]
            }
          ]);
        } else if (this.#initConnectionQueries === void 0) {
          const clientSchema2 = this.#clientSchema;
          send2(socket, [
            "initConnection",
            {
              desiredQueriesPatch: [...queriesPatch.values()],
              deleted: skipEmptyDeletedClients(this.#deletedClients),
              // The clientSchema only needs to be sent for the very first request.
              // Henceforth it is stored with the CVR and verified automatically.
              ...this.#connectCookie === null ? { clientSchema: clientSchema2 } : {}
            }
          ]);
          this.#deletedClients = void 0;
        }
        this.#initConnectionQueries = void 0;
        maybeSendDeletedClients();
        this.#setConnectionState(Connected);
        this.#connectResolver.resolve();
      }
      /**
       * Starts a new connection. This will create the WebSocket that does the HTTP
       * request to the server.
       *
       * {@link #connect} will throw an assertion error if the
       * {@link #connectionState} is not {@link ConnectionState.Disconnected}.
       * Callers MUST check the connection state before calling this method and log
       * an error as needed.
       *
       * The function will resolve once the socket is connected. If you need to know
       * when a connection has been established, as in we have received the
       * {@link ConnectedMessage}, you should await the {@link #connectResolver}
       * promise. The {@link #connectResolver} promise rejects if an error message
       * is received before the connected message is received or if the connection
       * attempt times out.
       */
      async #connect(l, additionalConnectParams) {
        assert3(this.#server);
        assert3(this.#connectionState === Disconnected);
        const wsid = nanoid();
        l = addWebSocketIDToLogContext(wsid, l);
        l.info?.("Connecting...", { navigatorOnline: localNavigator?.onLine });
        this.#setConnectionState(Connecting);
        assert3(this.#connectStart === void 0);
        const now = Date.now();
        this.#connectStart = now;
        if (this.#totalToConnectStart === void 0) {
          this.#totalToConnectStart = now;
        }
        if (this.closed) {
          return;
        }
        this.#connectCookie = parse4(
          await this.#rep.cookie,
          nullableVersionSchema
        );
        if (this.closed) {
          return;
        }
        const timeoutID = setTimeout(() => {
          l.debug?.("Rejecting connect resolver due to timeout");
          this.#connectResolver.reject(new TimedOutError("Connect"));
          this.#disconnect(l, {
            client: "ConnectTimeout"
          });
        }, CONNECT_TIMEOUT_MS);
        const abortHandler = /* @__PURE__ */ __name(() => {
          clearTimeout(timeoutID);
        }, "abortHandler");
        this.#closeAbortController.signal.addEventListener("abort", abortHandler);
        const [ws, initConnectionQueries, deletedClients] = await createSocket(
          this.#rep,
          this.#queryManager,
          this.#deleteClientsManager,
          toWSString(this.#server),
          this.#connectCookie,
          this.clientID,
          await this.clientGroupID,
          this.#clientSchema,
          this.userID,
          this.#rep.auth,
          this.#lastMutationIDReceived,
          wsid,
          this.#options.logLevel === "debug",
          l,
          this.#options.maxHeaderLength,
          additionalConnectParams
        );
        if (this.closed) {
          return;
        }
        this.#initConnectionQueries = initConnectionQueries;
        this.#deletedClients = deletedClients;
        ws.addEventListener("message", this.#onMessage);
        ws.addEventListener("open", this.#onOpen);
        ws.addEventListener("close", this.#onClose);
        this.#socket = ws;
        this.#socketResolver.resolve(ws);
        getBrowserGlobal("window")?.addEventListener("pagehide", this.#onPageHide);
        try {
          l.debug?.("Waiting for connection to be acknowledged");
          await this.#connectResolver.promise;
        } finally {
          clearTimeout(timeoutID);
          this.#closeAbortController.signal.removeEventListener(
            "abort",
            abortHandler
          );
        }
      }
      #disconnect(l, reason, closeCode, closeReason) {
        if (this.#connectionState === Connecting) {
          this.#connectErrorCount++;
        }
        l.info?.("disconnecting", {
          navigatorOnline: localNavigator?.onLine,
          reason,
          connectStart: this.#connectStart,
          totalToConnectStart: this.#totalToConnectStart,
          connectedAt: this.#connectedAt,
          connectionDuration: this.#connectedAt ? Date.now() - this.#connectedAt : 0,
          messageCount: this.#messageCount,
          connectionState: this.#connectionState,
          connectErrorCount: this.#connectErrorCount
        });
        switch (this.#connectionState) {
          case Connected: {
            if (this.#connectStart !== void 0) {
              l.error?.(
                "disconnect() called while connected but connect start time is defined. This should not happen."
              );
            }
            break;
          }
          case Connecting: {
            this.#metrics.lastConnectError.set(getLastConnectErrorValue(reason));
            this.#metrics.timeToConnectMs.set(DID_NOT_CONNECT_VALUE);
            this.#metrics.setConnectError(reason);
            if (this.#connectErrorCount % CHECK_CONNECTIVITY_ON_ERROR_FREQUENCY === 1) {
              this.#checkConnectivity(
                `connectErrorCount=${this.#connectErrorCount}`
              );
            }
            if (this.#connectStart === void 0) {
              l.error?.(
                "disconnect() called while connecting but connect start time is undefined. This should not happen."
              );
            }
            break;
          }
          case Disconnected:
            l.error?.("disconnect() called while disconnected");
            break;
        }
        this.#socketResolver = resolver();
        l.debug?.("Creating new connect resolver");
        this.#connectResolver = resolver();
        this.#setConnectionState(Disconnected);
        this.#messageCount = 0;
        this.#connectStart = void 0;
        this.#connectedAt = 0;
        this.#socket?.removeEventListener("message", this.#onMessage);
        this.#socket?.removeEventListener("open", this.#onOpen);
        this.#socket?.removeEventListener("close", this.#onClose);
        this.#socket?.close(closeCode, closeReason);
        this.#socket = void 0;
        this.#lastMutationIDSent = NULL_LAST_MUTATION_ID_SENT;
        this.#pokeHandler.handleDisconnect();
        getBrowserGlobal("window")?.removeEventListener(
          "pagehide",
          this.#onPageHide
        );
      }
      #handlePokeStart(_lc, pokeMessage) {
        this.#abortPingTimeout();
        this.#pokeHandler.handlePokeStart(pokeMessage[1]);
      }
      #handlePokePart(_lc, pokeMessage) {
        this.#abortPingTimeout();
        const lastMutationIDChangeForSelf = this.#pokeHandler.handlePokePart(
          pokeMessage[1]
        );
        if (lastMutationIDChangeForSelf !== void 0) {
          this.#lastMutationIDReceived = lastMutationIDChangeForSelf;
        }
      }
      #handlePokeEnd(_lc, pokeMessage) {
        this.#abortPingTimeout();
        this.#pokeHandler.handlePokeEnd(pokeMessage[1]);
      }
      #onPokeError() {
        const lc = this.#lc;
        lc.info?.(
          "poke error, disconnecting?",
          this.#connectionState !== Disconnected
        );
        if (this.#connectionState !== Disconnected) {
          this.#disconnect(lc, {
            client: "UnexpectedBaseCookie"
          });
        }
      }
      #handlePullResponse(lc, pullResponseMessage) {
        this.#abortPingTimeout();
        const body2 = pullResponseMessage[1];
        lc = lc.withContext("requestID", body2.requestID);
        lc.debug?.("Handling pull response", body2);
        const resolver9 = this.#pendingPullsByRequestID.get(body2.requestID);
        if (!resolver9) {
          lc.debug?.("No resolver found");
          return;
        }
        resolver9.resolve(pullResponseMessage[1]);
      }
      async #pusher(req, requestID) {
        assert3(req.pushVersion === 1);
        await this.#connectResolver.promise;
        const lc = this.#lc.withContext("requestID", requestID);
        lc.debug?.(`pushing ${req.mutations.length} mutations`);
        const socket = this.#socket;
        assert3(socket);
        const isMutationRecoveryPush = req.clientGroupID !== await this.clientGroupID;
        const start = isMutationRecoveryPush ? 0 : req.mutations.findIndex(
          (m) => m.clientID === this.#lastMutationIDSent.clientID && m.id === this.#lastMutationIDSent.id
        ) + 1;
        lc.debug?.(
          isMutationRecoveryPush ? "pushing for recovery" : "pushing",
          req.mutations.length - start,
          "mutations of",
          req.mutations.length,
          "mutations."
        );
        const now = Date.now();
        for (let i = start; i < req.mutations.length; i++) {
          const m = req.mutations[i];
          const timestamp2 = now - Math.round(performance.now() - m.timestamp);
          const zeroM = m.name === CRUD_MUTATION_NAME ? {
            type: CRUD,
            timestamp: timestamp2,
            id: m.id,
            clientID: m.clientID,
            name: m.name,
            args: [mapCRUD(m.args, this.#clientToServer)]
          } : {
            type: Custom,
            timestamp: timestamp2,
            id: m.id,
            clientID: m.clientID,
            name: m.name,
            args: [m.args]
          };
          const msg = [
            "push",
            {
              timestamp: now,
              clientGroupID: req.clientGroupID,
              mutations: [zeroM],
              pushVersion: req.pushVersion,
              requestID
            }
          ];
          send2(socket, msg);
          if (!isMutationRecoveryPush) {
            this.#lastMutationIDSent = { clientID: m.clientID, id: m.id };
          }
        }
        return {
          httpRequestInfo: {
            errorMessage: "",
            httpStatusCode: 200
          }
        };
      }
      async #updateAuthToken(lc, error3) {
        const { auth: authOption } = this.#options;
        const auth = await (typeof authOption === "function" ? authOption(error3) : authOption);
        if (auth) {
          lc.debug?.("Got auth token");
          this.#rep.auth = auth;
        }
      }
      async #runLoop() {
        this.#lc.info?.(`Starting Zero version: ${this.version}`);
        if (this.#server === null) {
          this.#lc.info?.("No socket origin provided, not starting connect loop.");
          return;
        }
        let runLoopCounter = 0;
        const bareLogContext = this.#lc;
        const getLogContext = /* @__PURE__ */ __name(() => {
          let lc = bareLogContext;
          if (this.#socket) {
            lc = addWebSocketIDFromSocketToLogContext(this.#socket, lc);
          }
          return lc.withContext("runLoopCounter", runLoopCounter);
        }, "getLogContext");
        await this.#updateAuthToken(bareLogContext);
        let needsReauth = false;
        let gotError = false;
        let backoffMs = RUN_LOOP_INTERVAL_MS;
        let additionalConnectParams;
        while (!this.closed) {
          runLoopCounter++;
          let lc = getLogContext();
          backoffMs = RUN_LOOP_INTERVAL_MS;
          try {
            switch (this.#connectionState) {
              case Disconnected: {
                if (this.#visibilityWatcher.visibilityState === "hidden") {
                  this.#metrics.setDisconnectedWaitingForVisible();
                  this.#totalToConnectStart = void 0;
                }
                await this.#visibilityWatcher.waitForVisible();
                if (needsReauth) {
                  await this.#updateAuthToken(lc, "invalid-token");
                }
                if (reloadScheduled()) {
                  break;
                }
                await this.#connect(lc, additionalConnectParams);
                additionalConnectParams = void 0;
                if (this.closed) {
                  break;
                }
                assert3(this.#socket);
                lc = getLogContext();
                lc.debug?.("Connected successfully");
                gotError = false;
                needsReauth = false;
                this.#setOnline(true);
                break;
              }
              case Connecting:
                lc.error?.("unreachable");
                gotError = true;
                break;
              case Connected: {
                const controller = new AbortController();
                this.#abortPingTimeout = () => controller.abort();
                const [pingTimeoutPromise, pingTimeoutAborted] = sleepWithAbort(
                  PING_INTERVAL_MS,
                  controller.signal
                );
                this.#rejectMessageError = resolver();
                const PING = 0;
                const HIDDEN = 2;
                const raceResult = await promiseRace([
                  pingTimeoutPromise,
                  pingTimeoutAborted,
                  this.#visibilityWatcher.waitForHidden(),
                  this.#connectionStateChangeResolver.promise,
                  this.#rejectMessageError.promise
                ]);
                if (this.closed) {
                  this.#rejectMessageError = void 0;
                  break;
                }
                switch (raceResult) {
                  case PING: {
                    const pingResult = await this.#ping(
                      lc,
                      this.#rejectMessageError.promise
                    );
                    if (pingResult === TimedOut) {
                      gotError = true;
                    }
                    break;
                  }
                  case HIDDEN:
                    this.#disconnect(lc, {
                      client: "Hidden"
                    });
                    this.#setOnline(false);
                    break;
                }
                this.#rejectMessageError = void 0;
              }
            }
          } catch (ex) {
            if (this.#connectionState !== Connected) {
              lc.error?.("Failed to connect", ex, {
                lmid: this.#lastMutationIDReceived,
                baseCookie: this.#connectCookie
              });
            }
            lc.debug?.(
              "Got an exception in the run loop",
              "state:",
              this.#connectionState,
              "exception:",
              ex
            );
            if (isAuthError(ex)) {
              if (!needsReauth) {
                needsReauth = true;
                continue;
              }
              needsReauth = true;
            }
            if (isServerError(ex) || ex instanceof TimedOutError || ex instanceof CloseError) {
              gotError = true;
            }
            const backoffError = isBackoffError(ex);
            if (backoffError) {
              if (backoffError.minBackoffMs !== void 0) {
                backoffMs = Math.max(backoffMs, backoffError.minBackoffMs);
              }
              if (backoffError.maxBackoffMs !== void 0) {
                backoffMs = Math.min(backoffMs, backoffError.maxBackoffMs);
              }
              additionalConnectParams = backoffError.reconnectParams;
            }
          }
          if (gotError) {
            this.#setOnline(false);
            lc.debug?.(
              "Sleeping",
              backoffMs,
              "ms before reconnecting due to error, state:",
              this.#connectionState
            );
            await sleep(backoffMs);
          }
        }
      }
      async #puller(req, requestID) {
        assert3(req.pullVersion === 1);
        const lc = this.#lc.withContext("requestID", requestID);
        lc.debug?.("Pull", req);
        if (req.clientGroupID === await this.clientGroupID) {
          return {
            httpRequestInfo: {
              errorMessage: "",
              httpStatusCode: 200
            }
          };
        }
        await this.#connectResolver.promise;
        const socket = this.#socket;
        assert3(socket);
        lc.debug?.("Pull is for mutation recovery");
        const cookie = parse4(req.cookie, nullableVersionSchema);
        const pullRequestMessage = [
          "pull",
          {
            clientGroupID: req.clientGroupID,
            cookie,
            requestID
          }
        ];
        send2(socket, pullRequestMessage);
        const pullResponseResolver = resolver();
        this.#pendingPullsByRequestID.set(requestID, pullResponseResolver);
        try {
          const TIMEOUT = 0;
          const RESPONSE = 1;
          const raceResult = await promiseRace([
            sleep(PULL_TIMEOUT_MS),
            pullResponseResolver.promise
          ]);
          switch (raceResult) {
            case TIMEOUT:
              lc.debug?.("Mutation recovery pull timed out");
              throw new Error("Pull timed out");
            case RESPONSE: {
              lc.debug?.("Returning mutation recovery pull response");
              const response = await pullResponseResolver.promise;
              return {
                response: {
                  cookie: response.cookie,
                  lastMutationIDChanges: response.lastMutationIDChanges,
                  patch: []
                },
                httpRequestInfo: {
                  errorMessage: "",
                  httpStatusCode: 200
                }
              };
            }
            default:
              assert3(false, "unreachable");
          }
        } finally {
          pullResponseResolver.reject("timed out");
          this.#pendingPullsByRequestID.delete(requestID);
        }
      }
      #setOnline(online) {
        if (this.#online === online) {
          return;
        }
        this.#online = online;
        this.#onOnlineChange?.(online);
      }
      /**
       * A rough heuristic for whether the client is currently online and
       * authenticated.
       */
      get online() {
        return this.#online;
      }
      /**
       * Starts a ping and waits for a pong.
       *
       * If it takes too long to get a pong we disconnect and this returns
       * {@code PingResult.TimedOut}.
       */
      async #ping(l, messageErrorRejectionPromise) {
        l.debug?.("pinging");
        const { promise, resolve: resolve2 } = resolver();
        this.#onPong = resolve2;
        const pingMessage = ["ping", {}];
        const t0 = performance.now();
        assert3(this.#socket);
        send2(this.#socket, pingMessage);
        const connected2 = await promiseRace([
          promise,
          sleep(PING_TIMEOUT_MS),
          messageErrorRejectionPromise
        ]) === 0;
        const delta = performance.now() - t0;
        if (!connected2) {
          l.info?.("ping failed in", delta, "ms - disconnecting");
          this.#disconnect(l, {
            client: "PingTimeout"
          });
          return TimedOut;
        }
        l.debug?.("ping succeeded in", delta, "ms");
        return Success;
      }
      // Sends a set of metrics to the server. Throws unless the server
      // returns 200.
      // TODO: Reenable metrics reporting
      async #reportMetrics(_allSeries) {
      }
      #checkConnectivity(reason) {
        void this.#checkConnectivityAsync(reason);
      }
      #checkConnectivityAsync(_reason) {
      }
      #registerQueries(schema2) {
        const rv = {};
        const context3 = this.#zeroContext;
        for (const name of Object.keys(schema2.tables)) {
          rv[name] = newQuery(context3, schema2, name);
        }
        return rv;
      }
    };
    __name(createSocket, "createSocket");
    __name(skipEmptyArray, "skipEmptyArray");
    __name(skipEmptyDeletedClients, "skipEmptyDeletedClients");
    __name(addWebSocketIDFromSocketToLogContext, "addWebSocketIDFromSocketToLogContext");
    __name(addWebSocketIDToLogContext, "addWebSocketIDToLogContext");
    __name(promiseRace, "promiseRace");
    TimedOutError = class extends Error {
      static {
        __name(this, "TimedOutError");
      }
      constructor(m) {
        super(`${m} timed out`);
      }
    };
    CloseError = class extends Error {
      static {
        __name(this, "CloseError");
      }
    };
  }
});

// node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/zero.js
var init_zero = __esm({
  "node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/zero.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_chunk_6KJRALZP();
    init_chunk_5X3DESC6();
    init_chunk_MJCITZ5S();
    init_chunk_424PT5DM();
  }
});

// node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-ULOTOBTC.js
var init_chunk_ULOTOBTC = __esm({
  "node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/chunk-ULOTOBTC.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/advanced.js
var init_advanced = __esm({
  "node_modules/.pnpm/@rocicorp+zero@0.17.2025032801/node_modules/@rocicorp/zero/out/advanced.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_chunk_ULOTOBTC();
    init_chunk_MJCITZ5S();
    init_chunk_424PT5DM();
  }
});

// .svelte-kit/output/server/entries/pages/_layout.ts.js
var layout_ts_exports = {};
__export(layout_ts_exports, {
  load: () => load
});
async function load(event) {
  if (event.data.auth) {
    let get_z_options = /* @__PURE__ */ __name(function() {
      return {
        userID: event.data.id,
        server: "https://sync.hiveos.app/",
        schema,
        kvStore: "idb"
        // ... other options
      };
    }, "get_z_options");
    z = new Z(get_z_options());
  } else {
    console.log("No auth, no z");
    z = void 0;
  }
  return {
    auth: event.data.auth,
    id: event.data.id,
    groupId: event.data.groupId,
    z
  };
}
var Z, users2, tasks3, events2, shoppingList2, userGroups2, userGroupMembers2, userGroupRequests2, taskRelationships, eventRelationships, shoppingListRelationships, userGroupRelationships, userGroupRequestsRelationships, schema, z;
var init_layout_ts = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.ts.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_zero();
    init_advanced();
    Z = class {
      static {
        __name(this, "Z");
      }
      current = null;
      constructor(z_options) {
        this.build(z_options);
      }
      build(z_options) {
        this.current = new Zero(z_options);
      }
      close() {
        this.current.close();
      }
    };
    users2 = table3("users").columns({
      id: string8(),
      name: string8(),
      email: string8(),
      password: string8()
    }).primaryKey("id");
    tasks3 = table3("tasks").columns({
      id: string8(),
      name: string8(),
      status: boolean3(),
      createdById: string8(),
      assignedToId: string8()
    }).primaryKey("id");
    events2 = table3("events").columns({
      id: string8(),
      name: string8(),
      datetime: number4(),
      timezone: string8(),
      createdById: string8(),
      assignedToId: string8()
    }).primaryKey("id");
    shoppingList2 = table3("shoppingList").columns({
      id: string8(),
      name: string8(),
      status: boolean3(),
      createdById: string8(),
      assignedToId: string8()
    }).primaryKey("id");
    userGroups2 = table3("userGroups").columns({
      id: string8(),
      name: string8(),
      createdById: string8()
    }).primaryKey("id");
    userGroupMembers2 = table3("userGroupMembers").columns({
      id: string8(),
      userId: string8(),
      userGroupId: string8()
    }).primaryKey("id");
    userGroupRequests2 = table3("userGroupRequests").columns({
      id: string8(),
      email: string8(),
      userGroupId: string8(),
      status: boolean3(),
      sentByEmail: string8(),
      groupName: string8()
    }).primaryKey("id");
    taskRelationships = relationships(tasks3, ({ one: one2 }) => ({
      createdBy: one2({
        sourceField: ["createdById"],
        destSchema: users2,
        destField: ["id"]
      }),
      assignedTo: one2({
        sourceField: ["assignedToId"],
        destSchema: users2,
        destField: ["id"]
      })
    }));
    eventRelationships = relationships(events2, ({ one: one2 }) => ({
      createdBy: one2({
        sourceField: ["createdById"],
        destSchema: users2,
        destField: ["id"]
      }),
      assignedTo: one2({
        sourceField: ["assignedToId"],
        destSchema: users2,
        destField: ["id"]
      })
    }));
    shoppingListRelationships = relationships(shoppingList2, ({ one: one2 }) => ({
      createdBy: one2({
        sourceField: ["createdById"],
        destSchema: users2,
        destField: ["id"]
      }),
      assignedTo: one2({
        sourceField: ["assignedToId"],
        destSchema: users2,
        destField: ["id"]
      })
    }));
    userGroupRelationships = relationships(userGroups2, ({ one: one2 }) => ({
      createdBy: one2({
        sourceField: ["createdById"],
        destSchema: users2,
        destField: ["id"]
      })
    }));
    userGroupRequestsRelationships = relationships(userGroupRequests2, ({ one: one2 }) => ({
      createdBy: one2({
        sourceField: ["sentByEmail"],
        destSchema: users2,
        destField: ["id"]
      }),
      userGroup: one2({
        sourceField: ["userGroupId"],
        destSchema: userGroups2,
        destField: ["id"]
      })
    }));
    schema = createSchema({
      tables: [users2, tasks3, events2, shoppingList2, userGroups2, userGroupMembers2, userGroupRequests2],
      relationships: [
        taskRelationships,
        eventRelationships,
        shoppingListRelationships,
        userGroupRelationships,
        userGroupRequestsRelationships
      ]
    });
    definePermissions(schema, () => {
      return {
        tasks: {
          row: {
            select: ANYONE_CAN,
            insert: ANYONE_CAN,
            update: {
              preMutation: ANYONE_CAN,
              postMutation: ANYONE_CAN
            }
          }
        },
        users: {
          row: {
            select: ANYONE_CAN,
            insert: ANYONE_CAN,
            update: {
              preMutation: ANYONE_CAN,
              postMutation: ANYONE_CAN
            }
          }
        },
        events: {
          row: {
            select: ANYONE_CAN,
            insert: ANYONE_CAN,
            update: {
              preMutation: ANYONE_CAN,
              postMutation: ANYONE_CAN
            },
            delete: ANYONE_CAN
          }
        },
        shoppingList: {
          row: {
            select: ANYONE_CAN,
            insert: ANYONE_CAN,
            update: {
              preMutation: ANYONE_CAN,
              postMutation: ANYONE_CAN
            },
            delete: ANYONE_CAN
          }
        },
        userGroups: {
          row: {
            select: ANYONE_CAN,
            insert: ANYONE_CAN,
            update: {
              preMutation: ANYONE_CAN,
              postMutation: ANYONE_CAN
            },
            delete: ANYONE_CAN
          }
        },
        userGroupMembers: {
          row: {
            select: ANYONE_CAN,
            insert: ANYONE_CAN,
            update: {
              preMutation: ANYONE_CAN,
              postMutation: ANYONE_CAN
            },
            delete: ANYONE_CAN
          }
        },
        userGroupRequests: {
          row: {
            select: ANYONE_CAN,
            insert: ANYONE_CAN,
            update: {
              preMutation: ANYONE_CAN,
              postMutation: ANYONE_CAN
            },
            delete: ANYONE_CAN
          }
        }
      };
    });
    __name(load, "load");
  }
});

// .svelte-kit/output/server/entries/pages/_layout.server.ts.js
var layout_server_ts_exports = {};
__export(layout_server_ts_exports, {
  load: () => load2,
  ssr: () => ssr
});
async function load2({ locals, url, cookies }) {
  console.log(locals);
  let auth;
  let id;
  let groupId;
  if (!locals?.user) {
    auth = false;
    id = "";
    groupId = "0";
    if (url.pathname !== "/account/login" && url.pathname !== "/account/register") {
      throw redirect(302, "/account/login");
    }
  } else {
    auth = true;
    id = locals.user.id;
    groupId = locals.user.groupId;
  }
  return { auth, id, groupId };
}
var ssr;
var init_layout_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.server.ts.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_chunks();
    ssr = false;
    __name(load2, "load");
  }
});

// .svelte-kit/output/server/entries/pages/_layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => _layout
});
function LogoutIcon($$payload) {
  $$payload.out += `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svelte-ajades"><path d="M377.9 105.9L500.7 228.7c7.2 7.2 11.3 17.1 11.3 27.3s-4.1 20.1-11.3 27.3L377.9 406.1c-6.4 6.4-15 9.9-24 9.9c-18.7 0-33.9-15.2-33.9-33.9l0-62.1-128 0c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32l128 0 0-62.1c0-18.7 15.2-33.9 33.9-33.9c9 0 17.6 3.6 24 9.9zM160 96L96 96c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-64 0c-53 0-96-43-96-96L0 128C0 75 43 32 96 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32z"></path></svg>`;
}
function MenuIcon($$payload) {
  $$payload.out += `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svelte-ajades"><path d="M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"></path></svg>`;
}
function _layout($$payload, $$props) {
  push();
  let { children, data } = $$props;
  let auth = data.auth;
  let menuOpen = false;
  $$payload.out += `<header class="svelte-w5w99z"><h1 class="svelte-w5w99z">HiveOS</h1> <nav class="svelte-w5w99z">`;
  if (auth) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<a class="button svelte-w5w99z" href="/account/logout">Logout `;
    LogoutIcon($$payload);
    $$payload.out += `<!----></a> <button class="menu-button svelte-w5w99z" aria-label="Open menu">`;
    {
      $$payload.out += "<!--[!-->";
      MenuIcon($$payload);
    }
    $$payload.out += `<!--]--></button>`;
  } else {
    $$payload.out += "<!--[!-->";
    $$payload.out += `<a href="/account/login" class="svelte-w5w99z">Login</a> <a href="/account/register" class="svelte-w5w99z">Register</a>`;
  }
  $$payload.out += `<!--]--></nav></header> <div class="main-layout svelte-w5w99z"><aside${attr_class("svelte-w5w99z", void 0, { "menuOpen": menuOpen })}>`;
  if (auth) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<ul class="svelte-w5w99z"><li class="svelte-w5w99z"><a href="/" class="svelte-w5w99z">Dashboard</a></li> <li class="svelte-w5w99z"><a href="/calendar" class="svelte-w5w99z">Calendar</a></li> <li class="svelte-w5w99z"><a href="/events" class="svelte-w5w99z">Events</a></li> <li class="svelte-w5w99z"><a href="/shopping-list" class="svelte-w5w99z">Shopping List</a></li> <li class="svelte-w5w99z"><a href="/tasks" class="svelte-w5w99z">Task list</a></li> <li class="svelte-w5w99z"><a href="/recipies" class="svelte-w5w99z">Recipies</a></li> <li class="bottom svelte-w5w99z"><a href="/account" class="svelte-w5w99z">Account</a></li></ul>`;
  } else {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]--></aside> <main${attr_class("svelte-w5w99z", void 0, { "menuOpen": menuOpen })}>`;
  children($$payload);
  $$payload.out += `<!----></main></div> <footer></footer>`;
  pop();
}
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_index2();
    init_clsx();
    __name(LogoutIcon, "LogoutIcon");
    __name(MenuIcon, "MenuIcon");
    __name(_layout, "_layout");
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  server: () => layout_server_ts_exports,
  server_id: () => server_id,
  stylesheets: () => stylesheets,
  universal: () => layout_ts_exports,
  universal_id: () => universal_id
});
var index, component_cache, component, universal_id, server_id, imports, stylesheets, fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_layout_ts();
    init_layout_server_ts();
    index = 0;
    component = /* @__PURE__ */ __name(async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default, "component");
    universal_id = "src/routes/+layout.ts";
    server_id = "src/routes/+layout.server.ts";
    imports = ["_app/immutable/nodes/0.6b2VjBYr.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/B12HVwOM.js", "_app/immutable/chunks/DS17_zEZ.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/CWIBd0RA.js", "_app/immutable/chunks/BbFkPdsf.js", "_app/immutable/chunks/Ccvmo-eH.js", "_app/immutable/chunks/AVv-E3Vi.js"];
    stylesheets = ["_app/immutable/assets/0.BxLCPXcD.css"];
    fonts = [];
  }
});

// .svelte-kit/output/server/chunks/client.js
function create_updated_store() {
  const { set: set2, subscribe } = writable(false);
  {
    return {
      subscribe,
      // eslint-disable-next-line @typescript-eslint/require-await
      check: /* @__PURE__ */ __name(async () => false, "check")
    };
  }
}
function get2(key2, parse5 = JSON.parse) {
  try {
    return parse5(sessionStorage[key2]);
  } catch {
  }
}
var SNAPSHOT_KEY, SCROLL_KEY, is_legacy, stores2;
var init_client = __esm({
  ".svelte-kit/output/server/chunks/client.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_exports();
    init_equality();
    SNAPSHOT_KEY = "sveltekit:snapshot";
    SCROLL_KEY = "sveltekit:scroll";
    __name(create_updated_store, "create_updated_store");
    is_legacy = noop.toString().includes("$$") || /function \w+\(\) \{\}/.test(noop.toString());
    if (is_legacy) {
      ({
        data: {},
        form: null,
        error: null,
        params: {},
        route: { id: null },
        state: {},
        status: -1,
        url: new URL("https://example.com")
      });
    }
    __name(get2, "get");
    get2(SCROLL_KEY) ?? {};
    get2(SNAPSHOT_KEY) ?? {};
    stores2 = {
      updated: /* @__PURE__ */ create_updated_store()
    };
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error$1
});
function context2() {
  return getContext("__request__");
}
function Error$1($$payload, $$props) {
  push();
  $$payload.out += `<h1>${escape_html(page.status)}</h1> <p>${escape_html(page.error?.message)}</p>`;
  pop();
}
var page$1, page;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_index2();
    init_clsx();
    init_client();
    ({
      check: stores2.updated.check
    });
    __name(context2, "context");
    page$1 = {
      get error() {
        return context2().page.error;
      },
      get status() {
        return context2().page.status;
      }
    };
    page = page$1;
    __name(Error$1, "Error$1");
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2, component_cache2, component2, imports2, stylesheets2, fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    index2 = 1;
    component2 = /* @__PURE__ */ __name(async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default, "component");
    imports2 = ["_app/immutable/nodes/1.CbCdDuF8.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/AVv-E3Vi.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/BbmRlLdw.js", "_app/immutable/chunks/CWIBd0RA.js", "_app/immutable/chunks/BbFkPdsf.js", "_app/immutable/chunks/DkGiYyGV.js", "_app/immutable/chunks/C2P0YLJE.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});

// .svelte-kit/output/server/chunks/query.svelte.js
function createSubscriber(_) {
  return () => {
  };
}
function getDefaultSnapshot(singular) {
  return singular ? defaultSnapshots.singular : defaultSnapshots.plural;
}
var emptyArray, defaultSnapshots, ViewWrapper, ViewStore, viewStore, Query2;
var init_query_svelte = __esm({
  ".svelte-kit/output/server/chunks/query.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_index2();
    init_advanced();
    __name(createSubscriber, "createSubscriber");
    emptyArray = [];
    defaultSnapshots = {
      singular: [void 0, { type: "unknown" }],
      plural: [emptyArray, { type: "unknown" }]
    };
    __name(getDefaultSnapshot, "getDefaultSnapshot");
    ViewWrapper = class {
      static {
        __name(this, "ViewWrapper");
      }
      query;
      onMaterialized;
      onDematerialized;
      #view;
      #data = { "": void 0 };
      #status = { type: "unknown" };
      #subscribe;
      #refCountMap = /* @__PURE__ */ new WeakMap();
      constructor(query, onMaterialized, onDematerialized) {
        this.query = query;
        this.onMaterialized = onMaterialized;
        this.onDematerialized = onDematerialized;
        this.#data = {
          "": this.query.format.singular ? void 0 : []
        };
        this.#subscribe = createSubscriber();
      }
      #onData = /* @__PURE__ */ __name((snap, resultType, update) => {
        const data = snap === void 0 ? snap : structuredClone(snap);
        this.#refCountMap.delete(this.#data);
        this.#data = { "": data };
        this.#refCountMap.set(this.#data, 1);
        this.#status = { type: resultType };
      }, "#onData");
      #applyChange(change) {
        applyChange(this.#data, change, this.query.schema, "", this.query.format, this.#refCountMap);
      }
      #materializeIfNeeded() {
        if (!this.#view) {
          this.#view = this.query.materialize();
          this.onMaterialized(this);
        }
      }
      // Used in Svelte components
      get current() {
        this.#subscribe();
        const data = this.#data[""];
        return [data, this.#status];
      }
    };
    ViewStore = class {
      static {
        __name(this, "ViewStore");
      }
      // eslint-disable-next-line
      #views = /* @__PURE__ */ new Map();
      getView(clientID, query, enabled = true) {
        if (!enabled) {
          return new ViewWrapper(query, () => {
          }, () => {
          });
        }
        const hash5 = query.hash() + clientID;
        let existing = this.#views.get(hash5);
        if (!existing) {
          existing = new ViewWrapper(
            query,
            (view) => {
              const lastView = this.#views.get(hash5);
              if (lastView && lastView !== view) {
                throw new Error("View already exists");
              }
              this.#views.set(hash5, view);
            },
            () => this.#views.delete(hash5)
          );
          this.#views.set(hash5, existing);
        }
        return existing;
      }
    };
    viewStore = new ViewStore();
    Query2 = class {
      static {
        __name(this, "Query");
      }
      current = null;
      details = null;
      #query_impl;
      #view;
      constructor(query, enabled = true) {
        const z2 = getContext("z");
        const id = z2?.current?.userID ? z2?.current.userID : "anon";
        this.#query_impl = query;
        const default_snapshot = getDefaultSnapshot(this.#query_impl.format.singular);
        this.current = default_snapshot[0];
        this.details = default_snapshot[1];
        this.#view = viewStore.getView(id, this.#query_impl, enabled);
        this.current = this.#view.current[0];
        this.details = this.#view.current[1];
      }
      // Method to update the query
      updateQuery(newQuery2, enabled = true) {
        const z2 = getContext("z");
        const id = z2?.current?.userID ? z2?.current.userID : "anon";
        this.#query_impl = newQuery2;
        this.#view = viewStore.getView(id, this.#query_impl, enabled);
        this.current = this.#view.current[0];
        this.details = this.#view.current[1];
      }
    };
  }
});

// .svelte-kit/output/server/chunks/eventsList.js
function DeleteIcon($$payload) {
  $$payload.out += `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svelte-t8zj09"><path d="M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z"></path></svg>`;
}
function EventsList($$payload, $$props) {
  push();
  let { data } = $$props;
  let z2 = data.z;
  let groupId = data.groupId;
  if (groupId === "0") {
    groupId = data.id;
  }
  const events3 = new Query2(z2.current.query.events.where("assignedToId", groupId).orderBy("datetime", "asc"));
  $$payload.out += `<div>`;
  if (events3.current.length === 0) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<p>No events found.</p>`;
  } else {
    $$payload.out += "<!--[!-->";
    const each_array = ensure_array_like(events3.current);
    $$payload.out += `<ul><!--[-->`;
    for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
      let event = each_array[$$index];
      $$payload.out += `<li class="svelte-1b5up0o">${escape_html(event.name)} <button${attr("data-id", event.id)} class="svelte-1b5up0o">`;
      DeleteIcon($$payload);
      $$payload.out += `<!----></button></li>`;
    }
    $$payload.out += `<!--]--></ul>`;
  }
  $$payload.out += `<!--]--></div>`;
  pop();
}
var init_eventsList = __esm({
  ".svelte-kit/output/server/chunks/eventsList.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_index2();
    init_clsx();
    init_zero();
    init_query_svelte();
    __name(DeleteIcon, "DeleteIcon");
    __name(EventsList, "EventsList");
  }
});

// .svelte-kit/output/server/chunks/shoppingList.js
function ShoppingList($$payload, $$props) {
  push();
  let { data } = $$props;
  let z2 = data.z;
  let groupid = data.groupId;
  if (groupid === "0") {
    groupid = data.id;
  }
  const shoppingList3 = new Query2(z2.current.query.shoppingList.where("assignedToId", groupid));
  $$payload.out += `<div>`;
  if (shoppingList3.current.length === 0) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<p>No items in the shopping list.</p>`;
  } else {
    $$payload.out += "<!--[!-->";
    const each_array = ensure_array_like(shoppingList3.current);
    $$payload.out += `<ul><!--[-->`;
    for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
      let item = each_array[$$index];
      $$payload.out += `<li><input type="checkbox"${attr("value", item.id)}${attr("checked", item.status, true)}/> ${escape_html(item.name)} <button${attr("data-id", item.id)}>Delete</button></li>`;
    }
    $$payload.out += `<!--]--></ul>`;
  }
  $$payload.out += `<!--]--></div>`;
  pop();
}
var init_shoppingList = __esm({
  ".svelte-kit/output/server/chunks/shoppingList.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_index2();
    init_zero();
    init_query_svelte();
    __name(ShoppingList, "ShoppingList");
  }
});

// .svelte-kit/output/server/entries/pages/_page.svelte.js
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => _page
});
function _page($$payload, $$props) {
  let { data } = $$props;
  $$payload.out += `<div class="container svelte-ftmuzi"><div class="events svelte-ftmuzi"><h2><a href="/events" class="svelte-ftmuzi">Events</a></h2> `;
  EventsList($$payload, { data });
  $$payload.out += `<!----></div> <div class="weather svelte-ftmuzi"><h2>Weather</h2> <p>Weather component goes here</p></div> <div class="shoppingList svelte-ftmuzi"><h2><a href="/shopping-list" class="svelte-ftmuzi">Shopping List</a></h2> `;
  ShoppingList($$payload, { data });
  $$payload.out += `<!----></div></div>`;
}
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_page.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_eventsList();
    init_shoppingList();
    __name(_page, "_page");
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  stylesheets: () => stylesheets3
});
var index3, component_cache3, component3, imports3, stylesheets3, fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    index3 = 2;
    component3 = /* @__PURE__ */ __name(async () => component_cache3 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default, "component");
    imports3 = ["_app/immutable/nodes/2.DQjn1MAQ.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/BbFkPdsf.js", "_app/immutable/chunks/DGC9cgFm.js", "_app/immutable/chunks/BbmRlLdw.js", "_app/immutable/chunks/CWIBd0RA.js", "_app/immutable/chunks/DS17_zEZ.js", "_app/immutable/chunks/DlO29WQi.js", "_app/immutable/chunks/B12HVwOM.js", "_app/immutable/chunks/AVv-E3Vi.js", "_app/immutable/chunks/prx5VFjU.js"];
    stylesheets3 = ["_app/immutable/assets/eventsList.BKsZWshW.css", "_app/immutable/assets/deleteIcon.CfDbl2f1.css", "_app/immutable/assets/2.n9GndlYR.css"];
    fonts3 = [];
  }
});

// .svelte-kit/output/server/entries/pages/account/_page.server.ts.js
var page_server_ts_exports = {};
__export(page_server_ts_exports, {
  load: () => load3
});
async function load3({ locals }) {
  const groupid = await db.select().from(userGroupMembers).where(eq(userGroupMembers.userId, locals.user.id)).execute() ?? "0";
  const email = await db.select().from(users).where(eq(users.id, locals.user.id)).execute();
  return {
    groupid: groupid[0]?.userGroupId,
    email: email[0]?.email
  };
}
var init_page_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/account/_page.server.ts.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_schema2();
    init_drizzle_orm();
    __name(load3, "load");
  }
});

// .svelte-kit/output/server/entries/pages/account/_page.svelte.js
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => _page2
});
function _page2($$payload, $$props) {
  push();
  const { data } = $$props;
  const z2 = data.z;
  let groupId = data.groupid;
  let userId = data.id;
  let email = data.email?.toLowerCase();
  if (!groupId) {
    groupId = "0";
  }
  let group3 = new Query2(z2.current.query.userGroups.where("id", groupId));
  const user = new Query2(z2.current.query.users.where("id", userId));
  const userGroupMembers3 = new Query2(z2.current.query.userGroupMembers.where("userGroupId", groupId));
  let userGroupRequests3 = new Query2(z2.current.query.userGroupRequests.where("email", email));
  let groupName = group3.current[0]?.name ?? "No group found";
  let showDeleteGroup = group3.current[0]?.name && group3.current[0]?.createdById === userId ? true : false;
  $$payload.out += `<div class="container"><h1>Your details</h1> <div class="details"><p><strong>Name:</strong> ${escape_html(user.current[0]?.name)}</p> <p><strong>Email:</strong> ${escape_html(user.current[0]?.email)}</p> <p><strong>Group:</strong> ${escape_html(groupName)}</p> `;
  if (!group3.current[0]?.name) {
    $$payload.out += "<!--[-->";
    $$payload.out += `<form><input type="text" name="groupName" placeholder="Group Name"/> <button type="submit">Generate Group</button></form> `;
    if (userGroupRequests3.current.length > 0) {
      $$payload.out += "<!--[-->";
      const each_array = ensure_array_like(userGroupRequests3.current);
      $$payload.out += `<p>Pending Requests</p> <ul><!--[-->`;
      for (let $$index = 0, $$length = each_array.length; $$index < $$length; $$index++) {
        let request = each_array[$$index];
        $$payload.out += `<li${attr("data-id", request.id)}>Group:${escape_html(request.groupName)} from ${escape_html(request.sentByEmail)} <button>Accept</button> <button>Reject</button></li>`;
      }
      $$payload.out += `<!--]--></ul>`;
    } else {
      $$payload.out += "<!--[!-->";
    }
    $$payload.out += `<!--]-->`;
  } else {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]--> `;
  if (showDeleteGroup) {
    $$payload.out += "<!--[-->";
    const each_array_1 = ensure_array_like(userGroupMembers3.current);
    $$payload.out += `<form><button type="submit">Delete Group</button></form> <div><div><p>All members:</p> <ul><!--[-->`;
    for (let $$index_1 = 0, $$length = each_array_1.length; $$index_1 < $$length; $$index_1++) {
      let member = each_array_1[$$index_1];
      $$payload.out += `<li>${escape_html(member.userId)}</li>`;
    }
    $$payload.out += `<!--]--></ul></div> <div><p>Invite Members:</p> <form><input type="email" name="email" placeholder="Email"/> <button type="submit">Invite Member</button></form></div></div>`;
  } else {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]--></div></div>`;
  pop();
}
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/account/_page.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_index2();
    init_zero();
    init_query_svelte();
    __name(_page2, "_page");
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  server: () => page_server_ts_exports,
  server_id: () => server_id2,
  stylesheets: () => stylesheets4
});
var index4, component_cache4, component4, server_id2, imports4, stylesheets4, fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_page_server_ts();
    index4 = 3;
    component4 = /* @__PURE__ */ __name(async () => component_cache4 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default, "component");
    server_id2 = "src/routes/account/+page.server.ts";
    imports4 = ["_app/immutable/nodes/3.BEMBEuFh.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/BbmRlLdw.js", "_app/immutable/chunks/CWIBd0RA.js", "_app/immutable/chunks/BbFkPdsf.js", "_app/immutable/chunks/DS17_zEZ.js", "_app/immutable/chunks/DlO29WQi.js", "_app/immutable/chunks/B12HVwOM.js", "_app/immutable/chunks/OxPLOBIU.js"];
    stylesheets4 = [];
    fonts4 = [];
  }
});

// .svelte-kit/output/server/chunks/hash.js
var hash4;
var init_hash = __esm({
  ".svelte-kit/output/server/chunks/hash.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_crypto2();
    hash4 = /* @__PURE__ */ __name((a) => {
      let hashed = crypto_default.pbkdf2Sync(a, "f9fe8255901de62b9184d9b1d070768d298d5bb937b9e6bbe729a1744fbab97677bb40ef1a5ed619e23da653d9ee93e9b613e8776688c79acdad1aa2ed66ad2f", 1e3, 64, `sha512`).toString(`hex`);
      return hashed;
    }, "hash");
  }
});

// .svelte-kit/output/server/entries/pages/account/login/_page.server.ts.js
var page_server_ts_exports2 = {};
__export(page_server_ts_exports2, {
  actions: () => actions,
  load: () => load4
});
async function load4({ locals }) {
  if (locals?.user) {
    throw redirect(302, "/");
  }
  return {
    props: {
      user: locals.user
    }
  };
}
var import_jsonwebtoken2, sign2, actions;
var init_page_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/account/login/_page.server.ts.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_chunks();
    init_hash();
    init_schema2();
    init_drizzle_orm();
    import_jsonwebtoken2 = __toESM(require_jsonwebtoken(), 1);
    ({ sign: sign2 } = import_jsonwebtoken2.default);
    __name(load4, "load");
    actions = {
      login: /* @__PURE__ */ __name(async ({ cookies, request }) => {
        const data = await request.formData();
        const email = data.get("email");
        if (!email) {
          throw redirect(302, "/account/login");
        }
        const password = data.get("password");
        let token;
        const account = await db.select().from(users).where(eq(users.email, email)).execute();
        const hashedPassword = hash4(password);
        if (account[0] && account[0].password === hashedPassword) {
          token = sign2(
            {
              user: email
            },
            "437baa87d7b1834b2b201dc242d60dace1fe4fa46a4d9483771f6a1492f200b412fbb27297e31ab07be1ea5be8fcfada87a8237408ebc7af13e257402c0afe36",
            { expiresIn: "30d" }
          );
        } else {
          console.log("wrong password");
        }
        if (token) {
          cookies.set("session", token, {
            path: "/",
            httpOnly: true,
            sameSite: "strict",
            secure: false,
            maxAge: 60 * 60 * 24 * 30
            // 30 days
          });
        }
        throw redirect(302, "/");
      }, "login")
    };
  }
});

// .svelte-kit/output/server/entries/pages/account/login/_page.svelte.js
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => _page3
});
function _page3($$payload) {
  $$payload.out += `<section><h1>Login</h1> <form method="POST" action="?/login"><input type="email" name="email" placeholder="Email" required/> <input type="password" name="password" placeholder="Password" required/> <button type="submit">Login</button></form></section>`;
}
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/account/login/_page.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_client();
    __name(_page3, "_page");
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  server: () => page_server_ts_exports2,
  server_id: () => server_id3,
  stylesheets: () => stylesheets5
});
var index5, component_cache5, component5, server_id3, imports5, stylesheets5, fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_page_server_ts2();
    index5 = 4;
    component5 = /* @__PURE__ */ __name(async () => component_cache5 ??= (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default, "component");
    server_id3 = "src/routes/account/login/+page.server.ts";
    imports5 = ["_app/immutable/nodes/4.CBehjKsE.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/AVv-E3Vi.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/BbFkPdsf.js", "_app/immutable/chunks/pM4qcl9a.js", "_app/immutable/chunks/DkGiYyGV.js", "_app/immutable/chunks/C2P0YLJE.js"];
    stylesheets5 = [];
    fonts5 = [];
  }
});

// .svelte-kit/output/server/entries/pages/account/logout/_page.server.ts.js
var page_server_ts_exports3 = {};
__export(page_server_ts_exports3, {
  load: () => load5
});
async function load5({ cookies }) {
  cookies.set("session", "", {
    path: "/",
    httpOnly: true,
    sameSite: "strict",
    secure: false,
    maxAge: 0
  });
  return {
    loggedIn: false
  };
}
var init_page_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/pages/account/logout/_page.server.ts.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_chunks();
    __name(load5, "load");
  }
});

// .svelte-kit/output/server/entries/pages/account/logout/_page.svelte.js
var page_svelte_exports4 = {};
__export(page_svelte_exports4, {
  default: () => _page4
});
function _page4($$payload, $$props) {
  push();
  let { data } = $$props;
  data.auth = false;
  pop();
}
var init_page_svelte4 = __esm({
  ".svelte-kit/output/server/entries/pages/account/logout/_page.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_index2();
    __name(_page4, "_page");
  }
});

// .svelte-kit/output/server/nodes/5.js
var __exports6 = {};
__export(__exports6, {
  component: () => component6,
  fonts: () => fonts6,
  imports: () => imports6,
  index: () => index6,
  server: () => page_server_ts_exports3,
  server_id: () => server_id4,
  stylesheets: () => stylesheets6
});
var index6, component_cache6, component6, server_id4, imports6, stylesheets6, fonts6;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_page_server_ts3();
    index6 = 5;
    component6 = /* @__PURE__ */ __name(async () => component_cache6 ??= (await Promise.resolve().then(() => (init_page_svelte4(), page_svelte_exports4))).default, "component");
    server_id4 = "src/routes/account/logout/+page.server.ts";
    imports6 = ["_app/immutable/nodes/5.BpOebX3Q.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/ClG5jPII.js"];
    stylesheets6 = [];
    fonts6 = [];
  }
});

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = __esm({
  "node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/url-alphabet/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  }
});

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/index.browser.js
var nanoid2;
var init_index_browser = __esm({
  "node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/index.browser.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_url_alphabet();
    nanoid2 = /* @__PURE__ */ __name((size2 = 21) => {
      let id = "";
      let bytes = crypto.getRandomValues(new Uint8Array(size2 |= 0));
      while (size2--) {
        id += urlAlphabet[bytes[size2] & 63];
      }
      return id;
    }, "nanoid");
  }
});

// .svelte-kit/output/server/entries/pages/account/register/_page.server.ts.js
var page_server_ts_exports4 = {};
__export(page_server_ts_exports4, {
  actions: () => actions2,
  load: () => load6
});
async function load6({ locals }) {
  return {
    props: {
      user: locals.user
    }
  };
}
var actions2;
var init_page_server_ts4 = __esm({
  ".svelte-kit/output/server/entries/pages/account/register/_page.server.ts.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_chunks();
    init_hash();
    init_schema2();
    init_drizzle_orm();
    init_index_browser();
    __name(load6, "load");
    actions2 = {
      createAccount: /* @__PURE__ */ __name(async ({ request }) => {
        const data = await request.formData();
        console.log(data);
        const email = data.get("email");
        const password = data.get("password");
        const confirmPassword = data.get("confirmPassword");
        const name = data.get("name");
        console.log(email, password, confirmPassword);
        if (password !== confirmPassword) {
          throw redirect(302, "/account/login");
        }
        const account = await db.select().from(users).where(eq(users.email, email)).execute();
        console.log(account);
        if (account[0]) {
          throw redirect(302, "/account/login");
        }
        const hashedPassword = hash4(password);
        (/* @__PURE__ */ new Date()).toISOString();
        try {
          await db.insert(users).values({
            id: nanoid2(),
            email,
            name,
            password: hashedPassword
          }).execute();
        } catch (error3) {
          console.log(error3);
        }
        throw redirect(302, "/account/login");
      }, "createAccount")
    };
  }
});

// .svelte-kit/output/server/entries/pages/account/register/_page.svelte.js
var page_svelte_exports5 = {};
__export(page_svelte_exports5, {
  default: () => _page5
});
function _page5($$payload) {
  $$payload.out += `<section><h1>Register</h1> <form method="POST" action="?/createAccount"><input type="text" name="name" placeholder="Name" required/> <input type="email" name="email" placeholder="Email" required/> <input type="password" name="password" placeholder="Password" required/> <input type="password" name="confirmPassword" placeholder="Confirm Password" required/> <button type="submit">Register</button></form></section>`;
}
var init_page_svelte5 = __esm({
  ".svelte-kit/output/server/entries/pages/account/register/_page.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_client();
    __name(_page5, "_page");
  }
});

// .svelte-kit/output/server/nodes/6.js
var __exports7 = {};
__export(__exports7, {
  component: () => component7,
  fonts: () => fonts7,
  imports: () => imports7,
  index: () => index7,
  server: () => page_server_ts_exports4,
  server_id: () => server_id5,
  stylesheets: () => stylesheets7
});
var index7, component_cache7, component7, server_id5, imports7, stylesheets7, fonts7;
var init__7 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_page_server_ts4();
    index7 = 6;
    component7 = /* @__PURE__ */ __name(async () => component_cache7 ??= (await Promise.resolve().then(() => (init_page_svelte5(), page_svelte_exports5))).default, "component");
    server_id5 = "src/routes/account/register/+page.server.ts";
    imports7 = ["_app/immutable/nodes/6.CI0UjcGE.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/AVv-E3Vi.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/BbFkPdsf.js", "_app/immutable/chunks/pM4qcl9a.js", "_app/immutable/chunks/DkGiYyGV.js", "_app/immutable/chunks/C2P0YLJE.js"];
    stylesheets7 = [];
    fonts7 = [];
  }
});

// .svelte-kit/output/server/entries/pages/events/_page.svelte.js
var page_svelte_exports6 = {};
__export(page_svelte_exports6, {
  default: () => _page6
});
function _page6($$payload, $$props) {
  push();
  let { data } = $$props;
  console.log(data);
  let z2 = data.z;
  new Query2(z2.current.query.events.where("assignedToId", data.id));
  const group3 = new Query2(z2.current.query.userGroups.where("id", data.groupId));
  group3.current[0]?.id ?? data.groupId;
  $$payload.out += `<section class="events svelte-16nyyc0"><h1 class="svelte-16nyyc0">Events</h1> `;
  EventsList($$payload, { data });
  $$payload.out += `<!----> <div class="svelte-16nyyc0"><h2>Add an event</h2> <form class="svelte-16nyyc0"><label for="name" class="svelte-16nyyc0">Event Name <input type="text" id="name" name="name" class="svelte-16nyyc0"/></label> <label for="date" class="svelte-16nyyc0">Date <input type="date" id="date" name="date" class="svelte-16nyyc0"/></label> <label for="time" class="svelte-16nyyc0">Time <input type="time" name="time" id="time" class="svelte-16nyyc0"/></label> <button type="submit">Add</button></form></div></section>`;
  pop();
}
var init_page_svelte6 = __esm({
  ".svelte-kit/output/server/entries/pages/events/_page.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_index2();
    init_zero();
    init_query_svelte();
    init_eventsList();
    __name(_page6, "_page");
  }
});

// .svelte-kit/output/server/nodes/7.js
var __exports8 = {};
__export(__exports8, {
  component: () => component8,
  fonts: () => fonts8,
  imports: () => imports8,
  index: () => index8,
  stylesheets: () => stylesheets8
});
var index8, component_cache8, component8, imports8, stylesheets8, fonts8;
var init__8 = __esm({
  ".svelte-kit/output/server/nodes/7.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    index8 = 7;
    component8 = /* @__PURE__ */ __name(async () => component_cache8 ??= (await Promise.resolve().then(() => (init_page_svelte6(), page_svelte_exports6))).default, "component");
    imports8 = ["_app/immutable/nodes/7.CNEZgr6q.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/CWIBd0RA.js", "_app/immutable/chunks/BbFkPdsf.js", "_app/immutable/chunks/B12HVwOM.js", "_app/immutable/chunks/DS17_zEZ.js", "_app/immutable/chunks/DlO29WQi.js", "_app/immutable/chunks/OxPLOBIU.js", "_app/immutable/chunks/DGC9cgFm.js", "_app/immutable/chunks/BbmRlLdw.js", "_app/immutable/chunks/AVv-E3Vi.js"];
    stylesheets8 = ["_app/immutable/assets/eventsList.BKsZWshW.css", "_app/immutable/assets/deleteIcon.CfDbl2f1.css", "_app/immutable/assets/7.wwjXbm4Y.css"];
    fonts8 = [];
  }
});

// .svelte-kit/output/server/entries/pages/shopping-list/_page.svelte.js
var page_svelte_exports7 = {};
__export(page_svelte_exports7, {
  default: () => _page7
});
function _page7($$payload, $$props) {
  push();
  let { data } = $$props;
  let z2 = data.z;
  const group3 = new Query2(z2.current.query.userGroups.where("id", data.groupId));
  group3.current[0]?.id ?? data.groupId;
  $$payload.out += `<section class="shopping-list svelte-84fep8"><h1 class="svelte-84fep8">Shopping List</h1> `;
  ShoppingList($$payload, { data });
  $$payload.out += `<!----> <div class="svelte-84fep8"><h2>Add an Item</h2> <form class="svelte-84fep8"><label for="name" class="svelte-84fep8">Item Name <input type="text" id="name" name="name" class="svelte-84fep8"/></label> <button type="submit">Add</button></form></div></section>`;
  pop();
}
var init_page_svelte7 = __esm({
  ".svelte-kit/output/server/entries/pages/shopping-list/_page.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_index2();
    init_shoppingList();
    init_zero();
    init_query_svelte();
    __name(_page7, "_page");
  }
});

// .svelte-kit/output/server/nodes/8.js
var __exports9 = {};
__export(__exports9, {
  component: () => component9,
  fonts: () => fonts9,
  imports: () => imports9,
  index: () => index9,
  stylesheets: () => stylesheets9
});
var index9, component_cache9, component9, imports9, stylesheets9, fonts9;
var init__9 = __esm({
  ".svelte-kit/output/server/nodes/8.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    index9 = 8;
    component9 = /* @__PURE__ */ __name(async () => component_cache9 ??= (await Promise.resolve().then(() => (init_page_svelte7(), page_svelte_exports7))).default, "component");
    imports9 = ["_app/immutable/nodes/8.Cg2RMF94.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/CWIBd0RA.js", "_app/immutable/chunks/BbFkPdsf.js", "_app/immutable/chunks/prx5VFjU.js", "_app/immutable/chunks/BbmRlLdw.js", "_app/immutable/chunks/DS17_zEZ.js", "_app/immutable/chunks/DlO29WQi.js", "_app/immutable/chunks/B12HVwOM.js", "_app/immutable/chunks/AVv-E3Vi.js", "_app/immutable/chunks/OxPLOBIU.js"];
    stylesheets9 = ["_app/immutable/assets/deleteIcon.CfDbl2f1.css", "_app/immutable/assets/8.XjXuxHAU.css"];
    fonts9 = [];
  }
});

// .svelte-kit/cloudflare/_worker.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .svelte-kit/output/server/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .svelte-kit/output/server/chunks/internal.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_equality();
init_index2();
init_clsx();
var DEV = false;
var base = "";
var assets = base;
var app_dir = "_app";
var initial = { base, assets };
function override(paths) {
  base = paths.base;
  assets = paths.assets;
}
__name(override, "override");
function reset2() {
  base = initial.base;
  assets = initial.assets;
}
__name(reset2, "reset");
var public_env = {};
var safe_public_env = {};
function set_private_env(environment) {
}
__name(set_private_env, "set_private_env");
function set_public_env(environment) {
  public_env = environment;
}
__name(set_public_env, "set_public_env");
function set_safe_public_env(environment) {
  safe_public_env = environment;
}
__name(set_safe_public_env, "set_safe_public_env");
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var BOUNDARY_EFFECT = 1 << 7;
var UNOWNED = 1 << 8;
var DISCONNECTED = 1 << 9;
var CLEAN = 1 << 10;
var DIRTY = 1 << 11;
var MAYBE_DIRTY = 1 << 12;
var INERT = 1 << 13;
var DESTROYED = 1 << 14;
var EFFECT_RAN = 1 << 15;
var EFFECT_TRANSPARENT = 1 << 16;
var HEAD_EFFECT = 1 << 19;
var EFFECT_HAS_DERIVED = 1 << 20;
var EFFECT_IS_UPDATING = 1 << 21;
var STATE_SYMBOL = Symbol("$state");
var LEGACY_PROPS = Symbol("legacy props");
function effect_update_depth_exceeded() {
  {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
__name(effect_update_depth_exceeded, "effect_update_depth_exceeded");
function hydration_failed() {
  {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
__name(hydration_failed, "hydration_failed");
function state_descriptors_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
__name(state_descriptors_fixed, "state_descriptors_fixed");
function state_prototype_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
__name(state_prototype_fixed, "state_prototype_fixed");
function state_unsafe_mutation() {
  {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
__name(state_unsafe_mutation, "state_unsafe_mutation");
var tracing_mode_flag = false;
var component_context = null;
function set_component_context(context3) {
  component_context = context3;
}
__name(set_component_context, "set_component_context");
function push2(props, runes = false, fn) {
  var ctx = component_context = {
    p: component_context,
    c: null,
    d: false,
    e: null,
    m: false,
    s: props,
    x: null,
    l: null
  };
  teardown(() => {
    ctx.d = true;
  });
}
__name(push2, "push");
function pop2(component10) {
  const context_stack_item = component_context;
  if (context_stack_item !== null) {
    const component_effects = context_stack_item.e;
    if (component_effects !== null) {
      var previous_effect = active_effect;
      var previous_reaction = active_reaction;
      context_stack_item.e = null;
      try {
        for (var i = 0; i < component_effects.length; i++) {
          var component_effect = component_effects[i];
          set_active_effect(component_effect.effect);
          set_active_reaction(component_effect.reaction);
          effect(component_effect.fn);
        }
      } finally {
        set_active_effect(previous_effect);
        set_active_reaction(previous_reaction);
      }
    }
    component_context = context_stack_item.p;
    context_stack_item.m = true;
  }
  return (
    /** @type {T} */
    {}
  );
}
__name(pop2, "pop");
function is_runes() {
  return true;
}
__name(is_runes, "is_runes");
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version4 = /* @__PURE__ */ state(0);
  var reaction = active_reaction;
  var with_parent = /* @__PURE__ */ __name((fn) => {
    var previous_reaction = active_reaction;
    set_active_reaction(reaction);
    var result = fn();
    set_active_reaction(previous_reaction);
    return result;
  }, "with_parent");
  if (is_proxied_array) {
    sources.set("length", /* @__PURE__ */ state(
      /** @type {any[]} */
      value.length
    ));
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s3 = sources.get(prop);
        if (s3 === void 0) {
          s3 = with_parent(() => /* @__PURE__ */ state(descriptor.value));
          sources.set(prop, s3);
        } else {
          set(
            s3,
            with_parent(() => proxy(descriptor.value))
          );
        }
        return true;
      },
      deleteProperty(target, prop) {
        var s3 = sources.get(prop);
        if (s3 === void 0) {
          if (prop in target) {
            sources.set(
              prop,
              with_parent(() => /* @__PURE__ */ state(UNINITIALIZED))
            );
            update_version(version4);
          }
        } else {
          if (is_proxied_array && typeof prop === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n2 = Number(prop);
            if (Number.isInteger(n2) && n2 < ls.v) {
              set(ls, n2);
            }
          }
          set(s3, UNINITIALIZED);
          update_version(version4);
        }
        return true;
      },
      get(target, prop, receiver) {
        if (prop === STATE_SYMBOL) {
          return value;
        }
        var s3 = sources.get(prop);
        var exists2 = prop in target;
        if (s3 === void 0 && (!exists2 || get_descriptor(target, prop)?.writable)) {
          s3 = with_parent(() => /* @__PURE__ */ state(proxy(exists2 ? target[prop] : UNINITIALIZED)));
          sources.set(prop, s3);
        }
        if (s3 !== void 0) {
          var v = get(s3);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop, receiver);
      },
      getOwnPropertyDescriptor(target, prop) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
        if (descriptor && "value" in descriptor) {
          var s3 = sources.get(prop);
          if (s3) descriptor.value = get(s3);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop) {
        if (prop === STATE_SYMBOL) {
          return true;
        }
        var s3 = sources.get(prop);
        var has = s3 !== void 0 && s3.v !== UNINITIALIZED || Reflect.has(target, prop);
        if (s3 !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop)?.writable)) {
          if (s3 === void 0) {
            s3 = with_parent(() => /* @__PURE__ */ state(has ? proxy(target[prop]) : UNINITIALIZED));
            sources.set(prop, s3);
          }
          var value2 = get(s3);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop, value2, receiver) {
        var s3 = sources.get(prop);
        var has = prop in target;
        if (is_proxied_array && prop === "length") {
          for (var i = value2; i < /** @type {Source<number>} */
          s3.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED));
              sources.set(i + "", other_s);
            }
          }
        }
        if (s3 === void 0) {
          if (!has || get_descriptor(target, prop)?.writable) {
            s3 = with_parent(() => /* @__PURE__ */ state(void 0));
            set(
              s3,
              with_parent(() => proxy(value2))
            );
            sources.set(prop, s3);
          }
        } else {
          has = s3.v !== UNINITIALIZED;
          set(
            s3,
            with_parent(() => proxy(value2))
          );
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n2 = Number(prop);
            if (Number.isInteger(n2) && n2 >= ls.v) {
              set(ls, n2 + 1);
            }
          }
          update_version(version4);
        }
        return true;
      },
      ownKeys(target) {
        get(version4);
        var own_keys = Reflect.ownKeys(target).filter((key22) => {
          var source3 = sources.get(key22);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
__name(proxy, "proxy");
function update_version(signal, d = 1) {
  set(signal, signal.v + d);
}
__name(update_version, "update_version");
function destroy_derived_effects(derived) {
  var effects = derived.effects;
  if (effects !== null) {
    derived.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
__name(destroy_derived_effects, "destroy_derived_effects");
function get_derived_parent_effect(derived) {
  var parent = derived.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (
        /** @type {Effect} */
        parent
      );
    }
    parent = parent.parent;
  }
  return null;
}
__name(get_derived_parent_effect, "get_derived_parent_effect");
function execute_derived(derived) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived));
  {
    try {
      destroy_derived_effects(derived);
      value = update_reaction(derived);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
__name(execute_derived, "execute_derived");
function update_derived(derived) {
  var value = execute_derived(derived);
  if (!derived.equals(value)) {
    derived.v = value;
    derived.wv = increment_write_version();
  }
  if (is_destroying_effect) return;
  var status = (skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;
  set_signal_status(derived, status);
}
__name(update_derived, "update_derived");
var old_values = /* @__PURE__ */ new Map();
function source(v, stack) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  return signal;
}
__name(source, "source");
// @__NO_SIDE_EFFECTS__
function state(v, stack) {
  const s3 = source(v);
  push_reaction_value(s3);
  return s3;
}
__name(state, "state");
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable2 = false) {
  const s3 = source(initial_value);
  if (!immutable2) {
    s3.equals = safe_equals;
  }
  return s3;
}
__name(mutable_source, "mutable_source");
function set(source2, value, should_proxy = false) {
  if (active_reaction !== null && !untracking && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 && !reaction_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  return internal_set(source2, new_value);
}
__name(set, "set");
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
  }
  return value;
}
__name(internal_set, "internal_set");
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags = reaction.f;
    if ((flags & DIRTY) !== 0) continue;
    set_signal_status(reaction, status);
    if ((flags & (CLEAN | UNOWNED)) !== 0) {
      if ((flags & DERIVED) !== 0) {
        mark_reactions(
          /** @type {Derived} */
          reaction,
          MAYBE_DIRTY
        );
      } else {
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
__name(mark_reactions, "mark_reactions");
function hydration_mismatch(location2) {
  {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
__name(hydration_mismatch, "hydration_mismatch");
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
__name(set_hydrating, "set_hydrating");
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
__name(set_hydrate_node, "set_hydrate_node");
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(hydrate_node)
  );
}
__name(hydrate_next, "hydrate_next");
var $window;
var first_child_getter;
var next_sibling_getter;
function init_operations2() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
}
__name(init_operations2, "init_operations");
function create_text(value = "") {
  return document.createTextNode(value);
}
__name(create_text, "create_text");
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
__name(get_first_child, "get_first_child");
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
__name(get_next_sibling, "get_next_sibling");
function clear_text_content(node) {
  node.textContent = "";
}
__name(clear_text_content, "clear_text_content");
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
__name(push_effect, "push_effect");
function create_effect(type, fn, sync, push22 = true) {
  var parent = active_effect;
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0
  };
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e3) {
      destroy_effect(effect2);
      throw e3;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  var inert = sync && effect2.deps === null && effect2.first === null && effect2.nodes_start === null && effect2.teardown === null && (effect2.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;
  if (!inert && push22) {
    if (parent !== null) {
      push_effect(effect2, parent);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
      var derived = (
        /** @type {Derived} */
        active_reaction
      );
      (derived.effects ??= []).push(effect2);
    }
  }
  return effect2;
}
__name(create_effect, "create_effect");
function teardown(fn) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn;
  return effect2;
}
__name(teardown, "teardown");
function component_root(fn) {
  const effect2 = create_effect(ROOT_EFFECT, fn, true);
  return (options2 = {}) => {
    return new Promise((fulfil) => {
      if (options2.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
__name(component_root, "component_root");
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
__name(effect, "effect");
function branch(fn, push22 = true) {
  return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push22);
}
__name(branch, "branch");
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
__name(execute_effect_teardown, "execute_effect_teardown");
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    var next = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next;
  }
}
__name(destroy_effect_children, "destroy_effect_children");
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next;
  }
}
__name(destroy_block_effect_children, "destroy_block_effect_children");
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null && effect2.nodes_end !== null) {
    remove_effect_dom(
      effect2.nodes_start,
      /** @type {TemplateNode} */
      effect2.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.transitions;
  if (transitions !== null) {
    for (const transition of transitions) {
      transition.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = null;
}
__name(destroy_effect, "destroy_effect");
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next = node === end ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    node.remove();
    node = next;
  }
}
__name(remove_effect_dom, "remove_effect_dom");
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next = effect2.next;
  if (prev !== null) prev.next = next;
  if (next !== null) next.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next;
    if (parent.last === effect2) parent.last = prev;
  }
}
__name(unlink_effect, "unlink_effect");
function pause_effect(effect2, callback) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  run_out_transitions(transitions, () => {
    destroy_effect(effect2);
    if (callback) callback();
  });
}
__name(pause_effect, "pause_effect");
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = /* @__PURE__ */ __name(() => --remaining || fn(), "check");
    for (var transition of transitions) {
      transition.out(check);
    }
  } else {
    fn();
  }
}
__name(run_out_transitions, "run_out_transitions");
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  if (effect2.transitions !== null) {
    for (const transition of effect2.transitions) {
      if (transition.is_global || local) {
        transitions.push(transition);
      }
    }
  }
  var child = effect2.first;
  while (child !== null) {
    var sibling = child.next;
    var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
    pause_children(child, transitions, transparent ? local : false);
    child = sibling;
  }
}
__name(pause_children, "pause_children");
var micro_tasks = [];
var idle_tasks = [];
function run_micro_tasks() {
  var tasks4 = micro_tasks;
  micro_tasks = [];
  run_all(tasks4);
}
__name(run_micro_tasks, "run_micro_tasks");
function run_idle_tasks() {
  var tasks4 = idle_tasks;
  idle_tasks = [];
  run_all(tasks4);
}
__name(run_idle_tasks, "run_idle_tasks");
function flush_tasks() {
  if (micro_tasks.length > 0) {
    run_micro_tasks();
  }
  if (idle_tasks.length > 0) {
    run_idle_tasks();
  }
}
__name(flush_tasks, "flush_tasks");
function handle_error(error3) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      throw error3;
    }
    effect2.fn(error3);
  } else {
    invoke_error_boundary(error3, effect2);
  }
}
__name(handle_error, "handle_error");
function invoke_error_boundary(error3, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.fn(error3);
        return;
      } catch {
      }
    }
    effect2 = effect2.parent;
  }
  throw error3;
}
__name(invoke_error_boundary, "invoke_error_boundary");
var is_flushing = false;
var last_scheduled_effect = null;
var is_updating_effect = false;
var is_destroying_effect = false;
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
__name(set_is_destroying_effect, "set_is_destroying_effect");
var queued_root_effects = [];
var active_reaction = null;
var untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
__name(set_active_reaction, "set_active_reaction");
var active_effect = null;
function set_active_effect(effect2) {
  active_effect = effect2;
}
__name(set_active_effect, "set_active_effect");
var reaction_sources = null;
function push_reaction_value(value) {
  if (active_reaction !== null && active_reaction.f & EFFECT_IS_UPDATING) {
    if (reaction_sources === null) {
      reaction_sources = [value];
    } else {
      reaction_sources.push(value);
    }
  }
}
__name(push_reaction_value, "push_reaction_value");
var new_deps = null;
var skipped_deps = 0;
var untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
__name(set_untracked_writes, "set_untracked_writes");
var write_version = 1;
var read_version = 0;
var skip_reaction = false;
function increment_write_version() {
  return ++write_version;
}
__name(increment_write_version, "increment_write_version");
function check_dirtiness(reaction) {
  var flags = reaction.f;
  if ((flags & DIRTY) !== 0) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    var is_unowned = (flags & UNOWNED) !== 0;
    if (dependencies !== null) {
      var i;
      var dependency;
      var is_disconnected = (flags & DISCONNECTED) !== 0;
      var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
      var length = dependencies.length;
      if (is_disconnected || is_unowned_connected) {
        var derived = (
          /** @type {Derived} */
          reaction
        );
        var parent = derived.parent;
        for (i = 0; i < length; i++) {
          dependency = dependencies[i];
          if (is_disconnected || !dependency?.reactions?.includes(derived)) {
            (dependency.reactions ??= []).push(derived);
          }
        }
        if (is_disconnected) {
          derived.f ^= DISCONNECTED;
        }
        if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
          derived.f ^= UNOWNED;
        }
      }
      for (i = 0; i < length; i++) {
        dependency = dependencies[i];
        if (check_dirtiness(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if (!is_unowned || active_effect !== null && !skip_reaction) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
__name(check_dirtiness, "check_dirtiness");
function schedule_possible_effect_self_invalidation(signal, effect2, root2 = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if (reaction_sources?.includes(signal)) continue;
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root2) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(schedule_possible_effect_self_invalidation, "schedule_possible_effect_self_invalidation");
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_skip_reaction = skip_reaction;
  var previous_reaction_sources = reaction_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var flags = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  skip_reaction = (flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
  active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  reaction_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  read_version++;
  reaction.f |= EFFECT_IS_UPDATING;
  try {
    var result = (
      /** @type {Function} */
      (0, reaction.fn)()
    );
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (!skip_reaction) {
        for (i = skipped_deps; i < deps.length; i++) {
          (deps[i].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    return result;
  } catch (error3) {
    handle_error(error3);
  } finally {
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    skip_reaction = previous_skip_reaction;
    reaction_sources = previous_reaction_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    reaction.f ^= EFFECT_IS_UPDATING;
  }
}
__name(update_reaction, "update_reaction");
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index10 = index_of.call(reactions, signal);
    if (index10 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index10] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
__name(remove_reaction, "remove_reaction");
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
__name(remove_reactions, "remove_reactions");
function update_effect(effect2) {
  var flags = effect2.f;
  if ((flags & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  try {
    if ((flags & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    var deps = effect2.deps;
    var dep;
    if (DEV && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && deps !== null) ;
    if (DEV) ;
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
  }
}
__name(update_effect, "update_effect");
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error3) {
    if (last_scheduled_effect !== null) {
      {
        invoke_error_boundary(error3, last_scheduled_effect);
      }
    } else {
      throw error3;
    }
  }
}
__name(infinite_loop_guard, "infinite_loop_guard");
function flush_queued_root_effects() {
  var was_updating_effect = is_updating_effect;
  try {
    var flush_count = 0;
    is_updating_effect = true;
    while (queued_root_effects.length > 0) {
      if (flush_count++ > 1e3) {
        infinite_loop_guard();
      }
      var root_effects = queued_root_effects;
      var length = root_effects.length;
      queued_root_effects = [];
      for (var i = 0; i < length; i++) {
        var collected_effects = process_effects(root_effects[i]);
        flush_queued_effects(collected_effects);
      }
      old_values.clear();
    }
  } finally {
    is_flushing = false;
    is_updating_effect = was_updating_effect;
    last_scheduled_effect = null;
  }
}
__name(flush_queued_root_effects, "flush_queued_root_effects");
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  for (var i = 0; i < length; i++) {
    var effect2 = effects[i];
    if ((effect2.f & (DESTROYED | INERT)) === 0) {
      if (check_dirtiness(effect2)) {
        update_effect(effect2);
        if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
          if (effect2.teardown === null) {
            unlink_effect(effect2);
          } else {
            effect2.fn = null;
          }
        }
      }
    }
  }
}
__name(flush_queued_effects, "flush_queued_effects");
function schedule_effect(signal) {
  if (!is_flushing) {
    is_flushing = true;
    queueMicrotask(flush_queued_root_effects);
  }
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags = effect2.f;
    if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
__name(schedule_effect, "schedule_effect");
function process_effects(root2) {
  var effects = [];
  var effect2 = root2;
  while (effect2 !== null) {
    var flags = effect2.f;
    var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
    var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
    if (!is_skippable_branch && (flags & INERT) === 0) {
      if ((flags & EFFECT) !== 0) {
        effects.push(effect2);
      } else if (is_branch) {
        effect2.f ^= CLEAN;
      } else {
        if (check_dirtiness(effect2)) {
          update_effect(effect2);
        }
      }
      var child = effect2.first;
      if (child !== null) {
        effect2 = child;
        continue;
      }
    }
    var parent = effect2.parent;
    effect2 = effect2.next;
    while (effect2 === null && parent !== null) {
      effect2 = parent.next;
      parent = parent.parent;
    }
  }
  return effects;
}
__name(process_effects, "process_effects");
function flushSync(fn) {
  var result;
  while (true) {
    flush_tasks();
    if (queued_root_effects.length === 0) {
      is_flushing = false;
      last_scheduled_effect = null;
      return (
        /** @type {T} */
        result
      );
    }
    is_flushing = true;
    flush_queued_root_effects();
  }
}
__name(flushSync, "flushSync");
function get(signal) {
  var flags = signal.f;
  var is_derived = (flags & DERIVED) !== 0;
  if (active_reaction !== null && !untracking) {
    if (!reaction_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if (signal.rv < read_version) {
        signal.rv = read_version;
        if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
          skipped_deps++;
        } else if (new_deps === null) {
          new_deps = [signal];
        } else if (!skip_reaction || !new_deps.includes(signal)) {
          new_deps.push(signal);
        }
      }
    }
  } else if (is_derived && /** @type {Derived} */
  signal.deps === null && /** @type {Derived} */
  signal.effects === null) {
    var derived = (
      /** @type {Derived} */
      signal
    );
    var parent = derived.parent;
    if (parent !== null && (parent.f & UNOWNED) === 0) {
      derived.f ^= UNOWNED;
    }
  }
  if (is_derived) {
    derived = /** @type {Derived} */
    signal;
    if (check_dirtiness(derived)) {
      update_derived(derived);
    }
  }
  if (is_destroying_effect && old_values.has(signal)) {
    return old_values.get(signal);
  }
  return signal.v;
}
__name(get, "get");
var STATUS_MASK = -7169;
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
__name(set_signal_status, "set_signal_status");
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
__name(is_passive_event, "is_passive_event");
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function handle_event_propagation(event) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event.type;
  var path2 = event.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path2[0] || event.target
  );
  var path_idx = 0;
  var handled_at = event.__root;
  if (handled_at) {
    var at_idx = path2.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event.__root = handler_element;
      return;
    }
    var handler_idx = path2.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path2[path_idx] || event.target;
  if (current_target === handler_element) return;
  define_property(event, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event.target === current_target)) {
          if (is_array(delegated)) {
            var [fn, ...data] = delegated;
            fn.apply(current_target, [event, ...data]);
          } else {
            delegated.call(current_target, event);
          }
        }
      } catch (error3) {
        if (throw_error) {
          other_errors.push(error3);
        } else {
          throw_error = error3;
        }
      }
      if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error3 of other_errors) {
        queueMicrotask(() => {
          throw error3;
        });
      }
      throw throw_error;
    }
  } finally {
    event.__root = handler_element;
    delete event.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(handle_event_propagation, "handle_event_propagation");
function assign_nodes(start, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes_start === null) {
    effect2.nodes_start = start;
    effect2.nodes_end = end;
  }
}
__name(assign_nodes, "assign_nodes");
function mount(component10, options2) {
  return _mount(component10, options2);
}
__name(mount, "mount");
function hydrate(component10, options2) {
  init_operations2();
  options2.intro = options2.intro ?? false;
  const target = options2.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== 8 || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    hydrate_next();
    const instance = _mount(component10, { ...options2, anchor });
    if (hydrate_node === null || hydrate_node.nodeType !== 8 || /** @type {Comment} */
    hydrate_node.data !== HYDRATION_END) {
      hydration_mismatch();
      throw HYDRATION_ERROR;
    }
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error3) {
    if (error3 === HYDRATION_ERROR) {
      if (options2.recover === false) {
        hydration_failed();
      }
      init_operations2();
      clear_text_content(target);
      set_hydrating(false);
      return mount(component10, options2);
    }
    throw error3;
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
__name(hydrate, "hydrate");
var document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events: events3, context: context3, intro = true }) {
  init_operations2();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = /* @__PURE__ */ __name((events22) => {
    for (var i = 0; i < events22.length; i++) {
      var event_name = events22[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive });
      var n2 = document_listeners.get(event_name);
      if (n2 === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n2 + 1);
      }
    }
  }, "event_handle");
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component10 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    branch(() => {
      if (context3) {
        push2({});
        var ctx = (
          /** @type {ComponentContext} */
          component_context
        );
        ctx.c = context3;
      }
      if (events3) {
        props.$$events = events3;
      }
      if (hydrating) {
        assign_nodes(
          /** @type {TemplateNode} */
          anchor_node,
          null
        );
      }
      component10 = Component(anchor_node, props) || {};
      if (hydrating) {
        active_effect.nodes_end = hydrate_node;
      }
      if (context3) {
        pop2();
      }
    });
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n2 = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n2 === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n2);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component10, unmount2);
  return component10;
}
__name(_mount, "_mount");
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component10, options2) {
  const fn = mounted_components.get(component10);
  if (fn) {
    mounted_components.delete(component10);
    return fn(options2);
  }
  return Promise.resolve();
}
__name(unmount, "unmount");
function asClassComponent$1(component10) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options2) {
      super({
        component: component10,
        ...options2
      });
    }
  };
}
__name(asClassComponent$1, "asClassComponent$1");
var Svelte4Component = class {
  static {
    __name(this, "Svelte4Component");
  }
  /** @type {any} */
  #events;
  /** @type {Record<string, any>} */
  #instance;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options2) {
    var sources = /* @__PURE__ */ new Map();
    var add_source = /* @__PURE__ */ __name((key2, value) => {
      var s3 = /* @__PURE__ */ mutable_source(value);
      sources.set(key2, s3);
      return s3;
    }, "add_source");
    const props = new Proxy(
      { ...options2.props || {}, $$events: {} },
      {
        get(target, prop) {
          return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
        },
        has(target, prop) {
          if (prop === LEGACY_PROPS) return true;
          get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
          return Reflect.has(target, prop);
        },
        set(target, prop, value) {
          set(sources.get(prop) ?? add_source(prop, value), value);
          return Reflect.set(target, prop, value);
        }
      }
    );
    this.#instance = (options2.hydrate ? hydrate : mount)(options2.component, {
      target: options2.target,
      anchor: options2.anchor,
      props,
      context: options2.context,
      intro: options2.intro ?? false,
      recover: options2.recover
    });
    if (!options2?.props?.$$host || options2.sync === false) {
      flushSync();
    }
    this.#events = props.$$events;
    for (const key2 of Object.keys(this.#instance)) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
      define_property(this, key2, {
        get() {
          return this.#instance[key2];
        },
        /** @param {any} value */
        set(value) {
          this.#instance[key2] = value;
        },
        enumerable: true
      });
    }
    this.#instance.$set = /** @param {Record<string, any>} next */
    (next) => {
      Object.assign(props, next);
    };
    this.#instance.$destroy = () => {
      unmount(this.#instance);
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    this.#instance.$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event, callback) {
    this.#events[event] = this.#events[event] || [];
    const cb = /* @__PURE__ */ __name((...args) => callback.call(this, ...args), "cb");
    this.#events[event].push(cb);
    return () => {
      this.#events[event] = this.#events[event].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    this.#instance.$destroy();
  }
};
var read_implementation = null;
function set_read_implementation(fn) {
  read_implementation = fn;
}
__name(set_read_implementation, "set_read_implementation");
function asClassComponent(component10) {
  const component_constructor = asClassComponent$1(component10);
  const _render = /* @__PURE__ */ __name((props, { context: context3 } = {}) => {
    const result = render(component10, { props, context: context3 });
    return {
      css: { code: "", map: null },
      head: result.head,
      html: result.body
    };
  }, "_render");
  component_constructor.render = _render;
  return component_constructor;
}
__name(asClassComponent, "asClassComponent");
var prerendering = false;
function Root($$payload, $$props) {
  push();
  let {
    stores: stores3,
    page: page2,
    constructors,
    components = [],
    form,
    data_0 = null,
    data_1 = null
  } = $$props;
  {
    setContext("__svelte__", stores3);
  }
  {
    stores3.page.set(page2);
  }
  const Pyramid_1 = constructors[1];
  if (constructors[1]) {
    $$payload.out += "<!--[-->";
    const Pyramid_0 = constructors[0];
    $$payload.out += `<!---->`;
    Pyramid_0($$payload, {
      data: data_0,
      form,
      children: /* @__PURE__ */ __name(($$payload2) => {
        $$payload2.out += `<!---->`;
        Pyramid_1($$payload2, { data: data_1, form });
        $$payload2.out += `<!---->`;
      }, "children"),
      $$slots: { default: true }
    });
    $$payload.out += `<!---->`;
  } else {
    $$payload.out += "<!--[!-->";
    const Pyramid_0 = constructors[0];
    $$payload.out += `<!---->`;
    Pyramid_0($$payload, { data: data_0, form });
    $$payload.out += `<!---->`;
  }
  $$payload.out += `<!--]--> `;
  {
    $$payload.out += "<!--[!-->";
  }
  $$payload.out += `<!--]-->`;
  pop();
}
__name(Root, "Root");
var root = asClassComponent(Root);
var options = {
  app_template_contains_nonce: false,
  csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, "reportOnly": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
  csrf_check_origin: true,
  embedded: false,
  env_public_prefix: "PUBLIC_",
  env_private_prefix: "",
  hash_routing: false,
  hooks: null,
  // added lazily, via `get_hooks`
  preload_strategy: "modulepreload",
  root,
  service_worker: false,
  templates: {
    app: /* @__PURE__ */ __name(({ head, body: body2, assets: assets2, nonce, env: env2 }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="' + assets2 + '/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body data-sveltekit-preload-data="hover">\n		<div style="display: contents">' + body2 + "</div>\n	</body>\n</html>\n", "app"),
    error: /* @__PURE__ */ __name(({ status, message }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n", "error")
  },
  version_hash: "1t1fr01"
};
async function get_hooks() {
  let handle2;
  let handleFetch;
  let handleError;
  let init2;
  ({ handle: handle2, handleFetch, handleError, init: init2 } = await Promise.resolve().then(() => (init_hooks_server(), hooks_server_exports)));
  let reroute;
  let transport;
  return {
    handle: handle2,
    handleFetch,
    handleError,
    init: init2,
    reroute,
    transport
  };
}
__name(get_hooks, "get_hooks");

// .svelte-kit/output/server/index.js
init_chunks();
init_exports();
var import_cookie2 = __toESM(require_dist(), 1);
var set_cookie_parser = __toESM(require_set_cookie(), 1);
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var PAGE_METHODS = ["GET", "POST", "HEAD"];
function negotiate(accept, types4) {
  const parts = [];
  accept.split(",").forEach((str, i) => {
    const match = /([^/ \t]+)\/([^; \t]+)[ \t]*(?:;[ \t]*q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q = "1"] = match;
      parts.push({ type, subtype, q: +q, i });
    }
  });
  parts.sort((a, b2) => {
    if (a.q !== b2.q) {
      return b2.q - a.q;
    }
    if (a.subtype === "*" !== (b2.subtype === "*")) {
      return a.subtype === "*" ? 1 : -1;
    }
    if (a.type === "*" !== (b2.type === "*")) {
      return a.type === "*" ? 1 : -1;
    }
    return a.i - b2.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types4) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
__name(negotiate, "negotiate");
function is_content_type(request, ...types4) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types4.includes(type.toLowerCase());
}
__name(is_content_type, "is_content_type");
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
__name(is_form_content_type, "is_form_content_type");
var request_event = null;
var als;
Promise.resolve().then(() => (init_async_hooks2(), async_hooks_exports)).then((hooks) => als = new hooks.AsyncLocalStorage()).catch(() => {
});
function with_event(event, fn) {
  try {
    request_event = event;
    return als ? als.run(event, fn) : fn();
  } finally {
    request_event = null;
  }
}
__name(with_event, "with_event");
var DATA_SUFFIX = "/__data.json";
var HTML_DATA_SUFFIX = ".html__data.json";
function has_data_suffix(pathname) {
  return pathname.endsWith(DATA_SUFFIX) || pathname.endsWith(HTML_DATA_SUFFIX);
}
__name(has_data_suffix, "has_data_suffix");
function add_data_suffix(pathname) {
  if (pathname.endsWith(".html")) return pathname.replace(/\.html$/, HTML_DATA_SUFFIX);
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
__name(add_data_suffix, "add_data_suffix");
function strip_data_suffix(pathname) {
  if (pathname.endsWith(HTML_DATA_SUFFIX)) {
    return pathname.slice(0, -HTML_DATA_SUFFIX.length) + ".html";
  }
  return pathname.slice(0, -DATA_SUFFIX.length);
}
__name(strip_data_suffix, "strip_data_suffix");
var ROUTE_SUFFIX = "/__route.js";
function has_resolution_suffix(pathname) {
  return pathname.endsWith(ROUTE_SUFFIX);
}
__name(has_resolution_suffix, "has_resolution_suffix");
function add_resolution_suffix(pathname) {
  return pathname.replace(/\/$/, "") + ROUTE_SUFFIX;
}
__name(add_resolution_suffix, "add_resolution_suffix");
function strip_resolution_suffix(pathname) {
  return pathname.slice(0, -ROUTE_SUFFIX.length);
}
__name(strip_resolution_suffix, "strip_resolution_suffix");
function coalesce_to_error(err2) {
  return err2 instanceof Error || err2 && /** @type {any} */
  err2.name && /** @type {any} */
  err2.message ? (
    /** @type {Error} */
    err2
  ) : new Error(JSON.stringify(err2));
}
__name(coalesce_to_error, "coalesce_to_error");
function normalize_error(error3) {
  return (
    /** @type {import('../runtime/control.js').Redirect | HttpError | SvelteKitError | Error} */
    error3
  );
}
__name(normalize_error, "normalize_error");
function get_status(error3) {
  return error3 instanceof HttpError || error3 instanceof SvelteKitError ? error3.status : 500;
}
__name(get_status, "get_status");
function get_message(error3) {
  return error3 instanceof SvelteKitError ? error3.text : "Internal Error";
}
__name(get_message, "get_message");
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
  // Svelte also escapes < because the escape function could be called inside a `noscript` there
  // https://github.com/sveltejs/svelte/security/advisories/GHSA-8266-84wp-wv5c
  // However, that doesn't apply in SvelteKit
};
var escape_html_dict = {
  "&": "&amp;",
  "<": "&lt;"
};
var surrogates = (
  // high surrogate without paired low surrogate
  "[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]"
);
var escape_html_attr_regex = new RegExp(
  `[${Object.keys(escape_html_attr_dict).join("")}]|` + surrogates,
  "g"
);
var escape_html_regex = new RegExp(
  `[${Object.keys(escape_html_dict).join("")}]|` + surrogates,
  "g"
);
function escape_html2(str, is_attr) {
  const dict = is_attr ? escape_html_attr_dict : escape_html_dict;
  const escaped_str = str.replace(is_attr ? escape_html_attr_regex : escape_html_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return escaped_str;
}
__name(escape_html2, "escape_html");
function method_not_allowed(mod, method) {
  return text2(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
__name(method_not_allowed, "method_not_allowed");
function allowed_methods(mod) {
  const allowed = ENDPOINT_METHODS.filter((method) => method in mod);
  if ("GET" in mod || "HEAD" in mod) allowed.push("HEAD");
  return allowed;
}
__name(allowed_methods, "allowed_methods");
function static_error_page(options2, status, message) {
  let page2 = options2.templates.error({ status, message: escape_html2(message) });
  return text2(page2, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
__name(static_error_page, "static_error_page");
async function handle_fatal_error(event, options2, error3) {
  error3 = error3 instanceof HttpError ? error3 : coalesce_to_error(error3);
  const status = get_status(error3);
  const body2 = await handle_error_and_jsonify(event, options2, error3);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json2(body2, {
      status
    });
  }
  return static_error_page(options2, status, body2.message);
}
__name(handle_fatal_error, "handle_fatal_error");
async function handle_error_and_jsonify(event, options2, error3) {
  if (error3 instanceof HttpError) {
    return error3.body;
  }
  const status = get_status(error3);
  const message = get_message(error3);
  return await with_event(
    event,
    () => options2.hooks.handleError({ error: error3, event, status, message })
  ) ?? { message };
}
__name(handle_error_and_jsonify, "handle_error_and_jsonify");
function redirect_response(status, location2) {
  const response = new Response(void 0, {
    status,
    headers: { location: location2 }
  });
  return response;
}
__name(redirect_response, "redirect_response");
function clarify_devalue_error(event, error3) {
  if (error3.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error3.message} (${error3.path})`;
  }
  if (error3.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error3.message;
}
__name(clarify_devalue_error, "clarify_devalue_error");
function serialize_uses(node) {
  const uses = {};
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.dependencies = Array.from(node.uses.dependencies);
  }
  if (node.uses && node.uses.search_params.size > 0) {
    uses.search_params = Array.from(node.uses.search_params);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.params = Array.from(node.uses.params);
  }
  if (node.uses?.parent) uses.parent = 1;
  if (node.uses?.route) uses.route = 1;
  if (node.uses?.url) uses.url = 1;
  return uses;
}
__name(serialize_uses, "serialize_uses");
function has_prerendered_path(manifest2, pathname) {
  return manifest2._.prerendered_routes.has(pathname) || pathname.at(-1) === "/" && manifest2._.prerendered_routes.has(pathname.slice(0, -1));
}
__name(has_prerendered_path, "has_prerendered_path");
async function render_endpoint(event, mod, state2) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && !mod.HEAD && mod.GET) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state2.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state2.prerendering && !state2.prerendering.inside_reroute && !prerender) {
    if (state2.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  try {
    const response = await with_event(
      event,
      () => handler(
        /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
        event
      )
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state2.prerendering && (!state2.prerendering.inside_reroute || prerender)) {
      const cloned = new Response(response.clone().body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      cloned.headers.set("x-sveltekit-prerender", String(prerender));
      if (state2.prerendering.inside_reroute && prerender) {
        cloned.headers.set(
          "x-sveltekit-routeid",
          encodeURI(
            /** @type {string} */
            event.route.id
          )
        );
        state2.prerendering.dependencies.set(event.url.pathname, { response: cloned, body: null });
      } else {
        return cloned;
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return new Response(void 0, {
        status: e3.status,
        headers: { location: e3.location }
      });
    }
    throw e3;
  }
}
__name(render_endpoint, "render_endpoint");
function is_endpoint_request(event) {
  const { method, headers: headers2 } = event.request;
  if (ENDPOINT_METHODS.includes(method) && !PAGE_METHODS.includes(method)) {
    return true;
  }
  if (method === "POST" && headers2.get("x-sveltekit-action") === "true") return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
__name(is_endpoint_request, "is_endpoint_request");
function compact(arr2) {
  return arr2.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
__name(compact, "compact");
var escaped = {
  "<": "\\u003C",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var DevalueError = class extends Error {
  static {
    __name(this, "DevalueError");
  }
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys) {
    super(message);
    this.name = "DevalueError";
    this.path = keys.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
__name(is_primitive, "is_primitive");
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
__name(is_plain_object, "is_plain_object");
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
__name(get_type, "get_type");
function get_escaped_char(char2) {
  switch (char2) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char2 < " " ? `\\u${char2.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
__name(get_escaped_char, "get_escaped_char");
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i = 0; i < len; i += 1) {
    const char2 = str[i];
    const replacement = get_escaped_char(char2);
    if (replacement) {
      result += str.slice(last_pos, i) + replacement;
      last_pos = i + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
__name(stringify_string, "stringify_string");
function enumerable_symbols(object2) {
  return Object.getOwnPropertySymbols(object2).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object2, symbol).enumerable
  );
}
__name(enumerable_symbols, "enumerable_symbols");
var is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key2) {
  return is_identifier.test(key2) ? "." + key2 : "[" + JSON.stringify(key2) + "]";
}
__name(stringify_key, "stringify_key");
var chars$1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing);
        if (typeof str2 === "string") {
          custom.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach((value2, i) => {
            keys.push(`[${i}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive$1(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          return;
        case "ArrayBuffer":
          return;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(stringify_key(key2));
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  __name(walk, "walk");
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a, b2) => b2[1] - a[1]).forEach((entry, i) => {
    names.set(entry[0], get_name(i));
  });
  function stringify22(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive$1(thing);
    }
    if (custom.has(thing)) {
      return custom.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify22(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v, i) => i in thing ? stringify22(v) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify22).join(",")}])`;
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array": {
        const typedArray = thing;
        return `new ${type}([${typedArray.toString()}])`;
      }
      case "ArrayBuffer": {
        const ui8 = new Uint8Array(thing);
        return `new Uint8Array([${ui8.toString()}]).buffer`;
      }
      default:
        const obj = `{${Object.keys(thing).map((key2) => `${safe_key(key2)}:${stringify22(thing[key2])}`).join(",")}}`;
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? `Object.assign(Object.create(null),${obj})` : `Object.create(null)`;
        }
        return obj;
    }
  }
  __name(stringify22, "stringify2");
  const str = stringify22(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values2 = [];
    names.forEach((name, thing) => {
      params.push(name);
      if (custom.has(thing)) {
        values2.push(
          /** @type {string} */
          custom.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values2.push(stringify_primitive$1(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values2.push(`Object(${stringify22(thing.valueOf())})`);
          break;
        case "RegExp":
          values2.push(thing.toString());
          break;
        case "Date":
          values2.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values2.push(`Array(${thing.length})`);
          thing.forEach((v, i) => {
            statements.push(`${name}[${i}]=${stringify22(v)}`);
          });
          break;
        case "Set":
          values2.push(`new Set`);
          statements.push(
            `${name}.${Array.from(thing).map((v) => `add(${stringify22(v)})`).join(".")}`
          );
          break;
        case "Map":
          values2.push(`new Map`);
          statements.push(
            `${name}.${Array.from(thing).map(([k, v]) => `set(${stringify22(k)}, ${stringify22(v)})`).join(".")}`
          );
          break;
        default:
          values2.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name}${safe_prop(key2)}=${stringify22(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values2.join(",")}))`;
  } else {
    return str;
  }
}
__name(uneval, "uneval");
function get_name(num) {
  let name = "";
  do {
    name = chars$1[num % chars$1.length] + name;
    num = ~~(num / chars$1.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
__name(get_name, "get_name");
function escape_unsafe_char(c2) {
  return escaped[c2] || c2;
}
__name(escape_unsafe_char, "escape_unsafe_char");
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
__name(escape_unsafe_chars, "escape_unsafe_chars");
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
__name(safe_key, "safe_key");
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
__name(safe_prop, "safe_prop");
function stringify_primitive$1(thing) {
  if (typeof thing === "string") return stringify_string(thing);
  if (thing === void 0) return "void 0";
  if (thing === 0 && 1 / thing < 0) return "-0";
  const str = String(thing);
  if (typeof thing === "number") return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint") return thing + "n";
  return str;
}
__name(stringify_primitive$1, "stringify_primitive$1");
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    binaryString += String.fromCharCode(dv.getUint8(i));
  }
  return binaryToAscii(binaryString);
}
__name(encode64, "encode64");
var KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function binaryToAscii(str) {
  let out = "";
  for (let i = 0; i < str.length; i += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i) & 3) << 4;
    if (str.length > i + 1) {
      groupsOfSix[1] |= str.charCodeAt(i + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i + 1) & 15) << 2;
    }
    if (str.length > i + 2) {
      groupsOfSix[2] |= str.charCodeAt(i + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i + 2) & 63;
    }
    for (let j = 0; j < groupsOfSix.length; j++) {
      if (typeof groupsOfSix[j] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j]];
      }
    }
  }
  return out;
}
__name(binaryToAscii, "binaryToAscii");
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;
function stringify2(value, reducers) {
  const stringified2 = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom = [];
  if (reducers) {
    for (const key2 of Object.getOwnPropertyNames(reducers)) {
      custom.push({ key: key2, fn: reducers[key2] });
    }
  }
  const keys = [];
  let p = 0;
  function flatten2(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (indexes.has(thing)) return indexes.get(thing);
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    const index22 = p++;
    indexes.set(thing, index22);
    for (const { key: key2, fn } of custom) {
      const value2 = fn(thing);
      if (value2) {
        stringified2[index22] = `["${key2}",${flatten2(value2)}]`;
        return index22;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "RegExp":
          const { source: source2, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source2)},"${flags}"]` : `["RegExp",${stringify_string(source2)}]`;
          break;
        case "Array":
          str = "[";
          for (let i = 0; i < thing.length; i += 1) {
            if (i > 0) str += ",";
            if (i in thing) {
              keys.push(`[${i}]`);
              str += flatten2(thing[i]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten2(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            str += `,${flatten2(key2)},${flatten2(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          const base642 = encode64(typedArray.buffer);
          str = '["' + type + '","' + base642 + '"]';
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base642 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base642}"]`;
          break;
        }
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key2 in thing) {
              keys.push(stringify_key(key2));
              str += `,${stringify_string(key2)},${flatten2(thing[key2])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key2 in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key2));
              str += `${stringify_string(key2)}:${flatten2(thing[key2])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified2[index22] = str;
    return index22;
  }
  __name(flatten2, "flatten");
  const index10 = flatten2(value);
  if (index10 < 0) return `${index10}`;
  return `[${stringified2.join(",")}]`;
}
__name(stringify2, "stringify");
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}
__name(stringify_primitive, "stringify_primitive");
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
__name(is_action_json_request, "is_action_json_request");
async function handle_action_json_request(event, options2, server2) {
  const actions3 = server2?.actions;
  if (!actions3) {
    const no_actions_error = new SvelteKitError(
      405,
      "Method Not Allowed",
      `POST method not allowed. No form actions exist for ${"this page"}`
    );
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions3);
  try {
    const data = await call_action(event, actions3);
    if (false) ;
    if (data instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data.data,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        )
      });
    }
  } catch (e3) {
    const err2 = normalize_error(e3);
    if (err2 instanceof Redirect) {
      return action_json_redirect(err2);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, check_incorrect_fail_use(err2))
      },
      {
        status: get_status(err2)
      }
    );
  }
}
__name(handle_action_json_request, "handle_action_json_request");
function check_incorrect_fail_use(error3) {
  return error3 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error3;
}
__name(check_incorrect_fail_use, "check_incorrect_fail_use");
function action_json_redirect(redirect2) {
  return action_json({
    type: "redirect",
    status: redirect2.status,
    location: redirect2.location
  });
}
__name(action_json_redirect, "action_json_redirect");
function action_json(data, init2) {
  return json2(data, init2);
}
__name(action_json, "action_json");
function is_action_request(event) {
  return event.request.method === "POST";
}
__name(is_action_request, "is_action_request");
async function handle_action_request(event, server2) {
  const actions3 = server2?.actions;
  if (!actions3) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        `POST method not allowed. No form actions exist for ${"this page"}`
      )
    };
  }
  check_named_default_separate(actions3);
  try {
    const data = await call_action(event, actions3);
    if (false) ;
    if (data instanceof ActionFailure) {
      return {
        type: "failure",
        status: data.status,
        data: data.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data
      };
    }
  } catch (e3) {
    const err2 = normalize_error(e3);
    if (err2 instanceof Redirect) {
      return {
        type: "redirect",
        status: err2.status,
        location: err2.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err2)
    };
  }
}
__name(handle_action_request, "handle_action_request");
function check_named_default_separate(actions3) {
  if (actions3.default && Object.keys(actions3).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://svelte.dev/docs/kit/form-actions#named-actions"
    );
  }
}
__name(check_named_default_separate, "check_named_default_separate");
async function call_action(event, actions3) {
  const url = new URL(event.request.url);
  let name = "default";
  for (const param of url.searchParams) {
    if (param[0].startsWith("/")) {
      name = param[0].slice(1);
      if (name === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions3[name];
  if (!action) {
    throw new SvelteKitError(404, "Not Found", `No action with name '${name}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new SvelteKitError(
      415,
      "Unsupported Media Type",
      `Form actions expect form-encoded data \u2014 received ${event.request.headers.get(
        "content-type"
      )}`
    );
  }
  return with_event(event, () => action(event));
}
__name(call_action, "call_action");
function uneval_action_response(data, route_id, transport) {
  const replacer = /* @__PURE__ */ __name((thing) => {
    for (const key2 in transport) {
      const encoded = transport[key2].encode(thing);
      if (encoded) {
        return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
      }
    }
  }, "replacer");
  return try_serialize(data, (value) => uneval(value, replacer), route_id);
}
__name(uneval_action_response, "uneval_action_response");
function stringify_action_response(data, route_id, transport) {
  const encoders = Object.fromEntries(
    Object.entries(transport).map(([key2, value]) => [key2, value.encode])
  );
  return try_serialize(data, (value) => stringify2(value, encoders), route_id);
}
__name(stringify_action_response, "stringify_action_response");
function try_serialize(data, fn, route_id) {
  try {
    return fn(data);
  } catch (e3) {
    const error3 = (
      /** @type {any} */
      e3
    );
    if (data instanceof Response) {
      throw new Error(
        `Data returned from action inside ${route_id} is not serializable. Form actions need to return plain objects or fail(). E.g. return { success: true } or return fail(400, { message: "invalid" });`
      );
    }
    if ("path" in error3) {
      let message = `Data returned from action inside ${route_id} is not serializable: ${error3.message}`;
      if (error3.path !== "") message += ` (data.${error3.path})`;
      throw new Error(message);
    }
    throw error3;
  }
}
__name(try_serialize, "try_serialize");
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
function b64_encode(buffer2) {
  if (globalThis.Buffer) {
    return Buffer.from(buffer2).toString("base64");
  }
  const little_endian = new Uint8Array(new Uint16Array([1]).buffer)[0] > 0;
  return btoa(
    new TextDecoder(little_endian ? "utf-16le" : "utf-16be").decode(
      new Uint16Array(new Uint8Array(buffer2))
    )
  );
}
__name(b64_encode, "b64_encode");
function get_relative_path(from, to) {
  const from_parts = from.split(/[/\\]/);
  const to_parts = to.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  let i = from_parts.length;
  while (i--) from_parts[i] = "..";
  return from_parts.concat(to_parts).join("/");
}
__name(get_relative_path, "get_relative_path");
async function load_server_data({ event, state: state2, node, parent }) {
  if (!node?.server) return null;
  let is_tracking = true;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false,
    search_params: /* @__PURE__ */ new Set()
  };
  const load7 = node.server.load;
  const slash = node.server.trailingSlash;
  if (!load7) {
    return { type: "data", data: null, uses, slash };
  }
  const url = make_trackable(
    event.url,
    () => {
      if (is_tracking) {
        uses.url = true;
      }
    },
    (param) => {
      if (is_tracking) {
        uses.search_params.add(param);
      }
    }
  );
  if (state2.prerendering) {
    disable_search(url);
  }
  let done = false;
  const result = await with_event(
    event,
    () => load7.call(null, {
      ...event,
      fetch: /* @__PURE__ */ __name((info3, init2) => {
        const url2 = new URL(info3 instanceof Request ? info3.url : info3, event.url);
        if (DEV && done && !uses.dependencies.has(url2.href)) ;
        return event.fetch(info3, init2);
      }, "fetch"),
      /** @param {string[]} deps */
      depends: /* @__PURE__ */ __name((...deps) => {
        for (const dep of deps) {
          const { href } = new URL(dep, event.url);
          if (DEV) ;
          uses.dependencies.add(href);
        }
      }, "depends"),
      params: new Proxy(event.params, {
        get: /* @__PURE__ */ __name((target, key2) => {
          if (DEV && done && typeof key2 === "string" && !uses.params.has(key2)) ;
          if (is_tracking) {
            uses.params.add(key2);
          }
          return target[
            /** @type {string} */
            key2
          ];
        }, "get")
      }),
      parent: /* @__PURE__ */ __name(async () => {
        if (DEV && done && !uses.parent) ;
        if (is_tracking) {
          uses.parent = true;
        }
        return parent();
      }, "parent"),
      route: new Proxy(event.route, {
        get: /* @__PURE__ */ __name((target, key2) => {
          if (DEV && done && typeof key2 === "string" && !uses.route) ;
          if (is_tracking) {
            uses.route = true;
          }
          return target[
            /** @type {'id'} */
            key2
          ];
        }, "get")
      }),
      url,
      untrack(fn) {
        is_tracking = false;
        try {
          return fn();
        } finally {
          is_tracking = true;
        }
      }
    })
  );
  done = true;
  return {
    type: "data",
    data: result ?? null,
    uses,
    slash
  };
}
__name(load_server_data, "load_server_data");
async function load_data({
  event,
  fetched,
  node,
  parent,
  server_data_promise,
  state: state2,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  if (!node?.universal?.load) {
    return server_data_node?.data ?? null;
  }
  const result = await node.universal.load.call(null, {
    url: event.url,
    params: event.params,
    data: server_data_node?.data ?? null,
    route: event.route,
    fetch: create_universal_fetch(event, state2, fetched, csr, resolve_opts),
    setHeaders: event.setHeaders,
    depends: /* @__PURE__ */ __name(() => {
    }, "depends"),
    parent,
    untrack: /* @__PURE__ */ __name((fn) => fn(), "untrack")
  });
  return result ?? null;
}
__name(load_data, "load_data");
function create_universal_fetch(event, state2, fetched, csr, resolve_opts) {
  const universal_fetch = /* @__PURE__ */ __name(async (input, init2) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init2?.headers;
    let response = await event.fetch(input, init2);
    const url = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state2.prerendering) {
        dependency = { response, body: null };
        state2.prerendering.dependencies.set(url.pathname, dependency);
      }
    } else if (url.protocol === "https:" || url.protocol === "http:") {
      const mode = input instanceof Request ? input.mode : init2?.mode ?? "cors";
      if (mode === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    const proxy2 = new Proxy(response, {
      get(response2, key2, _receiver) {
        async function push_fetched(body2, is_b64) {
          const status_number = Number(response2.status);
          if (isNaN(status_number)) {
            throw new Error(
              `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
            );
          }
          fetched.push({
            url: same_origin ? url.href.slice(event.url.origin.length) : url.href,
            method: event.request.method,
            request_body: (
              /** @type {string | ArrayBufferView | undefined} */
              input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init2?.body
            ),
            request_headers: cloned_headers,
            response_body: body2,
            response: response2,
            is_b64
          });
        }
        __name(push_fetched, "push_fetched");
        if (key2 === "arrayBuffer") {
          return async () => {
            const buffer2 = await response2.arrayBuffer();
            if (dependency) {
              dependency.body = new Uint8Array(buffer2);
            }
            if (buffer2 instanceof ArrayBuffer) {
              await push_fetched(b64_encode(buffer2), true);
            }
            return buffer2;
          };
        }
        async function text22() {
          const body2 = await response2.text();
          if (!body2 || typeof body2 === "string") {
            await push_fetched(body2, false);
          }
          if (dependency) {
            dependency.body = body2;
          }
          return body2;
        }
        __name(text22, "text2");
        if (key2 === "text") {
          return text22;
        }
        if (key2 === "json") {
          return async () => {
            return JSON.parse(await text22());
          };
        }
        return Reflect.get(response2, key2, response2);
      }
    });
    if (csr) {
      const get3 = response.headers.get;
      response.headers.get = (key2) => {
        const lower = key2.toLowerCase();
        const value = get3.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://svelte.dev/docs/kit/hooks#Server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy2;
  }, "universal_fetch");
  return (input, init2) => {
    const response = universal_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
__name(create_universal_fetch, "create_universal_fetch");
async function stream_to_string(stream) {
  let result = "";
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += decoder.decode(value);
  }
  return result;
}
__name(stream_to_string, "stream_to_string");
function hash2(...values2) {
  let hash22 = 5381;
  for (const value of values2) {
    if (typeof value === "string") {
      let i = value.length;
      while (i) hash22 = hash22 * 33 ^ value.charCodeAt(--i);
    } else if (ArrayBuffer.isView(value)) {
      const buffer2 = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i = buffer2.length;
      while (i) hash22 = hash22 * 33 ^ buffer2[--i];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash22 >>> 0).toString(36);
}
__name(hash2, "hash");
var replacements2 = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements2).join("")}]`, "g");
function serialize_data(fetched, filter, prerendering2 = false) {
  const headers2 = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key2, value] of fetched.response.headers) {
    if (filter(key2, value)) {
      headers2[key2] = value;
    }
    if (key2 === "cache-control") cache_control = value;
    else if (key2 === "age") age = value;
    else if (key2 === "vary" && value.trim() === "*") varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers: headers2,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements2[match]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url="${escape_html2(fetched.url, true)}"`
  ];
  if (fetched.is_b64) {
    attrs.push("data-b64");
  }
  if (fetched.request_headers || fetched.request_body) {
    const values2 = [];
    if (fetched.request_headers) {
      values2.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values2.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash2(...values2)}"`);
  }
  if (!prerendering2 && fetched.method === "GET" && cache_control && !varyAny) {
    const match = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match) {
      const ttl = +match[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
__name(serialize_data, "serialize_data");
var s = JSON.stringify;
var encoder$2 = new TextEncoder();
function sha2562(data) {
  if (!key[0]) precompute();
  const out = init.slice(0);
  const array22 = encode(data);
  for (let i = 0; i < array22.length; i += 16) {
    const w = array22.subarray(i, i + 16);
    let tmp;
    let a;
    let b2;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i2 = 0; i2 < 64; i2++) {
      if (i2 < 16) {
        tmp = w[i2];
      } else {
        a = w[i2 + 1 & 15];
        b2 = w[i2 + 14 & 15];
        tmp = w[i2 & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b2 >>> 17 ^ b2 >>> 19 ^ b2 >>> 10 ^ b2 << 15 ^ b2 << 13) + w[i2 & 15] + w[i2 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i2];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base64(bytes);
}
__name(sha2562, "sha256");
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x) {
    return (x - Math.floor(x)) * 4294967296;
  }
  __name(frac, "frac");
  let prime = 2;
  for (let i = 0; i < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i < 8) {
        init[i] = frac(prime ** (1 / 2));
      }
      key[i] = frac(prime ** (1 / 3));
      i++;
    }
  }
}
__name(precompute, "precompute");
function reverse_endianness(bytes) {
  for (let i = 0; i < bytes.length; i += 4) {
    const a = bytes[i + 0];
    const b2 = bytes[i + 1];
    const c2 = bytes[i + 2];
    const d = bytes[i + 3];
    bytes[i + 0] = d;
    bytes[i + 1] = c2;
    bytes[i + 2] = b2;
    bytes[i + 3] = a;
  }
}
__name(reverse_endianness, "reverse_endianness");
function encode(str) {
  const encoded = encoder$2.encode(str);
  const length = encoded.length * 8;
  const size2 = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size2 / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
__name(encode, "encode");
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes) {
  const l = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < l; i += 3) {
    result += chars[bytes[i - 2] >> 2];
    result += chars[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += chars[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += chars[bytes[i] & 63];
  }
  if (i === l + 1) {
    result += chars[bytes[i - 2] >> 2];
    result += chars[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += chars[bytes[i - 2] >> 2];
    result += chars[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += chars[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
__name(base64, "base64");
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return base64(array);
}
__name(generate_nonce, "generate_nonce");
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var BaseProvider = class {
  static {
    __name(this, "BaseProvider");
  }
  /** @type {boolean} */
  #use_hashes;
  /** @type {boolean} */
  #script_needs_csp;
  /** @type {boolean} */
  #script_src_needs_csp;
  /** @type {boolean} */
  #script_src_elem_needs_csp;
  /** @type {boolean} */
  #style_needs_csp;
  /** @type {boolean} */
  #style_src_needs_csp;
  /** @type {boolean} */
  #style_src_attr_needs_csp;
  /** @type {boolean} */
  #style_src_elem_needs_csp;
  /** @type {import('types').CspDirectives} */
  #directives;
  /** @type {import('types').Csp.Source[]} */
  #script_src;
  /** @type {import('types').Csp.Source[]} */
  #script_src_elem;
  /** @type {import('types').Csp.Source[]} */
  #style_src;
  /** @type {import('types').Csp.Source[]} */
  #style_src_attr;
  /** @type {import('types').Csp.Source[]} */
  #style_src_elem;
  /** @type {string} */
  #nonce;
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    this.#use_hashes = use_hashes;
    this.#directives = directives;
    const d = this.#directives;
    this.#script_src = [];
    this.#script_src_elem = [];
    this.#style_src = [];
    this.#style_src_attr = [];
    this.#style_src_elem = [];
    const effective_script_src = d["script-src"] || d["default-src"];
    const script_src_elem = d["script-src-elem"];
    const effective_style_src = d["style-src"] || d["default-src"];
    const style_src_attr = d["style-src-attr"];
    const style_src_elem = d["style-src-elem"];
    const needs_csp = /* @__PURE__ */ __name((directive) => !!directive && !directive.some((value) => value === "unsafe-inline"), "needs_csp");
    this.#script_src_needs_csp = needs_csp(effective_script_src);
    this.#script_src_elem_needs_csp = needs_csp(script_src_elem);
    this.#style_src_needs_csp = needs_csp(effective_style_src);
    this.#style_src_attr_needs_csp = needs_csp(style_src_attr);
    this.#style_src_elem_needs_csp = needs_csp(style_src_elem);
    this.#script_needs_csp = this.#script_src_needs_csp || this.#script_src_elem_needs_csp;
    this.#style_needs_csp = this.#style_src_needs_csp || this.#style_src_attr_needs_csp || this.#style_src_elem_needs_csp;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    this.#nonce = nonce;
  }
  /** @param {string} content */
  add_script(content) {
    if (!this.#script_needs_csp) return;
    const source2 = this.#use_hashes ? `sha256-${sha2562(content)}` : `nonce-${this.#nonce}`;
    if (this.#script_src_needs_csp) {
      this.#script_src.push(source2);
    }
    if (this.#script_src_elem_needs_csp) {
      this.#script_src_elem.push(source2);
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (!this.#style_needs_csp) return;
    const source2 = this.#use_hashes ? `sha256-${sha2562(content)}` : `nonce-${this.#nonce}`;
    if (this.#style_src_needs_csp) {
      this.#style_src.push(source2);
    }
    if (this.#style_src_attr_needs_csp) {
      this.#style_src_attr.push(source2);
    }
    if (this.#style_src_elem_needs_csp) {
      const sha256_empty_comment_hash = "sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=";
      const d = this.#directives;
      if (d["style-src-elem"] && !d["style-src-elem"].includes(sha256_empty_comment_hash) && !this.#style_src_elem.includes(sha256_empty_comment_hash)) {
        this.#style_src_elem.push(sha256_empty_comment_hash);
      }
      if (source2 !== sha256_empty_comment_hash) {
        this.#style_src_elem.push(source2);
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#style_src_attr.length > 0) {
      directives["style-src-attr"] = [
        ...directives["style-src-attr"] || [],
        ...this.#style_src_attr
      ];
    }
    if (this.#style_src_elem.length > 0) {
      directives["style-src-elem"] = [
        ...directives["style-src-elem"] || [],
        ...this.#style_src_elem
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    if (this.#script_src_elem.length > 0) {
      directives["script-src-elem"] = [
        ...directives["script-src-elem"] || [],
        ...this.#script_src_elem
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key2]
      );
      if (!value) continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
};
var CspProvider = class extends BaseProvider {
  static {
    __name(this, "CspProvider");
  }
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content="${escape_html2(content, true)}">`;
  }
};
var CspReportOnlyProvider = class extends BaseProvider {
  static {
    __name(this, "CspReportOnlyProvider");
  }
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v) => !!v).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
};
var Csp = class {
  static {
    __name(this, "Csp");
  }
  /** @readonly */
  nonce = generate_nonce();
  /** @type {CspProvider} */
  csp_provider;
  /** @type {CspReportOnlyProvider} */
  report_only_provider;
  /**
   * @param {import('./types.js').CspConfig} config
   * @param {import('./types.js').CspOpts} opts
   */
  constructor({ mode, directives, reportOnly }, { prerender }) {
    const use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
};
function defer() {
  let fulfil;
  let reject;
  const promise = new Promise((f, r3) => {
    fulfil = f;
    reject = r3;
  });
  return { promise, fulfil, reject };
}
__name(defer, "defer");
function create_async_iterator() {
  const deferred = [defer()];
  return {
    iterator: {
      [Symbol.asyncIterator]() {
        return {
          next: /* @__PURE__ */ __name(async () => {
            const next = await deferred[0].promise;
            if (!next.done) deferred.shift();
            return next;
          }, "next")
        };
      }
    },
    push: /* @__PURE__ */ __name((value) => {
      deferred[deferred.length - 1].fulfil({
        value,
        done: false
      });
      deferred.push(defer());
    }, "push"),
    done: /* @__PURE__ */ __name(() => {
      deferred[deferred.length - 1].fulfil({ done: true });
    }, "done")
  };
}
__name(create_async_iterator, "create_async_iterator");
function exec(match, params, matchers) {
  const result = {};
  const values2 = match.slice(1);
  const values_needing_match = values2.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i = 0; i < params.length; i += 1) {
    const param = params[i];
    let value = values2[i - buffered];
    if (param.chained && param.rest && buffered) {
      value = values2.slice(i - buffered, i + 1).filter((s22) => s22).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest) result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params[i + 1];
      const next_value = values2[i + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered) return;
  return result;
}
__name(exec, "exec");
function generate_route_object(route, url, manifest2) {
  const { errors, layouts, leaf } = route;
  const nodes = [...errors, ...layouts.map((l) => l?.[1]), leaf[1]].filter((n2) => typeof n2 === "number").map((n2) => `'${n2}': () => ${create_client_import(manifest2._.client.nodes?.[n2], url)}`).join(",\n		");
  return [
    `{
	id: ${s(route.id)}`,
    `errors: ${s(route.errors)}`,
    `layouts: ${s(route.layouts)}`,
    `leaf: ${s(route.leaf)}`,
    `nodes: {
		${nodes}
	}
}`
  ].join(",\n	");
}
__name(generate_route_object, "generate_route_object");
function create_client_import(import_path, url) {
  if (!import_path) return "Promise.resolve({})";
  if (import_path[0] === "/") {
    return `import('${import_path}')`;
  }
  if (assets !== "") {
    return `import('${assets}/${import_path}')`;
  }
  let path2 = get_relative_path(url.pathname, `${base}/${import_path}`);
  if (path2[0] !== ".") path2 = `./${path2}`;
  return `import('${path2}')`;
}
__name(create_client_import, "create_client_import");
async function resolve_route(resolved_path, url, manifest2) {
  if (!manifest2._.client.routes) {
    return text2("Server-side route resolution disabled", { status: 400 });
  }
  let route = null;
  let params = {};
  const matchers = await manifest2._.matchers();
  for (const candidate of manifest2._.client.routes) {
    const match = candidate.pattern.exec(resolved_path);
    if (!match) continue;
    const matched = exec(match, candidate.params, matchers);
    if (matched) {
      route = candidate;
      params = decode_params(matched);
      break;
    }
  }
  return create_server_routing_response(route, params, url, manifest2).response;
}
__name(resolve_route, "resolve_route");
function create_server_routing_response(route, params, url, manifest2) {
  const headers2 = new Headers({
    "content-type": "application/javascript; charset=utf-8"
  });
  if (route) {
    const csr_route = generate_route_object(route, url, manifest2);
    const body2 = `${create_css_import(route, url, manifest2)}
export const route = ${csr_route}; export const params = ${JSON.stringify(params)};`;
    return { response: text2(body2, { headers: headers2 }), body: body2 };
  } else {
    return { response: text2("", { headers: headers2 }), body: "" };
  }
}
__name(create_server_routing_response, "create_server_routing_response");
function create_css_import(route, url, manifest2) {
  const { errors, layouts, leaf } = route;
  let css = "";
  for (const node of [...errors, ...layouts.map((l) => l?.[1]), leaf[1]]) {
    if (typeof node !== "number") continue;
    const node_css = manifest2._.client.css?.[node];
    for (const css_path of node_css ?? []) {
      css += `'${assets || base}/${css_path}',`;
    }
  }
  if (!css) return "";
  return `${create_client_import(
    /** @type {string} */
    manifest2._.client.start,
    url
  )}.then(x => x.load_css([${css}]));`;
}
__name(create_css_import, "create_css_import");
var updated = {
  ...readable(false),
  check: /* @__PURE__ */ __name(() => false, "check")
};
var encoder$1 = new TextEncoder();
async function render_response({
  branch: branch2,
  fetched,
  options: options2,
  manifest: manifest2,
  state: state2,
  page_config,
  status,
  error: error3 = null,
  event,
  resolve_opts,
  action_result
}) {
  if (state2.prerendering) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client: client2 } = manifest2._;
  const modulepreloads = new Set(client2.imports);
  const stylesheets10 = new Set(client2.stylesheets);
  const fonts10 = new Set(client2.fonts);
  const link_header_preloads = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  {
    if (!state2.prerendering?.fallback) {
      const segments = event.url.pathname.slice(base.length).split("/").slice(2);
      base$1 = segments.map(() => "..").join("/") || ".";
      base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
      if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
        assets$1 = base$1;
      }
    } else if (options2.hash_routing) {
      base_expression = "new URL('.', location).pathname.slice(0, -1)";
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(
        branch2.map(({ node }) => {
          if (!node.component) {
            throw new Error(`Missing +page.svelte component for route ${event.route.id}`);
          }
          return node.component();
        })
      ),
      form: form_value
    };
    let data2 = {};
    for (let i = 0; i < branch2.length; i += 1) {
      data2 = { ...data2, ...branch2[i].data };
      props[`data_${i}`] = data2;
    }
    props.page = {
      error: error3,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data2,
      form: form_value,
      state: {}
    };
    override({ base: base$1, assets: assets$1 });
    const render_opts = {
      context: /* @__PURE__ */ new Map([
        [
          "__request__",
          {
            page: props.page
          }
        ]
      ])
    };
    {
      try {
        rendered = options2.root.render(props, render_opts);
      } finally {
        reset2();
      }
    }
    for (const { node } of branch2) {
      for (const url of node.imports) modulepreloads.add(url);
      for (const url of node.stylesheets) stylesheets10.add(url);
      for (const url of node.fonts) fonts10.add(url);
      if (node.inline_styles && !client2.inline) {
        Object.entries(await node.inline_styles()).forEach(([k, v]) => inline_styles.set(k, v));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head = "";
  let body2 = rendered.html;
  const csp = new Csp(options2.csp, {
    prerender: !!state2.prerendering
  });
  const prefixed = /* @__PURE__ */ __name((path2) => {
    if (path2.startsWith("/")) {
      return base + path2;
    }
    return `${assets$1}/${path2}`;
  }, "prefixed");
  const style = client2.inline ? client2.inline?.style : Array.from(inline_styles.values()).join("\n");
  if (style) {
    const attributes = [];
    if (csp.style_needs_nonce) attributes.push(` nonce="${csp.nonce}"`);
    csp.add_style(style);
    head += `
	<style${attributes.join("")}>${style}</style>`;
  }
  for (const dep of stylesheets10) {
    const path2 = prefixed(dep);
    const attributes = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path: path2 })) {
        const preload_atts = ['rel="preload"', 'as="style"'];
        link_header_preloads.add(`<${encodeURI(path2)}>; ${preload_atts.join(";")}; nopush`);
      }
    }
    head += `
		<link href="${path2}" ${attributes.join(" ")}>`;
  }
  for (const dep of fonts10) {
    const path2 = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path: path2 })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      const attributes = [
        'rel="preload"',
        'as="font"',
        `type="font/${ext}"`,
        `href="${path2}"`,
        "crossorigin"
      ];
      head += `
		<link ${attributes.join(" ")}>`;
    }
  }
  const global = `__sveltekit_${options2.version_hash}`;
  const { data, chunks } = get_data(
    event,
    options2,
    branch2.map((b2) => b2.server_data),
    csp,
    global
  );
  if (page_config.ssr && page_config.csr) {
    body2 += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state2.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    const route = manifest2._.client.routes?.find((r3) => r3.id === event.route.id) ?? null;
    if (client2.uses_env_dynamic_public && state2.prerendering) {
      modulepreloads.add(`${app_dir}/env.js`);
    }
    if (!client2.inline) {
      const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
        (path2) => resolve_opts.preload({ type: "js", path: path2 })
      );
      for (const path2 of included_modulepreloads) {
        link_header_preloads.add(`<${encodeURI(path2)}>; rel="modulepreload"; nopush`);
        if (options2.preload_strategy !== "modulepreload") {
          head += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path2}">`;
        } else if (state2.prerendering) {
          head += `
		<link rel="modulepreload" href="${path2}">`;
        }
      }
    }
    if (manifest2._.client.routes && state2.prerendering && !state2.prerendering.fallback) {
      const pathname = add_resolution_suffix(event.url.pathname);
      state2.prerendering.dependencies.set(
        pathname,
        create_server_routing_response(route, event.params, new URL(pathname, event.url), manifest2)
      );
    }
    const blocks = [];
    const load_env_eagerly = client2.uses_env_dynamic_public && state2.prerendering;
    const properties = [`base: ${base_expression}`];
    if (assets) {
      properties.push(`assets: ${s(assets)}`);
    }
    if (client2.uses_env_dynamic_public) {
      properties.push(`env: ${load_env_eagerly ? "null" : s(public_env)}`);
    }
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      properties.push(`resolve: ({ id, data, error }) => {
							const try_to_resolve = () => {
								if (!deferred.has(id)) {
									setTimeout(try_to_resolve, 0);
									return;
								}
								const { fulfil, reject } = deferred.get(id);
								deferred.delete(id);
								if (error) reject(error);
								else fulfil(data);
							}
							try_to_resolve();
						}`);
    }
    blocks.push(`${global} = {
						${properties.join(",\n						")}
					};`);
    const args = ["element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        );
      }
      if (error3) {
        serialized.error = uneval(error3);
      }
      const hydrate2 = [
        `node_ids: [${branch2.map(({ node }) => node.index).join(", ")}]`,
        `data: ${data}`,
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate2.push(`status: ${status}`);
      }
      if (manifest2._.client.routes) {
        if (route) {
          const stringified2 = generate_route_object(route, event.url, manifest2).replaceAll(
            "\n",
            "\n							"
          );
          hydrate2.push(`params: ${uneval(event.params)}`, `server_route: ${stringified2}`);
        }
      } else if (options2.embedded) {
        hydrate2.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      const indent = "	".repeat(load_env_eagerly ? 7 : 6);
      args.push(`{
${indent}	${hydrate2.join(`,
${indent}	`)}
${indent}}`);
    }
    const boot = client2.inline ? `${client2.inline.script}

					__sveltekit_${options2.version_hash}.app.start(${args.join(", ")});` : client2.app ? `Promise.all([
						import(${s(prefixed(client2.start))}),
						import(${s(prefixed(client2.app))})
					]).then(([kit, app]) => {
						kit.start(app, ${args.join(", ")});
					});` : `import(${s(prefixed(client2.start))}).then((app) => {
						app.start(${args.join(", ")})
					});`;
    if (load_env_eagerly) {
      blocks.push(`import(${s(`${base$1}/${app_dir}/env.js`)}).then(({ env }) => {
						${global}.env = env;

						${boot.replace(/\n/g, "\n	")}
					});`);
    } else {
      blocks.push(boot);
    }
    if (options2.service_worker) {
      const opts = "";
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body2 += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers2 = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state2.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state2.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state2.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers2.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers2.set("content-security-policy-report-only", report_only_header);
    }
    if (link_header_preloads.size) {
      headers2.set("link", Array.from(link_header_preloads).join(", "));
    }
  }
  head += rendered.head;
  const html = options2.templates.app({
    head,
    body: body2,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: safe_public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers2.set("etag", `"${hash2(transformed)}"`);
  }
  return !chunks ? text2(transformed, {
    status,
    headers: headers2
  }) : new Response(
    new ReadableStream({
      async start(controller) {
        controller.enqueue(encoder$1.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          controller.enqueue(encoder$1.encode(chunk));
        }
        controller.close();
      },
      type: "bytes"
    }),
    {
      headers: headers2
    }
  );
}
__name(render_response, "render_response");
function get_data(event, options2, nodes, csp, global) {
  let promise_id = 1;
  let count3 = 0;
  const { iterator: iterator2, push: push4, done } = create_async_iterator();
  function replacer(thing) {
    if (typeof thing?.then === "function") {
      const id = promise_id++;
      count3 += 1;
      thing.then(
        /** @param {any} data */
        (data) => ({ data })
      ).catch(
        /** @param {any} error */
        async (error3) => ({
          error: await handle_error_and_jsonify(event, options2, error3)
        })
      ).then(
        /**
         * @param {{data: any; error: any}} result
         */
        async ({ data, error: error3 }) => {
          count3 -= 1;
          let str;
          try {
            str = uneval({ id, data, error: error3 }, replacer);
          } catch {
            error3 = await handle_error_and_jsonify(
              event,
              options2,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            data = void 0;
            str = uneval({ id, data, error: error3 }, replacer);
          }
          const nonce = csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : "";
          push4(`<script${nonce}>${global}.resolve(${str})<\/script>
`);
          if (count3 === 0) done();
        }
      );
      return `${global}.defer(${id})`;
    } else {
      for (const key2 in options2.hooks.transport) {
        const encoded = options2.hooks.transport[key2].encode(thing);
        if (encoded) {
          return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
        }
      }
    }
  }
  __name(replacer, "replacer");
  try {
    const strings = nodes.map((node) => {
      if (!node) return "null";
      const payload = { type: "data", data: node.data, uses: serialize_uses(node) };
      if (node.slash) payload.slash = node.slash;
      return uneval(payload, replacer);
    });
    return {
      data: `[${strings.join(",")}]`,
      chunks: count3 > 0 ? iterator2 : null
    };
  } catch (e3) {
    e3.path = e3.path.slice(1);
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
__name(get_data, "get_data");
var PageNodes = class {
  static {
    __name(this, "PageNodes");
  }
  data;
  /**
   * @param {Array<import('types').SSRNode | undefined>} nodes
   */
  constructor(nodes) {
    this.data = nodes;
  }
  layouts() {
    return this.data.slice(0, -1);
  }
  page() {
    return this.data.at(-1);
  }
  validate() {
    for (const layout of this.layouts()) {
      if (layout) {
        validate_layout_server_exports(
          layout.server,
          /** @type {string} */
          layout.server_id
        );
        validate_layout_exports(
          layout.universal,
          /** @type {string} */
          layout.universal_id
        );
      }
    }
    const page2 = this.page();
    if (page2) {
      validate_page_server_exports(
        page2.server,
        /** @type {string} */
        page2.server_id
      );
      validate_page_exports(
        page2.universal,
        /** @type {string} */
        page2.universal_id
      );
    }
  }
  /**
   * @template {'prerender' | 'ssr' | 'csr' | 'trailingSlash'} Option
   * @param {Option} option
   * @returns {Value | undefined}
   */
  #get_option(option) {
    return this.data.reduce(
      (value, node) => {
        return node?.universal?.[option] ?? node?.server?.[option] ?? value;
      },
      /** @type {Value | undefined} */
      void 0
    );
  }
  csr() {
    return this.#get_option("csr") ?? true;
  }
  ssr() {
    return this.#get_option("ssr") ?? true;
  }
  prerender() {
    return this.#get_option("prerender") ?? false;
  }
  trailing_slash() {
    return this.#get_option("trailingSlash") ?? "never";
  }
  get_config() {
    let current = {};
    for (const node of this.data) {
      if (!node?.universal?.config && !node?.server?.config) continue;
      current = {
        ...current,
        // TODO: should we override the server config value with the universal value similar to other page options?
        ...node?.universal?.config,
        ...node?.server?.config
      };
    }
    return Object.keys(current).length ? current : void 0;
  }
  should_prerender_data() {
    return this.data.some(
      // prerender in case of trailingSlash because the client retrieves that value from the server
      (node) => node?.server?.load || node?.server?.trailingSlash !== void 0
    );
  }
};
async function respond_with_error({
  event,
  options: options2,
  manifest: manifest2,
  state: state2,
  status,
  error: error3,
  resolve_opts
}) {
  if (event.request.headers.get("x-sveltekit-error")) {
    return static_error_page(
      options2,
      status,
      /** @type {Error} */
      error3.message
    );
  }
  const fetched = [];
  try {
    const branch2 = [];
    const default_layout = await manifest2._.nodes[0]();
    const nodes = new PageNodes([default_layout]);
    const ssr2 = nodes.ssr();
    const csr = nodes.csr();
    if (ssr2) {
      state2.error = true;
      const server_data_promise = load_server_data({
        event,
        state: state2,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: /* @__PURE__ */ __name(async () => ({}), "parent")
      });
      const server_data = await server_data_promise;
      const data = await load_data({
        event,
        fetched,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: /* @__PURE__ */ __name(async () => ({}), "parent"),
        resolve_opts,
        server_data_promise,
        state: state2,
        csr
      });
      branch2.push(
        {
          node: default_layout,
          server_data,
          data
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options2,
      manifest: manifest2,
      state: state2,
      page_config: {
        ssr: ssr2,
        csr
      },
      status,
      error: await handle_error_and_jsonify(event, options2, error3),
      branch: branch2,
      fetched,
      event,
      resolve_opts
    });
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return redirect_response(e3.status, e3.location);
    }
    return static_error_page(
      options2,
      get_status(e3),
      (await handle_error_and_jsonify(event, options2, e3)).message
    );
  }
}
__name(respond_with_error, "respond_with_error");
function once2(fn) {
  let done = false;
  let result;
  return () => {
    if (done) return result;
    done = true;
    return result = fn();
  };
}
__name(once2, "once");
var encoder2 = new TextEncoder();
async function render_data(event, route, options2, manifest2, state2, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted2 = false;
    const url = new URL(event.url);
    url.pathname = normalize_path(url.pathname, trailing_slash);
    const new_event = { ...event, url };
    const functions = node_ids.map((n2, i) => {
      return once2(async () => {
        try {
          if (aborted2) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n2 == void 0 ? n2 : await manifest2._.nodes[n2]();
          return load_server_data({
            event: new_event,
            state: state2,
            node,
            parent: /* @__PURE__ */ __name(async () => {
              const data2 = {};
              for (let j = 0; j < i; j += 1) {
                const parent = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions[j]()
                );
                if (parent) {
                  Object.assign(data2, parent.data);
                }
              }
              return data2;
            }, "parent")
          });
        } catch (e3) {
          aborted2 = true;
          throw e3;
        }
      });
    });
    const promises = functions.map(async (fn, i) => {
      if (!invalidated[i]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p, i) => p.catch(async (error3) => {
          if (error3 instanceof Redirect) {
            throw error3;
          }
          length = Math.min(length, i + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, options2, error3),
              status: error3 instanceof HttpError || error3 instanceof SvelteKitError ? error3.status : void 0
            }
          );
        })
      )
    );
    const { data, chunks } = get_data_json(event, options2, nodes);
    if (!chunks) {
      return json_response(data);
    }
    return new Response(
      new ReadableStream({
        async start(controller) {
          controller.enqueue(encoder2.encode(data));
          for await (const chunk of chunks) {
            controller.enqueue(encoder2.encode(chunk));
          }
          controller.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e3) {
    const error3 = normalize_error(e3);
    if (error3 instanceof Redirect) {
      return redirect_json_response(error3);
    } else {
      return json_response(await handle_error_and_jsonify(event, options2, error3), 500);
    }
  }
}
__name(render_data, "render_data");
function json_response(json22, status = 200) {
  return text2(typeof json22 === "string" ? json22 : JSON.stringify(json22), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
__name(json_response, "json_response");
function redirect_json_response(redirect2) {
  return json_response({
    type: "redirect",
    location: redirect2.location
  });
}
__name(redirect_json_response, "redirect_json_response");
function get_data_json(event, options2, nodes) {
  let promise_id = 1;
  let count3 = 0;
  const { iterator: iterator2, push: push4, done } = create_async_iterator();
  const reducers = {
    ...Object.fromEntries(
      Object.entries(options2.hooks.transport).map(([key2, value]) => [key2, value.encode])
    ),
    /** @param {any} thing */
    Promise: /* @__PURE__ */ __name((thing) => {
      if (typeof thing?.then === "function") {
        const id = promise_id++;
        count3 += 1;
        let key2 = "data";
        thing.catch(
          /** @param {any} e */
          async (e3) => {
            key2 = "error";
            return handle_error_and_jsonify(
              event,
              options2,
              /** @type {any} */
              e3
            );
          }
        ).then(
          /** @param {any} value */
          async (value) => {
            let str;
            try {
              str = stringify2(value, reducers);
            } catch {
              const error3 = await handle_error_and_jsonify(
                event,
                options2,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              key2 = "error";
              str = stringify2(error3, reducers);
            }
            count3 -= 1;
            push4(`{"type":"chunk","id":${id},"${key2}":${str}}
`);
            if (count3 === 0) done();
          }
        );
        return id;
      }
    }, "Promise")
  };
  try {
    const strings = nodes.map((node) => {
      if (!node) return "null";
      if (node.type === "error" || node.type === "skip") {
        return JSON.stringify(node);
      }
      return `{"type":"data","data":${stringify2(node.data, reducers)},"uses":${JSON.stringify(
        serialize_uses(node)
      )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `{"type":"data","nodes":[${strings.join(",")}]}
`,
      chunks: count3 > 0 ? iterator2 : null
    };
  } catch (e3) {
    e3.path = "data" + e3.path;
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
__name(get_data_json, "get_data_json");
var MAX_DEPTH = 10;
async function render_page(event, page2, options2, manifest2, state2, nodes, resolve_opts) {
  if (state2.depth > MAX_DEPTH) {
    return text2(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page2.leaf]();
    return handle_action_json_request(event, options2, node?.server);
  }
  try {
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.page()
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      action_result = await handle_action_request(event, leaf_node.server);
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        status = get_status(action_result.error);
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender = nodes.prerender();
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state2.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state2.prerender_default = should_prerender;
    const should_prerender_data = nodes.should_prerender_data();
    const data_pathname = add_data_suffix(event.url.pathname);
    const fetched = [];
    const ssr2 = nodes.ssr();
    const csr = nodes.csr();
    if (ssr2 === false && !(state2.prerendering && should_prerender_data)) {
      if (DEV && action_result && !event.request.headers.has("x-sveltekit-action")) ;
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr
        },
        status,
        error: null,
        event,
        options: options2,
        manifest: manifest2,
        state: state2,
        resolve_opts
      });
    }
    const branch2 = [];
    let load_error = null;
    const server_promises = nodes.data.map((node, i) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          return await load_server_data({
            event,
            state: state2,
            node,
            parent: /* @__PURE__ */ __name(async () => {
              const data = {};
              for (let j = 0; j < i; j += 1) {
                const parent = await server_promises[j];
                if (parent) Object.assign(data, parent.data);
              }
              return data;
            }, "parent")
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    const load_promises = nodes.data.map((node, i) => {
      if (load_error) throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            fetched,
            node,
            parent: /* @__PURE__ */ __name(async () => {
              const data = {};
              for (let j = 0; j < i; j += 1) {
                Object.assign(data, await load_promises[j]);
              }
              return data;
            }, "parent"),
            resolve_opts,
            server_data_promise: server_promises[i],
            state: state2,
            csr
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    for (const p of server_promises) p.catch(() => {
    });
    for (const p of load_promises) p.catch(() => {
    });
    for (let i = 0; i < nodes.data.length; i += 1) {
      const node = nodes.data[i];
      if (node) {
        try {
          const server_data = await server_promises[i];
          const data = await load_promises[i];
          branch2.push({ node, server_data, data });
        } catch (e3) {
          const err2 = normalize_error(e3);
          if (err2 instanceof Redirect) {
            if (state2.prerendering && should_prerender_data) {
              const body2 = JSON.stringify({
                type: "redirect",
                location: err2.location
              });
              state2.prerendering.dependencies.set(data_pathname, {
                response: text2(body2),
                body: body2
              });
            }
            return redirect_response(err2.status, err2.location);
          }
          const status2 = get_status(err2);
          const error3 = await handle_error_and_jsonify(event, options2, err2);
          while (i--) {
            if (page2.errors[i]) {
              const index10 = (
                /** @type {number} */
                page2.errors[i]
              );
              const node2 = await manifest2._.nodes[index10]();
              let j = i;
              while (!branch2[j]) j -= 1;
              const layouts = compact(branch2.slice(0, j + 1));
              const nodes2 = new PageNodes(layouts.map((layout) => layout.node));
              return await render_response({
                event,
                options: options2,
                manifest: manifest2,
                state: state2,
                resolve_opts,
                page_config: {
                  ssr: nodes2.ssr(),
                  csr: nodes2.csr()
                },
                status: status2,
                error: error3,
                branch: layouts.concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched
              });
            }
          }
          return static_error_page(options2, status2, error3.message);
        }
      } else {
        branch2.push(null);
      }
    }
    if (state2.prerendering && should_prerender_data) {
      let { data, chunks } = get_data_json(
        event,
        options2,
        branch2.map((node) => node?.server_data)
      );
      if (chunks) {
        for await (const chunk of chunks) {
          data += chunk;
        }
      }
      state2.prerendering.dependencies.set(data_pathname, {
        response: text2(data),
        body: data
      });
    }
    return await render_response({
      event,
      options: options2,
      manifest: manifest2,
      state: state2,
      resolve_opts,
      page_config: {
        csr,
        ssr: ssr2
      },
      status,
      error: null,
      branch: ssr2 === false ? [] : compact(branch2),
      action_result,
      fetched
    });
  } catch (e3) {
    return await respond_with_error({
      event,
      options: options2,
      manifest: manifest2,
      state: state2,
      status: 500,
      error: e3,
      resolve_opts
    });
  }
}
__name(render_page, "render_page");
var INVALID_COOKIE_CHARACTER_REGEX = /[\x00-\x1F\x7F()<>@,;:"/[\]?={} \t]/;
function validate_options(options2) {
  if (options2?.path === void 0) {
    throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
  }
}
__name(validate_options, "validate_options");
function get_cookies(request, url) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = (0, import_cookie2.parse)(header, { decode: /* @__PURE__ */ __name((value) => value, "decode") });
  let normalized_url;
  const new_cookies = {};
  const defaults = {
    httpOnly: true,
    sameSite: "lax",
    secure: url.hostname === "localhost" && url.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} [opts]
     */
    get(name, opts) {
      const c2 = new_cookies[name];
      if (c2 && domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
        return c2.value;
      }
      const req_cookies = (0, import_cookie2.parse)(header, { decode: opts?.decode });
      const cookie = req_cookies[name];
      return cookie;
    },
    /**
     * @param {import('cookie').CookieParseOptions} [opts]
     */
    getAll(opts) {
      const cookies2 = (0, import_cookie2.parse)(header, { decode: opts?.decode });
      for (const c2 of Object.values(new_cookies)) {
        if (domain_matches(url.hostname, c2.options.domain) && path_matches(url.pathname, c2.options.path)) {
          cookies2[c2.name] = c2.value;
        }
      }
      return Object.entries(cookies2).map(([name, value]) => ({ name, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('./page/types.js').Cookie['options']} options
     */
    set(name, value, options2) {
      const illegal_characters = name.match(INVALID_COOKIE_CHARACTER_REGEX);
      if (illegal_characters) {
        console.warn(
          `The cookie name "${name}" will be invalid in SvelteKit 3.0 as it contains ${illegal_characters.join(
            " and "
          )}. See RFC 2616 for more details https://datatracker.ietf.org/doc/html/rfc2616#section-2.2`
        );
      }
      validate_options(options2);
      set_internal(name, value, { ...defaults, ...options2 });
    },
    /**
     * @param {string} name
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    delete(name, options2) {
      validate_options(options2);
      cookies.set(name, "", { ...options2, maxAge: 0 });
    },
    /**
     * @param {string} name
     * @param {string} value
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    serialize(name, value, options2) {
      validate_options(options2);
      let path2 = options2.path;
      if (!options2.domain || options2.domain === url.hostname) {
        if (!normalized_url) {
          throw new Error("Cannot serialize cookies until after the route is determined");
        }
        path2 = resolve(normalized_url, path2);
      }
      return (0, import_cookie2.serialize)(name, value, { ...defaults, ...options2, path: path2 });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const key2 in new_cookies) {
      const cookie = new_cookies[key2];
      if (!domain_matches(destination.hostname, cookie.options.domain)) continue;
      if (!path_matches(destination.pathname, cookie.options.path)) continue;
      const encoder22 = cookie.options.encode || encodeURIComponent;
      combined_cookies[cookie.name] = encoder22(cookie.value);
    }
    if (header2) {
      const parsed = (0, import_cookie2.parse)(header2, { decode: /* @__PURE__ */ __name((value) => value, "decode") });
      for (const name in parsed) {
        combined_cookies[name] = parsed[name];
      }
    }
    return Object.entries(combined_cookies).map(([name, value]) => `${name}=${value}`).join("; ");
  }
  __name(get_cookie_header, "get_cookie_header");
  const internal_queue = [];
  function set_internal(name, value, options2) {
    if (!normalized_url) {
      internal_queue.push(() => set_internal(name, value, options2));
      return;
    }
    let path2 = options2.path;
    if (!options2.domain || options2.domain === url.hostname) {
      path2 = resolve(normalized_url, path2);
    }
    new_cookies[name] = { name, value, options: { ...options2, path: path2 } };
  }
  __name(set_internal, "set_internal");
  function set_trailing_slash(trailing_slash) {
    normalized_url = normalize_path(url.pathname, trailing_slash);
    internal_queue.forEach((fn) => fn());
  }
  __name(set_trailing_slash, "set_trailing_slash");
  return { cookies, new_cookies, get_cookie_header, set_internal, set_trailing_slash };
}
__name(get_cookies, "get_cookies");
function domain_matches(hostname, constraint) {
  if (!constraint) return true;
  const normalized = constraint[0] === "." ? constraint.slice(1) : constraint;
  if (hostname === normalized) return true;
  return hostname.endsWith("." + normalized);
}
__name(domain_matches, "domain_matches");
function path_matches(path2, constraint) {
  if (!constraint) return true;
  const normalized = constraint.endsWith("/") ? constraint.slice(0, -1) : constraint;
  if (path2 === normalized) return true;
  return path2.startsWith(normalized + "/");
}
__name(path_matches, "path_matches");
function add_cookies_to_headers(headers2, cookies) {
  for (const new_cookie of cookies) {
    const { name, value, options: options2 } = new_cookie;
    headers2.append("set-cookie", (0, import_cookie2.serialize)(name, value, options2));
    if (options2.path.endsWith(".html")) {
      const path2 = add_data_suffix(options2.path);
      headers2.append("set-cookie", (0, import_cookie2.serialize)(name, value, { ...options2, path: path2 }));
    }
  }
}
__name(add_cookies_to_headers, "add_cookies_to_headers");
function create_fetch({ event, options: options2, manifest: manifest2, state: state2, get_cookie_header, set_internal }) {
  const server_fetch = /* @__PURE__ */ __name(async (info3, init2) => {
    const original_request = normalize_fetch_input(info3, init2, event.url);
    let mode = (info3 instanceof Request ? info3.mode : init2?.mode) ?? "cors";
    let credentials = (info3 instanceof Request ? info3.credentials : init2?.credentials) ?? "same-origin";
    return options2.hooks.handleFetch({
      event,
      request: original_request,
      fetch: /* @__PURE__ */ __name(async (info22, init3) => {
        const request = normalize_fetch_input(info22, init3, event.url);
        const url = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info22 !== original_request) {
          mode = (info22 instanceof Request ? info22.mode : init3?.mode) ?? "cors";
          credentials = (info22 instanceof Request ? info22.credentials : init3?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode === "no-cors" && url.origin !== event.url.origin || url.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url.origin !== event.url.origin) {
          if (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie = get_cookie_header(url, request.headers.get("cookie"));
            if (cookie) request.headers.set("cookie", cookie);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename) || filename in manifest2._.server_assets;
        const is_asset_html = manifest2.assets.has(filename_html) || filename_html in manifest2._.server_assets;
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (state2.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state2.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          } else if (read_implementation && file in manifest2._.server_assets) {
            const length = manifest2._.server_assets[file];
            const type = manifest2.mimeTypes[file.slice(file.lastIndexOf("."))];
            return new Response(read_implementation(file), {
              headers: {
                "Content-Length": "" + length,
                "Content-Type": type
              }
            });
          }
          return await fetch(request);
        }
        if (has_prerendered_path(manifest2, base + decoded)) {
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie = get_cookie_header(url, request.headers.get("cookie"));
          if (cookie) {
            request.headers.set("cookie", cookie);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await respond(request, options2, manifest2, {
          ...state2,
          depth: state2.depth + 1
        });
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str of set_cookie_parser.splitCookiesString(set_cookie)) {
            const { name, value, ...options3 } = set_cookie_parser.parseString(str, {
              decodeValues: false
            });
            const path2 = options3.path ?? (url.pathname.split("/").slice(0, -1).join("/") || "/");
            set_internal(name, value, {
              path: path2,
              encode: /* @__PURE__ */ __name((value2) => value2, "encode"),
              .../** @type {import('cookie').CookieSerializeOptions} */
              options3
            });
          }
        }
        return response;
      }, "fetch")
    });
  }, "server_fetch");
  return (input, init2) => {
    const response = server_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
__name(create_fetch, "create_fetch");
function normalize_fetch_input(info3, init2, url) {
  if (info3 instanceof Request) {
    return info3;
  }
  return new Request(typeof info3 === "string" ? new URL(info3, url) : info3, init2);
}
__name(normalize_fetch_input, "normalize_fetch_input");
var body;
var etag;
var headers;
function get_public_env(request) {
  body ??= `export const env=${JSON.stringify(public_env)}`;
  etag ??= `W/${Date.now()}`;
  headers ??= new Headers({
    "content-type": "application/javascript; charset=utf-8",
    etag
  });
  if (request.headers.get("if-none-match") === etag) {
    return new Response(void 0, { status: 304, headers });
  }
  return new Response(body, { headers });
}
__name(get_public_env, "get_public_env");
var default_transform = /* @__PURE__ */ __name(({ html }) => html, "default_transform");
var default_filter = /* @__PURE__ */ __name(() => false, "default_filter");
var default_preload = /* @__PURE__ */ __name(({ type }) => type === "js" || type === "css", "default_preload");
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
async function respond(request, options2, manifest2, state2) {
  const url = new URL(request.url);
  if (options2.csrf_check_origin) {
    const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request.headers.get("origin") !== url.origin;
    if (forbidden) {
      const csrf_error = new HttpError(
        403,
        `Cross-site ${request.method} form submissions are forbidden`
      );
      if (request.headers.get("accept") === "application/json") {
        return json2(csrf_error.body, { status: csrf_error.status });
      }
      return text2(csrf_error.body.message, { status: csrf_error.status });
    }
  }
  if (options2.hash_routing && url.pathname !== base + "/" && url.pathname !== "/[fallback]") {
    return text2("Not found", { status: 404 });
  }
  let invalidated_data_nodes;
  const is_route_resolution_request = has_resolution_suffix(url.pathname);
  const is_data_request = has_data_suffix(url.pathname);
  if (is_route_resolution_request) {
    url.pathname = strip_resolution_suffix(url.pathname);
  } else if (is_data_request) {
    url.pathname = strip_data_suffix(url.pathname) + (url.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url.searchParams.delete(INVALIDATED_PARAM);
  }
  const headers2 = {};
  const { cookies, new_cookies, get_cookie_header, set_internal, set_trailing_slash } = get_cookies(
    request,
    url
  );
  const event = {
    cookies,
    // @ts-expect-error `fetch` needs to be created after the `event` itself
    fetch: null,
    getClientAddress: state2.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-cloudflare"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params: {},
    platform: state2.platform,
    request,
    route: { id: null },
    setHeaders: /* @__PURE__ */ __name((new_headers) => {
      for (const key2 in new_headers) {
        const lower = key2.toLowerCase();
        const value = new_headers[key2];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers2) {
          throw new Error(`"${key2}" header is already set`);
        } else {
          headers2[lower] = value;
          if (state2.prerendering && lower === "cache-control") {
            state2.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    }, "setHeaders"),
    url,
    isDataRequest: is_data_request,
    isSubRequest: state2.depth > 0
  };
  event.fetch = create_fetch({
    event,
    options: options2,
    manifest: manifest2,
    state: state2,
    get_cookie_header,
    set_internal
  });
  if (state2.emulator?.platform) {
    event.platform = await state2.emulator.platform({
      config: {},
      prerender: !!state2.prerendering?.fallback
    });
  }
  let resolved_path;
  const prerendering_reroute_state = state2.prerendering?.inside_reroute;
  try {
    if (state2.prerendering) state2.prerendering.inside_reroute = true;
    resolved_path = await options2.hooks.reroute({ url: new URL(url), fetch: event.fetch }) ?? url.pathname;
  } catch {
    return text2("Internal Server Error", {
      status: 500
    });
  } finally {
    if (state2.prerendering) state2.prerendering.inside_reroute = prerendering_reroute_state;
  }
  try {
    resolved_path = decode_pathname(resolved_path);
  } catch {
    return text2("Malformed URI", { status: 400 });
  }
  if (resolved_path !== url.pathname && !state2.prerendering?.fallback && has_prerendered_path(manifest2, resolved_path)) {
    const url2 = new URL(request.url);
    url2.pathname = is_data_request ? add_data_suffix(resolved_path) : is_route_resolution_request ? add_resolution_suffix(resolved_path) : resolved_path;
    const response = await fetch(url2, request);
    const headers22 = new Headers(response.headers);
    if (headers22.has("content-encoding")) {
      headers22.delete("content-encoding");
      headers22.delete("content-length");
    }
    return new Response(response.body, {
      headers: headers22,
      status: response.status,
      statusText: response.statusText
    });
  }
  let route = null;
  if (base && !state2.prerendering?.fallback) {
    if (!resolved_path.startsWith(base)) {
      return text2("Not found", { status: 404 });
    }
    resolved_path = resolved_path.slice(base.length) || "/";
  }
  if (is_route_resolution_request) {
    return resolve_route(resolved_path, new URL(request.url), manifest2);
  }
  if (resolved_path === `/${app_dir}/env.js`) {
    return get_public_env(request);
  }
  if (resolved_path.startsWith(`/${app_dir}`)) {
    const headers22 = new Headers();
    headers22.set("cache-control", "public, max-age=0, must-revalidate");
    return text2("Not found", { status: 404, headers: headers22 });
  }
  if (!state2.prerendering?.fallback) {
    const matchers = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match = candidate.pattern.exec(resolved_path);
      if (!match) continue;
      const matched = exec(match, candidate.params, matchers);
      if (matched) {
        route = candidate;
        event.route = { id: route.id };
        event.params = decode_params(matched);
        break;
      }
    }
  }
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  let trailing_slash = "never";
  try {
    const page_nodes = route?.page ? new PageNodes(await load_page_nodes(route.page, manifest2)) : void 0;
    if (route) {
      if (url.pathname === base || url.pathname === base + "/") {
        trailing_slash = "always";
      } else if (page_nodes) {
        if (DEV) ;
        trailing_slash = page_nodes.trailing_slash();
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash ?? "never";
        if (DEV) ;
      }
      if (!is_data_request) {
        const normalized = normalize_path(url.pathname, trailing_slash);
        if (normalized !== url.pathname && !state2.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
              )
            }
          });
        }
      }
      if (state2.before_handle || state2.emulator?.platform) {
        let config2 = {};
        let prerender = false;
        if (route.endpoint) {
          const node = await route.endpoint();
          config2 = node.config ?? config2;
          prerender = node.prerender ?? prerender;
        } else if (page_nodes) {
          config2 = page_nodes.get_config() ?? config2;
          prerender = page_nodes.prerender();
        }
        if (state2.before_handle) {
          state2.before_handle(event, config2, prerender);
        }
        if (state2.emulator?.platform) {
          event.platform = await state2.emulator.platform({ config: config2, prerender });
        }
      }
    }
    set_trailing_slash(trailing_slash);
    if (state2.prerendering && !state2.prerendering.fallback && !state2.prerendering.inside_reroute) {
      disable_search(url);
    }
    const response = await with_event(
      event,
      () => options2.hooks.handle({
        event,
        resolve: /* @__PURE__ */ __name((event2, opts) => (
          // counter-intuitively, we need to clear the event, so that it's not
          // e.g. accessible when loading modules needed to handle the request
          with_event(
            null,
            () => resolve2(event2, page_nodes, opts).then((response2) => {
              for (const key2 in headers2) {
                const value = headers2[key2];
                response2.headers.set(
                  key2,
                  /** @type {string} */
                  value
                );
              }
              add_cookies_to_headers(response2.headers, Object.values(new_cookies));
              if (state2.prerendering && event2.route.id !== null) {
                response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
              }
              return response2;
            })
          )
        ), "resolve")
      })
    );
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag2 = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag2) {
        const headers22 = new Headers({ etag: etag2 });
        for (const key2 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key2);
          if (value) headers22.set(key2, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers22
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location2 = response.headers.get("location");
      if (location2) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location2
        ));
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      const response = is_data_request ? redirect_json_response(e3) : route?.page && is_action_json_request(event) ? action_json_redirect(e3) : redirect_response(e3.status, e3.location);
      add_cookies_to_headers(response.headers, Object.values(new_cookies));
      return response;
    }
    return await handle_fatal_error(event, options2, e3);
  }
  async function resolve2(event2, page_nodes, opts) {
    try {
      if (opts) {
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (options2.hash_routing || state2.prerendering?.fallback) {
        return await render_response({
          event: event2,
          options: options2,
          manifest: manifest2,
          state: state2,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts
        });
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response;
        if (is_data_request) {
          response = await render_data(
            event2,
            route,
            options2,
            manifest2,
            state2,
            invalidated_data_nodes,
            trailing_slash
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response = await render_endpoint(event2, await route.endpoint(), state2);
        } else if (route.page) {
          if (!page_nodes) {
            throw new Error("page_nodes not found. This should never happen");
          } else if (page_methods.has(method)) {
            response = await render_page(
              event2,
              route.page,
              options2,
              manifest2,
              state2,
              page_nodes,
              resolve_opts
            );
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("Route is neither page nor endpoint. This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response.headers.get("vary")?.split(",")?.map((v) => v.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response = new Response(response.body, {
              status: response.status,
              statusText: response.statusText,
              headers: new Headers(response.headers)
            });
            response.headers.append("Vary", "Accept");
          }
        }
        return response;
      }
      if (state2.error && event2.isSubRequest) {
        const headers22 = new Headers(request.headers);
        headers22.set("x-sveltekit-error", "true");
        return await fetch(request, { headers: headers22 });
      }
      if (state2.error) {
        return text2("Internal Server Error", {
          status: 500
        });
      }
      if (state2.depth === 0) {
        if (DEV && event2.url.pathname === "/.well-known/appspecific/com.chrome.devtools.json") ;
        return await respond_with_error({
          event: event2,
          options: options2,
          manifest: manifest2,
          state: state2,
          status: 404,
          error: new SvelteKitError(404, "Not Found", `Not found: ${event2.url.pathname}`),
          resolve_opts
        });
      }
      if (state2.prerendering) {
        return text2("not found", { status: 404 });
      }
      return await fetch(request);
    } catch (e3) {
      return await handle_fatal_error(event2, options2, e3);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
  __name(resolve2, "resolve2");
}
__name(respond, "respond");
function load_page_nodes(page2, manifest2) {
  return Promise.all([
    // we use == here rather than === because [undefined] serializes as "[null]"
    ...page2.layouts.map((n2) => n2 == void 0 ? n2 : manifest2._.nodes[n2]()),
    manifest2._.nodes[page2.leaf]()
  ]);
}
__name(load_page_nodes, "load_page_nodes");
function filter_private_env(env2, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env2).filter(
      ([k]) => k.startsWith(private_prefix) && (public_prefix === "" || !k.startsWith(public_prefix))
    )
  );
}
__name(filter_private_env, "filter_private_env");
function filter_public_env(env2, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env2).filter(
      ([k]) => k.startsWith(public_prefix) && (private_prefix === "" || !k.startsWith(private_prefix))
    )
  );
}
__name(filter_public_env, "filter_public_env");
function set_app(value) {
}
__name(set_app, "set_app");
var prerender_env_handler = {
  get({ type }, prop) {
    throw new Error(
      `Cannot read values from $env/dynamic/${type} while prerendering (attempted to read env.${prop.toString()}). Use $env/static/${type} instead`
    );
  }
};
var init_promise;
var Server = class {
  static {
    __name(this, "Server");
  }
  /** @type {import('types').SSROptions} */
  #options;
  /** @type {import('@sveltejs/kit').SSRManifest} */
  #manifest;
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    this.#options = options;
    this.#manifest = manifest2;
  }
  /**
   * @param {{
   *   env: Record<string, string>;
   *   read?: (file: string) => ReadableStream;
   * }} opts
   */
  async init({ env: env2, read }) {
    const prefixes = {
      public_prefix: this.#options.env_public_prefix,
      private_prefix: this.#options.env_private_prefix
    };
    const private_env = filter_private_env(env2, prefixes);
    const public_env2 = filter_public_env(env2, prefixes);
    set_private_env(
      prerendering ? new Proxy({ type: "private" }, prerender_env_handler) : private_env
    );
    set_public_env(
      prerendering ? new Proxy({ type: "public" }, prerender_env_handler) : public_env2
    );
    set_safe_public_env(public_env2);
    if (read) {
      set_read_implementation(read);
    }
    await (init_promise ??= (async () => {
      try {
        const module = await get_hooks();
        this.#options.hooks = {
          handle: module.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
          handleError: module.handleError || (({ status, error: error3 }) => console.error(status === 404 && /** @type {Error} */
          error3?.message || error3)),
          handleFetch: module.handleFetch || (({ request, fetch: fetch2 }) => fetch2(request)),
          reroute: module.reroute || (() => {
          }),
          transport: module.transport || {}
        };
        set_app({
          decoders: module.transport ? Object.fromEntries(Object.entries(module.transport).map(([k, v]) => [k, v.decode])) : {}
        });
        if (module.init) {
          await module.init();
        }
      } catch (error3) {
        {
          throw error3;
        }
      }
    })());
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options2) {
    return respond(request, this.#options, this.#manifest, {
      ...options2,
      error: false,
      depth: 0
    });
  }
};

// .svelte-kit/cloudflare-tmp/manifest.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ??= value = fn();
  }
  __name(__memo, "__memo");
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["favicon.png"]),
    mimeTypes: { ".png": "image/png" },
    _: {
      client: { start: "_app/immutable/entry/start.BcfMiieC.js", app: "_app/immutable/entry/app.1T_CC7gk.js", imports: ["_app/immutable/entry/start.BcfMiieC.js", "_app/immutable/chunks/DkGiYyGV.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/C2P0YLJE.js", "_app/immutable/entry/app.1T_CC7gk.js", "_app/immutable/chunks/DS17_zEZ.js", "_app/immutable/chunks/BH2dqj3a.js", "_app/immutable/chunks/BbmRlLdw.js", "_app/immutable/chunks/CWIBd0RA.js", "_app/immutable/chunks/BbFkPdsf.js", "_app/immutable/chunks/CWj6FrbW.js", "_app/immutable/chunks/C2P0YLJE.js", "_app/immutable/chunks/Ccvmo-eH.js", "_app/immutable/chunks/ClG5jPII.js"], stylesheets: [], fonts: [], uses_env_dynamic_public: false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5))),
        __memo(() => Promise.resolve().then(() => (init__6(), __exports6))),
        __memo(() => Promise.resolve().then(() => (init__7(), __exports7))),
        __memo(() => Promise.resolve().then(() => (init__8(), __exports8))),
        __memo(() => Promise.resolve().then(() => (init__9(), __exports9)))
      ],
      routes: [
        {
          id: "/",
          pattern: /^\/$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 2 },
          endpoint: null
        },
        {
          id: "/account",
          pattern: /^\/account\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 3 },
          endpoint: null
        },
        {
          id: "/account/login",
          pattern: /^\/account\/login\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 4 },
          endpoint: null
        },
        {
          id: "/account/logout",
          pattern: /^\/account\/logout\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 5 },
          endpoint: null
        },
        {
          id: "/account/register",
          pattern: /^\/account\/register\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 6 },
          endpoint: null
        },
        {
          id: "/events",
          pattern: /^\/events\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 7 },
          endpoint: null
        },
        {
          id: "/shopping-list",
          pattern: /^\/shopping-list\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 8 },
          endpoint: null
        }
      ],
      prerendered_routes: /* @__PURE__ */ new Set([]),
      matchers: /* @__PURE__ */ __name(async () => {
        return {};
      }, "matchers"),
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var base_path = "";

// .svelte-kit/cloudflare/_worker.js
async function e(e3, t22) {
  let n2 = "string" != typeof t22 && "HEAD" === t22.method;
  n2 && (t22 = new Request(t22, { method: "GET" }));
  let r3 = await e3.match(t22);
  return n2 && r3 && (r3 = new Response(null, r3)), r3;
}
__name(e, "e");
function t2(e3, t22, n2, o2) {
  return ("string" == typeof t22 || "GET" === t22.method) && r(n2) && (n2.headers.has("Set-Cookie") && (n2 = new Response(n2.body, n2)).headers.append("Cache-Control", "private=Set-Cookie"), o2.waitUntil(e3.put(t22, n2.clone()))), n2;
}
__name(t2, "t");
var n = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r(e3) {
  if (!n.has(e3.status)) return false;
  if (~(e3.headers.get("Vary") || "").indexOf("*")) return false;
  let t22 = e3.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t22);
}
__name(r, "r");
function o(n2) {
  return async function(r3, o2) {
    let a = await e(n2, r3);
    if (a) return a;
    o2.defer((e3) => {
      t2(n2, r3, e3, o2);
    });
  };
}
__name(o, "o");
var s2 = caches.default;
var c = t2.bind(0, s2);
var r2 = e.bind(0, s2);
var e2 = o.bind(0, s2);
var server = new Server(manifest);
var app_path = `/${manifest.appPath}`;
var immutable = `${app_path}/immutable/`;
var version_file = `${app_path}/version.json`;
var worker_default = {
  /**
   * @param {Request} req
   * @param {{ ASSETS: { fetch: typeof fetch } }} env
   * @param {ExecutionContext} context
   * @returns {Promise<Response>}
   */
  async fetch(req, env2, context3) {
    await server.init({
      // @ts-expect-error env contains environment variables and bindings
      env: env2
    });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r2(req);
    if (res) return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.slice(base_path.length + 1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
    }
    let location2 = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env2.ASSETS.fetch(req);
    } else if (location2 && prerendered.has(location2)) {
      if (search) location2 += search;
      res = new Response("", {
        status: 308,
        headers: {
          location: location2
        }
      });
    } else {
      res = await server.respond(req, {
        platform: {
          env: env2,
          context: context3,
          // @ts-expect-error webworker types from worktop are not compatible with Cloudflare Workers types
          caches,
          // @ts-expect-error the type is correct but ts is confused because platform.cf uses the type from index.ts while req.cf uses the type from index.d.ts
          cf: req.cf
        },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c(req, res, context3) : res;
  }
};
export {
  worker_default as default
};
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=_worker.js.map
